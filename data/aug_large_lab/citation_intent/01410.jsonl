{"text":"Your heuristic for the FoodSearchProblem goes here . . .This heuristic must be consistent to ensure correctness .First , try to come up .with an admissible heuristic ; almost all admissible heuristics will be consistent .On the other hand , . inadmissible or inconsistent heuristics may find optimal solutions , so be careful . . .","label":"Uses","metadata":{},"score":"81.46628"}
{"text":"To select an agent , use the ' -p ' option .when running pacman.py .Arguments can be passed to your agent . using ' -a ' .For example , to load a SearchAgent that uses .depth first search ( dfs ) , run the following command : .","label":"Uses","metadata":{},"score":"86.530624"}
{"text":"supplied search problem , then returns actions to follow that path . . .As a default , this agent runs DFS on a PositionSearchProblem to find location ( 1,1 ) .Options for fn include : .depthFirstSearch or dfs .","label":"Uses","metadata":{},"score":"87.94479"}
{"text":"uniformCostSearch .An agent for position search with a cost function that penalizes being in . positions on the East side of the board . . .The cost function for stepping into a position ( x , y ) is 2^x . .","label":"Uses","metadata":{},"score":"88.51294"}
{"text":"Returns successor states , the actions they require , and a cost of 1 . . .As noted in search.py : .For a given state , this should return a list of triples , .( successor , action , stepCost ) , where ' successor ' is a .","label":"Uses","metadata":{},"score":"89.43257"}
{"text":"Grid ( see game.py ) of either True or False .You can call foodGrid.asList ( ) .to get a list of food coordinates instead . . .If you want access to info like walls , capsules , etc . , you can query the problem .","label":"Uses","metadata":{},"score":"93.68589"}
{"text":"gameState : A GameState object ( pacman.py ) .costFn : A function from a search state ( tuple ) to a non - negative number .goal : A position in the gameState . \" \" \" self .getWalls ( ) self .","label":"Uses","metadata":{},"score":"94.017746"}
{"text":"( You need not worry about consistency for .this heuristic to receive full credit . ) aStarSearch ( prob , cornersHeuristic ) self .A search problem associated with finding the a path that collects all of the . food ( dots ) in a Pacman game . . .","label":"Uses","metadata":{},"score":"95.665665"}
{"text":"An agent for position search with a cost function that penalizes being in . positions on the West side of the board . . .The cost function for stepping into a position ( x , y ) is 1/2^x . .","label":"Uses","metadata":{},"score":"95.71908"}
{"text":"that will complete the problem definition . raiseNotDefined( ) # # # # # # # # # # # # # # # # # # .# Mini - contest 1 # .# # # # # # # # # # # # # # # # # # class ApproximateSearchAgent ( Agent ): \" Implement your contest entry here .","label":"Uses","metadata":{},"score":"96.012955"}
{"text":"getCostOfActions ( self .actions ) print ( ' Path found with total cost of % d in % .1f seconds ' % ( totalCost , time . time ( ) - starttime ) ) if ' _ expanded ' in dir ( problem ): print ( ' Search nodes expanded : % d ' % problem .","label":"Uses","metadata":{},"score":"96.10259"}
{"text":"\" From game.py : .The Agent will receive a GameState and must return an action from .Directions . raiseNotDefined( ) def mazeDistance ( point1 , point2 , gameState ): \" \" \" .Returns the maze distance between any two points , using the search functions .","label":"Uses","metadata":{},"score":"97.781136"}
{"text":"actions [ i ] else : return Directions .STOP class PositionSearchProblem ( search .SearchProblem ): \" \" \" .A search problem defines the state space , start state , goal test , . successor function and cost function .","label":"Uses","metadata":{},"score":"98.4396"}
{"text":"For a given state , this should return a list of triples , .( successor , action , stepCost ) , where ' successor ' is a .successor to the current state , ' action ' is the action .","label":"Uses","metadata":{},"score":"98.44967"}
{"text":"_ visitedlist . append ( state ) return successors def getCostOfActions ( self , actions ): \" \" \" .Returns the cost of a particular sequence of actions .If those actions . include an illegal move , return 999999 . \"","label":"Uses","metadata":{},"score":"98.784004"}
{"text":"This search problem finds paths through all four corners of a layout .You must select a suitable state space and successor function . \" \" \" def _ _ init _ _ ( self , startingGameState ): \" \" \" .","label":"Uses","metadata":{},"score":"98.84457"}
{"text":"# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class SearchAgent ( Agent ): \" \" \" .","label":"Uses","metadata":{},"score":"100.03836"}
{"text":"getGhostPosition ( a ) for a in others if state .spreadProb / numBest .spreadProb ) / len ( legalActions ) return distribution","label":"Uses","metadata":{},"score":"100.13839"}
{"text":"Please only change the parts of the file you are asked to .Look for the lines that say .\" The parts you fill in start about 3/4 of the way down .Follow the . project description for details .","label":"Uses","metadata":{},"score":"100.199875"}
{"text":"uniformCostSearch .# This portion is incomplete .Time to write code ! # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class CornersProblem ( search .","label":"Uses","metadata":{},"score":"100.44122"}
{"text":"required to get there , and ' stepCost ' is the incremental .cost of expanding to that successor . \" NORTH , Directions .SOUTH , Directions .EAST , Directions .WEST ] : # Add a successor state to the successor list if the action is legal .","label":"Uses","metadata":{},"score":"100.532745"}
{"text":"The gameState can be any game state -- Pacman 's position . in that state is ignored . . .Example usage : mazeDistance ( ( 2,4 ) , ( 5,6 ) , gameState ) .This might be a useful helper function for your ApproximateSearchAgent . bfs ( prob ) ) # helloWorld.py # ------------- # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"102.21318"}
{"text":"Returns the cost of a particular sequence of actions .If those actions . include an illegal move , return 999999 .This is implemented for you .walls [ x ] [ y ] : return 999999 return len ( actions ) def cornersHeuristic ( state , problem ): \" \" \" .","label":"Uses","metadata":{},"score":"102.70515"}
{"text":"pacmanPosition : a tuple ( x , y ) of integers specifying Pacman 's position .foodGrid : a Grid ( see game.py ) of either True or False , specifying remaining food . \" \" \" def _ _ init _ _ ( self , startingGameState ): self .","label":"Uses","metadata":{},"score":"102.7977"}
{"text":"Here , we .choose a path to the goal .In this phase , the agent should compute the path to the . goal and store it in a local variable .All of the work is done in this method ! state : a GameState object ( pacman.py ) . \" \" \" if self .","label":"Uses","metadata":{},"score":"103.3083"}
{"text":"_ display .drawExpandedCells ( self ._ visitedlist ) # @UndefinedVariable return isGoal def getSuccessors ( self , state ): \" \" \" .Returns successor states , the actions they require , and a cost of 1 . . .","label":"Uses","metadata":{},"score":"103.59553"}
{"text":"For example , . if you only want to count the walls once and store that value , try : .Subsequent calls to this heuristic can access problem.heuristicInfo['wallCount ' ] . \"getFood ( ) .findPathToClosestDot ( currentState ) # The missing piece self .","label":"Uses","metadata":{},"score":"104.06384"}
{"text":"getFood ( ) # Store info for the PositionSearchProblem ( no need to change this ) self .getWalls ( ) self .getPacmanPosition ( ) self ._ visited , self ._ visitedlist , self .The state is Pacman 's position .","label":"Uses","metadata":{},"score":"104.06981"}
{"text":"Counter ( ) dist [ Directions .GhostAgent ): \" Chooses an action that distances the ghost from the other ghosts with probability spreadProb . \"getGhostState ( self .getLegalActions ( self .getGhostPosition ( self .getNumAgents ( ) ) if i ! index ] for a in others : assert state .","label":"Uses","metadata":{},"score":"104.13748"}
{"text":"co_varnames : print ( ' [ SearchAgent ] using function ' + fn ) self . print ( ' [ SearchAgent ] using function % s and heuristic % s ' % ( fn , heuristic ) ) # Note : this bit of Python trickery combines the search algorithm and the heuristic self . endswith ( ' Problem ' ): raise AttributeError , prob + ' is not a search problem type in SearchAgents.py . ' self .","label":"Uses","metadata":{},"score":"104.98389"}
{"text":"cost of expanding to that successor . \" NORTH , Directions .SOUTH , Directions .EAST , Directions .costFn ( nextState ) successors . append ( ( nextState , action , cost ) ) # Bookkeeping for display purposes self .","label":"Uses","metadata":{},"score":"105.120995"}
{"text":"The class definition above , AnyFoodSearchProblem(PositionSearchProblem ) , . inherits the methods of the PositionSearchProblem . . .You can use this search problem to help you fill in .the findPathToClosestDot method . \" \" def _ _ init _ _ ( self , gameState ): \" Stores information from the gameState .","label":"Uses","metadata":{},"score":"106.67408"}
{"text":"Note : You should NOT change any code in SearchAgent .\" # Get the search function from the name and heuristic if fn not in dir ( search ): raise AttributeError , fn + ' is not a search function in search.py . '","label":"Uses","metadata":{},"score":"107.5908"}
{"text":"You are free to use and extend these projects for educational # purposes .The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .Here 's the intended output of this script , once you fill it in : .","label":"Uses","metadata":{},"score":"107.66023"}
{"text":"( ) class AnyFoodSearchProblem ( PositionSearchProblem ): \" \" \" .A search problem for finding a path to any food . . .This search problem is just like the PositionSearchProblem , but . has a different goal test , which you need to fill in below .","label":"Uses","metadata":{},"score":"108.95935"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .To run this script , type . python buyLotsOfFruit.py .Once you have correctly implemented the buyLotsOfFruit function , .","label":"Uses","metadata":{},"score":"109.16542"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) . items ( ): print ' % s cost % f a pound ' % ( fruit , price ) # listcomp.py # ----------- # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"110.45682"}
{"text":"used to find paths to a particular point on the pacman board . . .The state space consists of ( x , y ) positions in a pacman game . . .Note : this search problem is fully specified ; you should NOT change it .","label":"Uses","metadata":{},"score":"110.5069"}
{"text":"getWalls ( ) self . start def isGoalState ( self , state ): return state [ 1 ] .NORTH , Directions .SOUTH , Directions .EAST , Directions . append ( ( ( ( nextx , nexty ) , nextFood ) , direction , 1 ) ) return successors def getCostOfActions ( self , actions ): \" \" \" Returns the cost of a particular sequence of actions .","label":"Uses","metadata":{},"score":"110.52788"}
{"text":"Returns the next action in the path chosen earlier ( in registerInitialState ) .Return .Directions .STOP if there is no further action to take . . .state : a GameState object ( pacman.py ) . \" \" \" if ' actionIndex ' not in dir ( self ): self . actionIndex self .","label":"Uses","metadata":{},"score":"111.4303"}
{"text":"Cost of [ ( ' apples ' , 2.0 ) , ( ' pears ' , 3.0 ) , ( ' limes ' , 4.0 ) ] is 12.25 . \" orderList : List of ( fruit , numPounds ) tuples .","label":"Uses","metadata":{},"score":"111.5336"}
{"text":"getWalls ( ) self .walls .height - 2 , self .walls .width - 2 self .corners : if not startingGameState . raiseNotDefined( ) def isGoalState ( self , state ): \" Returns whether this search state is a goal state of the problem \" . raiseNotDefined","label":"Uses","metadata":{},"score":"113.34544"}
{"text":"# searchAgents.py # --------------- # Licensing Information : Please do not distribute or publish solutions to this # project .You are free to use and extend these projects for educational # purposes .The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .","label":"Uses","metadata":{},"score":"114.12407"}
{"text":"\" if Directions .WEST in state .getLegalPacmanActions ( ): return Directions .WEST else : return Directions .STOP # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # .","label":"Uses","metadata":{},"score":"114.258995"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# quickSort.py # ------------ # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"114.40914"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# listcomp2.py # ------------ # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"114.44559"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# foreach.py # ---------- # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"115.85072"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# shopTest.py # ----------- # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"116.32669"}
{"text":"fruitShops : List of FruitShops . \" getName ( ) # bustersGhostAgents.py # --------------------- # Licensing Information : Please do not distribute or publish solutions to this # project .You are free to use and extend these projects for educational # purposes .","label":"Uses","metadata":{},"score":"116.76944"}
{"text":"state : The current search state .( a data structure you chose in your search problem ) .problem : The CornersProblem instance for this layout . . .This function should always return a number that is a lower bound . on the shortest path from the state to a goal of the problem ; i.e. .","label":"Uses","metadata":{},"score":"117.141655"}
{"text":"getNumFood ( ) !_ visited , self ._ visitedlist , self .goal # For display purposes only if isGoal : self ._ visitedlist . append ( state ) import _ _ main _ _ if ' _ display ' in dir ( _ _ main _ _ ): if ' drawExpandedCells ' in dir ( _ _ main _ _ .","label":"Uses","metadata":{},"score":"127.55727"}
{"text":"The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .getCostPerPound ( ' apples ' ) print otherPrice print ( ' Apples cost $ % .2f at % s. ' % ( otherPrice , otherName ) ) print ( \" My , that 's expensive ! \" ) # buyLotsOfFruit.py # ----------------- # Licensing Information : Please do not distribute or publish solutions to this # project .","label":"Uses","metadata":{},"score":"131.01712"}
{"text":"Welcome to shop2 fruit shop .For orders : [ ( ' apples ' , 1.0 ) , ( ' oranges ' , 3.0 ) ] best shop is shop1 .For orders : [ ( ' apples ' , 3.0 ) ] best shop is shop2 . \" \" \" import shop def shopSmart ( orderList , fruitShops ): \" \" \" .","label":"Uses","metadata":{},"score":"141.15672"}
