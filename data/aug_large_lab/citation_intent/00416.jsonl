{"text":"It must contain a short - term memory component which can hold several features before writing to the P - representation of the lexeme .This accounts for the fact that a single affix can represent several grammatical features ( cf .","label":"Background","metadata":{},"score":"29.055231"}{"text":"I strongly suspect that it is not possible to make any hard divisions or distinctions .In the case where the brain simply respects the grammar rules but does not explicitly represent them would still be a case of the brain representing those rules , but just implicitly .","label":"Background","metadata":{},"score":"30.340363"}{"text":"The field linguist doing the preliminary analysis of such a language might not notice at first the generality of the phonological processes , or he might notice the generality but be unable to account for the exceptions .He might need the help of a consultant , when one is available , to produce an account of allomorphy based on phonological rules .","label":"Background","metadata":{},"score":"32.706184"}{"text":"The field linguist doing the preliminary analysis of such a language might not notice at first the generality of the phonological processes , or he might notice the generality but be unable to account for the exceptions .He might need the help of a consultant , when one is available , to produce an account of allomorphy based on phonological rules .","label":"Background","metadata":{},"score":"32.706184"}{"text":"Hence their processing becomes a question of great importance , especially in lexicalized linguistic theories as HPSG .From the two possibilities of formalizing the lexical rules , meta - level approach ( Calcagno and Pollard 1995 ) and description - level approach ( in which lexical rules become a part of the theory ) , the author adopts the latter .","label":"Background","metadata":{},"score":"33.190582"}{"text":"Certainly the distinction makes intuitive sense .It 's easy to imagine an explicit representation there that is to be read off and used .And its also easy to imagine the other case , of a system with no representation , that just works in a way that respects the rules .","label":"Background","metadata":{},"score":"33.28305"}{"text":"It preserves the priorities about unifying control strategies for both NLP tasks -- parsing and generation , stated in the previous chapter .The author proposes a solution to the syntactic - under - determination ( such as spurious ambiguity ) from the bottom - up perspective , using magic ( templates ) transformation .","label":"Background","metadata":{},"score":"33.36866"}{"text":"His approach is considered as an alternative to approaches requiring manual encoding of control information for processing declarative grammars .Minnen 's approach is tested on an HPSG formalism as an example of the constraint - based grammars and relies on the interaction between bottom - up and top - down control strategies .","label":"Background","metadata":{},"score":"33.705757"}{"text":"Assuming the internal engine to be at least as complex as the user interface , this represents a considerable savings in program writing and maintenance .Moreover , should the IA model prove to be inadequate to the needs of a given language , the grammar that has been written up to that point can be retained ; translating the grammar into the more adequate IP model is as simple as switching the interface .","label":"Background","metadata":{},"score":"33.876373"}{"text":"Assuming the internal engine to be at least as complex as the user interface , this represents a considerable savings in program writing and maintenance .Moreover , should the IA model prove to be inadequate to the needs of a given language , the grammar that has been written up to that point can be retained ; translating the grammar into the more adequate IP model is as simple as switching the interface .","label":"Background","metadata":{},"score":"33.876373"}{"text":"With the right means of interpretation we can still ' read ' the implicit representation ( not that we , as people trying to understand how the brain works , necessarily have the means to determine this means of interpretation ) .","label":"Background","metadata":{},"score":"34.103973"}{"text":"The third subsection suggests that SUF theories in fact provide an \" escape \" mechanism which allows the translation of an MUF description into an SUF description in a way which is both mechanical and transparent to the user .The implication is that while an underlying parsing engine may implement SUF morphology internally , it can in fact process descriptions couched in terms of either SUF or MUF morphology , with a minor amount of preprocessing .","label":"Background","metadata":{},"score":"34.16412"}{"text":"The third subsection suggests that SUF theories in fact provide an \" escape \" mechanism which allows the translation of an MUF description into an SUF description in a way which is both mechanical and transparent to the user .The implication is that while an underlying parsing engine may implement SUF morphology internally , it can in fact process descriptions couched in terms of either SUF or MUF morphology , with a minor amount of preprocessing .","label":"Background","metadata":{},"score":"34.16412"}{"text":"Finally , as suggested in section 2 , there is also a pedagogical advantage to being able to display a description in two theoretical frameworks , particularly to the user who is unfamiliar with one of those frameworks .[ 10 ] .","label":"Background","metadata":{},"score":"34.283783"}{"text":"Finally , as suggested in section 2 , there is also a pedagogical advantage to being able to display a description in two theoretical frameworks , particularly to the user who is unfamiliar with one of those frameworks .[ 10 ] .","label":"Background","metadata":{},"score":"34.283783"}{"text":"In general , it seems better to apply the allomorphy rules before the phonological rules , with the understanding that phonological rules may further alter the output of the allomorphy rules .A difficulty could arise if a phonological rule obscured the boundary between two morphemes , making it difficult to determine where a morpheme ends and its environment begins .","label":"Background","metadata":{},"score":"35.12113"}{"text":"In general , it seems better to apply the allomorphy rules before the phonological rules , with the understanding that phonological rules may further alter the output of the allomorphy rules .A difficulty could arise if a phonological rule obscured the boundary between two morphemes , making it difficult to determine where a morpheme ends and its environment begins .","label":"Background","metadata":{},"score":"35.12113"}{"text":"Its advantage is its speed .CRITICAL EVALUATION The book presents an up - to - date view on automatic transformation of declarative logic grammars with respect to speeding - up their performance and in some cases insuring the termination .It highlights the role of the linguistic specifications for the efficient Natural Language Processing .","label":"Background","metadata":{},"score":"35.74794"}{"text":"It may seem a bit of a stretch to call such implicit cases ' representation ' .But if what I 'm suggesting is correct , then there 's no hard distinction between \" explicit representation \" and \" implicit representation \" , and thus the common meaning of representation is making a hard distinction that does n't exist .","label":"Background","metadata":{},"score":"35.77558"}{"text":"In effect , this proposal treats agreement explicitly as a phenomenon that involves merging of information contributed by various sources in the sentence .II .The syntax / semantics interface with respect to purposive adjuncts in English ( Chapter 2 ) .","label":"Background","metadata":{},"score":"36.29123"}{"text":"In effect , this proposal treats agreement explicitly as a phenomenon that involves merging of information contributed by various sources in the sentence .II .The syntax / semantics interface with respect to purposive adjuncts in English ( Chapter 2 ) .","label":"Background","metadata":{},"score":"36.29123"}{"text":"It is intended for computational linguists mainly , but its interdisciplinary approach makes it useful for formal linguists and computer scientists as well .The book focuses on the practical and theoretical problems that arise when processing with Constraint - logic grammars .","label":"Background","metadata":{},"score":"36.296364"}{"text":"The problem is that for all the structure , only one phonologically realizable lexeme has been inserted .The lexicon has two options : . remove the structure and nominalize the verb . fill in the structure with lexical categories it controlls ( Gender , Number , Noun Class ) .","label":"Background","metadata":{},"score":"36.533997"}{"text":"But from another point of view , the difference is less important than it might appear ; I claim there is a straightforward mapping from an Item - and - Arrangement description to an Item - and - Process description ( although not necessarily in the reverse direction ) .","label":"Background","metadata":{},"score":"36.649666"}{"text":"But from another point of view , the difference is less important than it might appear ; I claim there is a straightforward mapping from an Item - and - Arrangement description to an Item - and - Process description ( although not necessarily in the reverse direction ) .","label":"Background","metadata":{},"score":"36.649666"}{"text":"A new idea about the lexicon is suggested .The covariation lexicon is meant to include extended lexicon ( lexical entries specifying words that can or can not undergo lexical rule application ) and lexical rule predicates .The author is aware of the limitation areas such as spurious ambiguity and non - determinism .","label":"Background","metadata":{},"score":"36.681976"}{"text":"That information is fed in ordered fashion to short - term memory .The MS - module also contains a list of rules which responds to the information in its memory .In this diagram only the grammatical information is relevant , so only it is represented .","label":"Background","metadata":{},"score":"37.206696"}{"text":"I have no definite solutions to offer in this case , save to say that an IP analysis in both senses of the term ( affixes as rules , and single underlying forms ) may be more appropriate in these cases .","label":"Background","metadata":{},"score":"37.41707"}{"text":"I have no definite solutions to offer in this case , save to say that an IP analysis in both senses of the term ( affixes as rules , and single underlying forms ) may be more appropriate in these cases .","label":"Background","metadata":{},"score":"37.41707"}{"text":"Unfortunately , a descriptive linguist may not be able to afford the luxury of waiting for the correct theory to arrive !Even when the correct theory has been developed and become generally accepted by theoretical linguists , it may not be feasible to retrain the descriptive linguist , or the potential readers of his description , in the latest theory .","label":"Background","metadata":{},"score":"37.420433"}{"text":"Unfortunately , a descriptive linguist may not be able to afford the luxury of waiting for the correct theory to arrive !Even when the correct theory has been developed and become generally accepted by theoretical linguists , it may not be feasible to retrain the descriptive linguist , or the potential readers of his description , in the latest theory .","label":"Background","metadata":{},"score":"37.420433"}{"text":"14 ] That is , it is possible to define rules which apply to specific morphemes or rules which apply in the environment of a specific morpheme , even if there are homophones to which the rule should not apply .I am not concerned here with the detailed syntax of the two notations , but rather with the meaning of the two representations .","label":"Background","metadata":{},"score":"37.57431"}{"text":"14 ] That is , it is possible to define rules which apply to specific morphemes or rules which apply in the environment of a specific morpheme , even if there are homophones to which the rule should not apply .I am not concerned here with the detailed syntax of the two notations , but rather with the meaning of the two representations .","label":"Background","metadata":{},"score":"37.57431"}{"text":"Beard ( 1988 , 1995 ) argues that grammatical morphemes differ from lexemes in the following ways ( detailed arguments may be found in ' LMBM and Word Syntax ' at this website ) : . lexemes do not allow zero or empty forms ; morphemes do .","label":"Background","metadata":{},"score":"37.706978"}{"text":"However , it is sometimes the case that allomorphs which are clearly conditioned by the phonological environment can not be straightforwardly generated by current theories of phonology .Before turning to some examples , I should observe that this is a practical question , not a theoretical one .","label":"Background","metadata":{},"score":"37.855583"}{"text":"However , it is sometimes the case that allomorphs which are clearly conditioned by the phonological environment can not be straightforwardly generated by current theories of phonology .Before turning to some examples , I should observe that this is a practical question , not a theoretical one .","label":"Background","metadata":{},"score":"37.855583"}{"text":"The statement of allomorphy by means of multiple underlying forms would allow the linguist to do such text processing at this earlier stage of understanding , while still supporting the goal of eventually accounting for the allomorphy with phonological rules .I therefore claim that as a practical matter , a system for morphological description should allow the statement of allomorphy using an MUF model , particularly during the earlier stages of analysis .","label":"Background","metadata":{},"score":"37.98159"}{"text":"The statement of allomorphy by means of multiple underlying forms would allow the linguist to do such text processing at this earlier stage of understanding , while still supporting the goal of eventually accounting for the allomorphy with phonological rules .I therefore claim that as a practical matter , a system for morphological description should allow the statement of allomorphy using an MUF model , particularly during the earlier stages of analysis .","label":"Background","metadata":{},"score":"37.98159"}{"text":"In addition to the way in which natural classes are represented in the two programs , there are a number of additional differences , of which the major divergence lies in the treatment of morphosyntactic features .The following sections examine these differences in more detail .","label":"Background","metadata":{},"score":"38.484253"}{"text":"In addition to the way in which natural classes are represented in the two programs , there are a number of additional differences , of which the major divergence lies in the treatment of morphosyntactic features .The following sections examine these differences in more detail .","label":"Background","metadata":{},"score":"38.484253"}{"text":"Some people ( and I do n't think they 're the only ones ) talk about representations as if something was only a representation if it was in some fairly explicit form that can be read by some process which then interprets its meaning .","label":"Background","metadata":{},"score":"38.55652"}{"text":"There is a summary of the monograph contents as well .Chapter 2 is entitled \" Processing with Constraint - logic Grammars \" .In this chapter the formal preliminaries for the rest of the book are defined and explained .The chapter discusses two topics : definitions of constraint - logic grammars and processing with constraint - logic grammars .","label":"Background","metadata":{},"score":"38.612495"}{"text":"It is recommended that a conforming parser does not attempt to directly evaluate the JSON - LD frame and instead purely parse the input into a language - native data structure .Processors must act as if the initial context is defined in the outer - most level when processing JSON - LD documents .","label":"Background","metadata":{},"score":"38.624535"}{"text":"Indeed the breaking up of a morpheme by an infix is the common situation , without which there would be little reason to consider the affix to be an infix , rather than a prefix or suffix .The result is that the domain of the allomorphy rule for the morpheme into which the infix has been inserted is no longer contiguous ; it may be necessary to treat the infix as invisible for the purposes of the allomorphy rule affecting the morphemes composing the stem .","label":"Background","metadata":{},"score":"38.7716"}{"text":"Indeed the breaking up of a morpheme by an infix is the common situation , without which there would be little reason to consider the affix to be an infix , rather than a prefix or suffix .The result is that the domain of the allomorphy rule for the morpheme into which the infix has been inserted is no longer contiguous ; it may be necessary to treat the infix as invisible for the purposes of the allomorphy rule affecting the morphemes composing the stem .","label":"Background","metadata":{},"score":"38.7716"}{"text":"The syntax does not necessarily require applications to change their JSON , but allows to easily add meaning by adding context in a way that is either in - band or out - of - band .The syntax is designed to not disturb already deployed systems running on JSON , but provide a smooth upgrade path from JSON to JSON with added semantics .","label":"Background","metadata":{},"score":"38.84829"}{"text":"Hence , the LMBM lexicon contains neither bound nor free grammatical morphemes - both are the responsibility of morphological spelling .The layout of an LMBM grammar is illustrated in the table to the right : .What then are ' morphemes ' under this hypothesis ?","label":"Background","metadata":{},"score":"39.11382"}{"text":"For instance , the attachment of affixes under extrametricality ( McCarthy and Prince 1990 ) would be problematical .6 I am not making the converse claim , that all allomorphy rules can be mechanically translated into multiple allomorphs .The translation from multiple allomorph statements to allomorphy rules suffices for our purposes . 7 The question or ordering arises when allomorph rules are used to encode allomorphy ; I return to this issue in appendix 3 . 8 The reverse translation , from an SUF analysis to an MUF analysis , might also be possible .","label":"Background","metadata":{},"score":"39.226765"}{"text":"For instance , the attachment of affixes under extrametricality ( McCarthy and Prince 1990 ) would be problematical .6 I am not making the converse claim , that all allomorphy rules can be mechanically translated into multiple allomorphs .The translation from multiple allomorph statements to allomorphy rules suffices for our purposes . 7 The question or ordering arises when allomorph rules are used to encode allomorphy ; I return to this issue in appendix 3 . 8 The reverse translation , from an SUF analysis to an MUF analysis , might also be possible .","label":"Background","metadata":{},"score":"39.226765"}{"text":"No doubt there are answers to these questions , perhaps within some existing theory of phonology .My point is not that the rules can not be formulated , given the correct theory .Rather , my point is that we do yet not know which ( if any ) theory is correct .","label":"Background","metadata":{},"score":"39.267235"}{"text":"No doubt there are answers to these questions , perhaps within some existing theory of phonology .My point is not that the rules can not be formulated , given the correct theory .Rather , my point is that we do yet not know which ( if any ) theory is correct .","label":"Background","metadata":{},"score":"39.267235"}{"text":"In pursuing his aim , he discusses ' reversible grammars ' .According to him , the reversibility is accomplished via two distinct definitions for generating a grammar and parsing a grammar , both of which are derived from the grammar by means of a transformation .","label":"Background","metadata":{},"score":"40.014866"}{"text":"At any rate , the use of diacritic features makes it possible to directly encode in an SUF morphology anything which could be encoded in an MUF morphology .[ 7 ] .In summary , SUF theories retain an \" escape mechanism \" in the form of allomorphy rules for cases of phonologically conditioned allomorphy which resist treatment by general phonological rules .","label":"Background","metadata":{},"score":"40.14936"}{"text":"At any rate , the use of diacritic features makes it possible to directly encode in an SUF morphology anything which could be encoded in an MUF morphology .[ 7 ] .In summary , SUF theories retain an \" escape mechanism \" in the form of allomorphy rules for cases of phonologically conditioned allomorphy which resist treatment by general phonological rules .","label":"Background","metadata":{},"score":"40.14936"}{"text":"Alternatively ( as suggested by Anderson 1992 ) , zero morphemes will often not correspond to any affixation process whatsoever , and therefore need not be parsed .The examples thus far have dwelt on the phonological effects of affixation , plus the change in the part of speech .","label":"Background","metadata":{},"score":"40.354984"}{"text":"Alternatively ( as suggested by Anderson 1992 ) , zero morphemes will often not correspond to any affixation process whatsoever , and therefore need not be parsed .The examples thus far have dwelt on the phonological effects of affixation , plus the change in the part of speech .","label":"Background","metadata":{},"score":"40.354984"}{"text":"All algorithms described in this section are intended to operate on language - native data structures .That is , the serialization to a text - based JSON document is n't required as input or output to any of these algorithms and language - native data structures must be used where applicable . 3.1 Syntax Tokens and Keywords .","label":"Background","metadata":{},"score":"40.361073"}{"text":"The underlying motivation is the following : such an approach takes into account the peculiarities of the lexical rules as well as the exceptions to them .Last but not least , it is applied to finite - length lists and thus the problem with the potentially infinite lexicons is reduced .","label":"Background","metadata":{},"score":"40.669937"}{"text":"In other words , the duality - relevant mismatch is located between morpho / phonology and constituent ( syntactic and semantic ) structure , i.e. between a \" phenogrammatical \" and a \" tectogrammatical \" levels of representation .Fukushima 's approach to topicalisation employs topic- substitution and topic - addition lexical rules to the effect that the topic is interpreted as an element of the argument structure .","label":"Background","metadata":{},"score":"40.745045"}{"text":"In other words , the duality - relevant mismatch is located between morpho / phonology and constituent ( syntactic and semantic ) structure , i.e. between a \" phenogrammatical \" and a \" tectogrammatical \" levels of representation .Fukushima 's approach to topicalisation employs topic- substitution and topic - addition lexical rules to the effect that the topic is interpreted as an element of the argument structure .","label":"Background","metadata":{},"score":"40.745045"}{"text":"I maintain that it would still be desirable for a practical implementation of a morphological parser to allow the listing of allomorphs , i.e. to allow MUF morphology .Consider a field linguist who has begun work with a hypothetical unanalyzed language .","label":"Background","metadata":{},"score":"40.86588"}{"text":"I maintain that it would still be desirable for a practical implementation of a morphological parser to allow the listing of allomorphs , i.e. to allow MUF morphology .Consider a field linguist who has begun work with a hypothetical unanalyzed language .","label":"Background","metadata":{},"score":"40.86588"}{"text":"However , this specification allows for the expression of unlabled nodes , as most graph - based data sets on the Web contain a number of associated nodes that are not named and thus are not directly de - referenceable . 1.3","label":"Background","metadata":{},"score":"41.02769"}{"text":"He relies on several techniques and assumptions : Hoehfeld and Smolka 's ( 1988 ) investigations of the requirements for extension of a constraint language with relations ; closed world interpretation ( Gerdemann and King 1994 ) and Prolog notations .Some basic concepts on generation and parsing with these grammars are introduced .","label":"Background","metadata":{},"score":"41.078354"}{"text":"Literal rearrangement procedure uses as an indicator of the relative processing efficiency the notion of ' degree of non-determinism ' , which is applied to a literal .This is a measurement of the different instantiations of the literal with respect to its evaluation context -- the grammar and the instantiated parts of the literal .","label":"Background","metadata":{},"score":"41.444054"}{"text":"The \" escape mechanism \" of allomorphy rules is introduced , and it is argued that whatever the theoretical reasons may be for preferring single underlying form models , there are a number of reasons to allow languages to be described from the viewpoint of multiple underlying forms .","label":"Background","metadata":{},"score":"41.45761"}{"text":"The \" escape mechanism \" of allomorphy rules is introduced , and it is argued that whatever the theoretical reasons may be for preferring single underlying form models , there are a number of reasons to allow languages to be described from the viewpoint of multiple underlying forms .","label":"Background","metadata":{},"score":"41.45761"}{"text":"Similarly , circumfixes make the left and right environments ambiguous .In general , it will be difficult to establish a boundary between stem and affix whenever the affixal process has modified the stem by doing anything except attaching phonological material either before or after the stem ( but not both ) , or inserting more than a single infix .","label":"Background","metadata":{},"score":"41.956562"}{"text":"Similarly , circumfixes make the left and right environments ambiguous .In general , it will be difficult to establish a boundary between stem and affix whenever the affixal process has modified the stem by doing anything except attaching phonological material either before or after the stem ( but not both ) , or inserting more than a single infix .","label":"Background","metadata":{},"score":"41.956562"}{"text":"The effects of lexical and inflectional derivation on the lexeme do not affect its status as a sign at all .These processes , it follows , must involve elements other than linguistic signs .Lexical ( derivational ) and inflectional morphemes hence must represent different types of linguistic elements .","label":"Background","metadata":{},"score":"42.020287"}{"text":"29 ] This also works in an MUF system in which there are no ( morpho-)phonological rules .It is not clear that it will always produce the desired results in a mixed system in which some allomorphs are generated from underlying forms by phonological rule , and some by allomorphy rules , if the allomorphy rules are intended to represent surface - true generalizations .","label":"Background","metadata":{},"score":"42.067772"}{"text":"29 ] This also works in an MUF system in which there are no ( morpho-)phonological rules .It is not clear that it will always produce the desired results in a mixed system in which some allomorphs are generated from underlying forms by phonological rule , and some by allomorphy rules , if the allomorphy rules are intended to represent surface - true generalizations .","label":"Background","metadata":{},"score":"42.067772"}{"text":"Five appendices , a list of references and an Index follow the text body .The introduction explains the author 's motivation for practically oriented dealing with the topic and discusses the key words in his work : constraint - logic grammars , declarative under - determination and grammar compilation .","label":"Background","metadata":{},"score":"42.080364"}{"text":"As a practical matter , then , an implementation should allow the user to represent such situations using multiple allomorphs .It must be noted , however , that this problem is less of a factor to the extent that the phonological description allows the statement of unnatural rules .","label":"Background","metadata":{},"score":"42.351246"}{"text":"As a practical matter , then , an implementation should allow the user to represent such situations using multiple allomorphs .It must be noted , however , that this problem is less of a factor to the extent that the phonological description allows the statement of unnatural rules .","label":"Background","metadata":{},"score":"42.351246"}{"text":"Null affixes are also problematical , since it is arbitrary whether they should be prefixed or suffixed to a stem , rendering the question of left vs. right environment problematical .( We are not concerned so much with multiple null allomorphs of a single morpheme -- an unlikely analysis -- as with the question of an affix with non - null allomorphs in some environment , and a null allomorph in some other environment . )","label":"Background","metadata":{},"score":"42.633663"}{"text":"Null affixes are also problematical , since it is arbitrary whether they should be prefixed or suffixed to a stem , rendering the question of left vs. right environment problematical .( We are not concerned so much with multiple null allomorphs of a single morpheme -- an unlikely analysis -- as with the question of an affix with non - null allomorphs in some environment , and a null allomorph in some other environment . )","label":"Background","metadata":{},"score":"42.633663"}{"text":"The translation from the lexical entry in ( 2 ) to the rule in ( 1 ) is transparent .In fact , rules like that in ( 1 ) can be generated mechanically from lexical entries like that in ( 2 ) .","label":"Background","metadata":{},"score":"42.674534"}{"text":"The translation from the lexical entry in ( 2 ) to the rule in ( 1 ) is transparent .In fact , rules like that in ( 1 ) can be generated mechanically from lexical entries like that in ( 2 ) .","label":"Background","metadata":{},"score":"42.674534"}{"text":"Its function is to distinguish stems which have undergone derivation from those which have not .If the derivation is inflectional , the marker may be attached to the lexical stem or assigned independently to a structural position in syntax in ways which syntax alone can not predict .","label":"Background","metadata":{},"score":"42.735195"}{"text":"In summary , the SUF approach is now well accepted by generative linguists .To anticipate the conclusion of this section , I will argue that whatever the advantages of SUF morphology may be in theory , in practice it is necessary to allow for the description of languages using an MUF approach .","label":"Background","metadata":{},"score":"42.84236"}{"text":"In summary , the SUF approach is now well accepted by generative linguists .To anticipate the conclusion of this section , I will argue that whatever the advantages of SUF morphology may be in theory , in practice it is necessary to allow for the description of languages using an MUF approach .","label":"Background","metadata":{},"score":"42.84236"}{"text":"21 A realizational morphology approach would also be possible , and perhaps superior ; cf .footnote .22 Actually , the test for prefixes would probably be somewhat more complicated than this , due to AMPLE 's left - to - right processing ( the test given in the text could only be done as a final test ) .","label":"Background","metadata":{},"score":"42.979137"}{"text":"21 A realizational morphology approach would also be possible , and perhaps superior ; cf .footnote .22 Actually , the test for prefixes would probably be somewhat more complicated than this , due to AMPLE 's left - to - right processing ( the test given in the text could only be done as a final test ) .","label":"Background","metadata":{},"score":"42.979137"}{"text":"An LMBM MS - module with such a capacity would resemble the following diagram of a computational model of morphological spelling .Notice the lexeme representation in the lower left ; it comprises a phonological ( P ) , a grammatical ( G ) , and semantic ( R ) representation .","label":"Background","metadata":{},"score":"42.980938"}{"text":"In ( American ) structuralist linguistics , morphophonemic rules were of uncertain theoretical status ( and allophonic rules were by definition not involved in allomorphy ) ; hence MUF morphology was dominant until the rise of generative linguistics .Early generative linguistics did not distinguish a separate morphological component , but the combination of lexicon , syntax , and phonology essentially operated under the assumptions of SUF morphology .","label":"Background","metadata":{},"score":"43.04033"}{"text":"In ( American ) structuralist linguistics , morphophonemic rules were of uncertain theoretical status ( and allophonic rules were by definition not involved in allomorphy ) ; hence MUF morphology was dominant until the rise of generative linguistics .Early generative linguistics did not distinguish a separate morphological component , but the combination of lexicon , syntax , and phonology essentially operated under the assumptions of SUF morphology .","label":"Background","metadata":{},"score":"43.04033"}{"text":"Section 2 discusses the Item - and - Arrangement vs. Item - and - Process distinction as one of affixes - as - lexical items vs. affixes - as - rules , supporting the claim that there is a mapping from the former to the latter .","label":"Background","metadata":{},"score":"43.096893"}{"text":"Section 2 discusses the Item - and - Arrangement vs. Item - and - Process distinction as one of affixes - as - lexical items vs. affixes - as - rules , supporting the claim that there is a mapping from the former to the latter .","label":"Background","metadata":{},"score":"43.096893"}{"text":"Used in Framing when a value of .null should be returned , which would otherwise be removed when Compacting .All JSON - LD tokens and keywords are case - sensitive .Algorithm Terms . active subject .the currently active subject that the processor should use when processing .","label":"Background","metadata":{},"score":"43.180286"}{"text":"Allowing this is currently being discussed .The framing algorithm takes an .JSON - LD input ( expanded input ) and an . input frame ( expanded frame ) that have been expanded according to the Expansion Algorithm , and a number of options and produces .","label":"Background","metadata":{},"score":"43.208527"}{"text":"The environment will require either diacritic features , or a more abstract representation of certain morphemes , because while the shortening usually applies in a particular phonetic environment ( before a consonant cluster ) , it also applies before certain suffixes which synchronically do not contain consonant clusters .","label":"Background","metadata":{},"score":"43.433357"}{"text":"The environment will require either diacritic features , or a more abstract representation of certain morphemes , because while the shortening usually applies in a particular phonetic environment ( before a consonant cluster ) , it also applies before certain suffixes which synchronically do not contain consonant clusters .","label":"Background","metadata":{},"score":"43.433357"}{"text":"19 ] .The situation in ( 2 ) , where an allomorph property indicates that only certain allomorphs condition a process affecting other morphemes , might arise when a phonological process affects morphemes on both sides of a morpheme boundary .","label":"Background","metadata":{},"score":"43.445885"}{"text":"19 ] .The situation in ( 2 ) , where an allomorph property indicates that only certain allomorphs condition a process affecting other morphemes , might arise when a phonological process affects morphemes on both sides of a morpheme boundary .","label":"Background","metadata":{},"score":"43.445885"}{"text":"I would argue that the WBM analysis is correct insofar as it allows a generalization to be made , namely that all morphemes with a particular property undergo an alternation .[17 ] However , the generalization is captured in a linguistically inappropriate way , namely as an if - then condition on allomorph properties , rather than as a rule describing phonological structure .","label":"Background","metadata":{},"score":"43.51484"}{"text":"I would argue that the WBM analysis is correct insofar as it allows a generalization to be made , namely that all morphemes with a particular property undergo an alternation .[17 ] However , the generalization is captured in a linguistically inappropriate way , namely as an if - then condition on allomorph properties , rather than as a rule describing phonological structure .","label":"Background","metadata":{},"score":"43.51484"}{"text":"After the two introductory chapters ( Introduction and Processing with Constraint - logic Grammars ) , the contents of the book is divided into two main parts : Syntactic Under - determination and Lexical Under - determination with the relevant chapters .","label":"Background","metadata":{},"score":"43.517456"}{"text":"Because allomorphy rules are able to model virtually any kind of phonologically conditioned allomorphy , it is possible to mechanically transform a description with multiple underlying forms into a description with single underlying forms plus allomorphy rules .Again , the implication of this mapping is that a computational implementation allowing the use of allomorphy rules can be used to process both single and multiple underlying form descriptions .","label":"Background","metadata":{},"score":"43.53311"}{"text":"Because allomorphy rules are able to model virtually any kind of phonologically conditioned allomorphy , it is possible to mechanically transform a description with multiple underlying forms into a description with single underlying forms plus allomorphy rules .Again , the implication of this mapping is that a computational implementation allowing the use of allomorphy rules can be used to process both single and multiple underlying form descriptions .","label":"Background","metadata":{},"score":"43.53311"}{"text":"This has an important implication for computational implementations , e.g. morphological parsers : if a user is presented with a user interface which allows him to create an IA description , that description can be mapped internally into an IP representation .","label":"Background","metadata":{},"score":"43.589012"}{"text":"This has an important implication for computational implementations , e.g. morphological parsers : if a user is presented with a user interface which allows him to create an IA description , that description can be mapped internally into an IP representation .","label":"Background","metadata":{},"score":"43.589012"}{"text":"1992 : 16 - 17 ) .It should be noted , however , that morphosyntactic features may be of great relevance to affixation processes ; to the extent to which this is true , there will be duplication in an AMPLE analysis between the Morpheme Properties list and the \" features \" list .","label":"Background","metadata":{},"score":"43.84235"}{"text":"1992 : 16 - 17 ) .It should be noted , however , that morphosyntactic features may be of great relevance to affixation processes ; to the extent to which this is true , there will be duplication in an AMPLE analysis between the Morpheme Properties list and the \" features \" list .","label":"Background","metadata":{},"score":"43.84235"}{"text":"In some cases , data exists natively in Triples or Quads form ; for example , if the data was originally represented in an RDF graph or triple / quad store .This algorithm is designed to simply translate an array of Statement s into a JSON - LD document .","label":"Background","metadata":{},"score":"43.93973"}{"text":"It becomes possible for the user to gradually shift from one theoretical perspective to another in the course of a language program .Allomorphy can be modeled initially in terms of multiple allomorphs , each with a separate conditioning environment ; as the phonological processes causing the allomorphy are clarified , separate allomorphy statements can be collapsed into one or more phonological rules .","label":"Background","metadata":{},"score":"44.27871"}{"text":"It becomes possible for the user to gradually shift from one theoretical perspective to another in the course of a language program .Allomorphy can be modeled initially in terms of multiple allomorphs , each with a separate conditioning environment ; as the phonological processes causing the allomorphy are clarified , separate allomorphy statements can be collapsed into one or more phonological rules .","label":"Background","metadata":{},"score":"44.27871"}{"text":"LINGUIST List 12.492 .Thu Feb 22 2001 .Review : Levine & Green , Phrase Structure Grammar .What follows is another discussion note contributed to our Book Discussion Forum .We expect these discussions to be informal and interactive ; and the author of the book discussed is cordially invited to join in .","label":"Background","metadata":{},"score":"44.37246"}{"text":"Within that general notion , each program has expectations about the information contained in those lexical entries .I will base my discussion of the contents of the fields of lexical entries on that in WBM chapter 11 , section 3 .","label":"Background","metadata":{},"score":"44.49485"}{"text":"Within that general notion , each program has expectations about the information contained in those lexical entries .I will base my discussion of the contents of the fields of lexical entries on that in WBM chapter 11 , section 3 .","label":"Background","metadata":{},"score":"44.49485"}{"text":"There exists a consensus that the treatment of Japanese causative constructions entails some kind of dual structure .The two approaches presented in the volume start from different premises with respect to where the crucial mismatch among the linguistic representational components is located .","label":"Background","metadata":{},"score":"44.536133"}{"text":"There exists a consensus that the treatment of Japanese causative constructions entails some kind of dual structure .The two approaches presented in the volume start from different premises with respect to where the crucial mismatch among the linguistic representational components is located .","label":"Background","metadata":{},"score":"44.536133"}{"text":"19 Focusing on a different aspect of the problem , some linguists might argue that the AMPLE approach is better , in that it uses a constraint - based approach instead of a rule - based approach .This issue is , however , orthogonal to the one in the text , inasmuch as constraint - based approaches ( such as that in Bird 1995 ) are like rule - based approaches in that they describe generalizations in terms of phonological structure , rather than in terms of allomorph properties .","label":"Background","metadata":{},"score":"44.625908"}{"text":"19 Focusing on a different aspect of the problem , some linguists might argue that the AMPLE approach is better , in that it uses a constraint - based approach instead of a rule - based approach .This issue is , however , orthogonal to the one in the text , inasmuch as constraint - based approaches ( such as that in Bird 1995 ) are like rule - based approaches in that they describe generalizations in terms of phonological structure , rather than in terms of allomorph properties .","label":"Background","metadata":{},"score":"44.625908"}{"text":"Thus , if there is a computational implementation of Item - and - Process morphology , it can be used to process an Item - and - Arrangement description in an appropriate notation .Linguists have sometimes characterized the contrast between Item - and - Arrangement and Item - and - Process morphology in another way , as a choice between listing all allomorphs on the one hand , and deriving phonologically conditioned allomorphs from a single underlying form on the other .","label":"Background","metadata":{},"score":"44.69211"}{"text":"Thus , if there is a computational implementation of Item - and - Process morphology , it can be used to process an Item - and - Arrangement description in an appropriate notation .Linguists have sometimes characterized the contrast between Item - and - Arrangement and Item - and - Process morphology in another way , as a choice between listing all allomorphs on the one hand , and deriving phonologically conditioned allomorphs from a single underlying form on the other .","label":"Background","metadata":{},"score":"44.69211"}{"text":"None .Optional parameters : .None .Encoding considerations : .The same as the application / json MIME media type .Security considerations : .Since a JSON - LD frame is intended to specify a deterministic layout for a JSON - LD graph , the serialization SHOULD NOT be passed through a code execution mechanism such as JavaScript 's eval ( ) function .","label":"Background","metadata":{},"score":"44.943184"}{"text":"This could be expressed by including the feature [ + dynamic ] in the required features field of the past tense suffix rules , and the feature [ + past_tense ] ( assumed for convenience to be binary ) in the head features field of the rules .","label":"Background","metadata":{},"score":"45.126038"}{"text":"This could be expressed by including the feature [ + dynamic ] in the required features field of the past tense suffix rules , and the feature [ + past_tense ] ( assumed for convenience to be binary ) in the head features field of the rules .","label":"Background","metadata":{},"score":"45.126038"}{"text":"The existence of phonologically conditioned allomorphy which will not readily succumb to treatment by general phonological rules has not escaped the notice of SUF proponents .Chomsky and Halle ( 1968 ) proposed a solution in which a distinct class of rules , \" readjustment rules , \" apply before phonological rules .","label":"Background","metadata":{},"score":"45.167915"}{"text":"The existence of phonologically conditioned allomorphy which will not readily succumb to treatment by general phonological rules has not escaped the notice of SUF proponents .Chomsky and Halle ( 1968 ) proposed a solution in which a distinct class of rules , \" readjustment rules , \" apply before phonological rules .","label":"Background","metadata":{},"score":"45.167915"}{"text":"Under this view of representation , there are two options for how these rules exist in our brains : either these rules are represented in the brain , or they are in some sense built - in to the brain without being represented .","label":"Background","metadata":{},"score":"45.272087"}{"text":"Chicago , University of Chicago Press .Sag , I. and T. Wasow ( 1999 ) .Syntactic theory : a formal introduction .Stanford , CSLI .LINGUIST List 12.3097 .Sat Dec 15 2001 .Review : Processing with Constraint - Logic Grammars .","label":"Background","metadata":{},"score":"45.29182"}{"text":"\" The following are some examples : .It may not be apparent at first glance that these rules apply only to specific morphemes .Rule ( 3 ) , for instance , appears to refer to a more or less phonetically statable environment .","label":"Background","metadata":{},"score":"45.369354"}{"text":"\" The following are some examples : .It may not be apparent at first glance that these rules apply only to specific morphemes .Rule ( 3 ) , for instance , appears to refer to a more or less phonetically statable environment .","label":"Background","metadata":{},"score":"45.369354"}{"text":"This is due to the lossy nature of xsd : double values .Authors should instead use the expanded object form to set the canonical lexical representation directly .When JSON - native datatypes , like number s , are type coerced , lossless data round - tripping can not be guaranted .","label":"Background","metadata":{},"score":"45.40535"}{"text":"Finally , add a @context property to element and set it to the initially passed context .3.11 Framing .JSON - LD Framing allows developers to query by example and force a specific tree layout to a JSON - LD document .","label":"Background","metadata":{},"score":"45.469723"}{"text":"Furthermore , while phonological rules could obscure the boundaries under autosegmental phonology , they are less of a problem with classical ( segmental ) generative phonology .Parts of a morpheme may disappear ( by deletion rules ) , and non - morphemic material may be inserted ( by epenthesis rules ) , but two morphemes may not be intermingled unless the phonology includes metathesis rules .","label":"Background","metadata":{},"score":"45.605904"}{"text":"Furthermore , while phonological rules could obscure the boundaries under autosegmental phonology , they are less of a problem with classical ( segmental ) generative phonology .Parts of a morpheme may disappear ( by deletion rules ) , and non - morphemic material may be inserted ( by epenthesis rules ) , but two morphemes may not be intermingled unless the phonology includes metathesis rules .","label":"Background","metadata":{},"score":"45.605904"}{"text":"Framing is the process of taking a JSON - LD document , which expresses a graph of information , and applying a specific graph layout ( called a Frame ) .Framing makes use of the Subject Flattening algorithm to place each object defined in the JSON - LD document into a flat list of objects , allowing them to be operated upon by the framing algorithm .","label":"Background","metadata":{},"score":"45.615875"}{"text":"And amongst this unlimited variety there are encoding schemes that more explicitly represent the thing and those that do so less explicitly .So my question is , is there just a spectrum here , from very implicit representations right up to very explicit reprsentations ?","label":"Background","metadata":{},"score":"45.624725"}{"text":"A callback that is called when processing is complete on the given input .optional JsonLdOptions ? options .A set of options that MAY affect the framing algorithm such as , e.g. , the input document 's base .IRI .","label":"Background","metadata":{},"score":"45.646423"}{"text":"The implication for computational implementation is that a morphological parsing engine which implements Item - and - Process morphology can in fact be used for Item - and - Arrangement morphology by means of an appropriate user interface .The second distinction sometimes intended by the terms \" Item - and - Arrangement \" vs. \" Item - and - Process \" is that between Multiple Underlying Form ( MUF ) models and Single Underlying Form ( SUF ) models .","label":"Background","metadata":{},"score":"45.64759"}{"text":"The implication for computational implementation is that a morphological parsing engine which implements Item - and - Process morphology can in fact be used for Item - and - Arrangement morphology by means of an appropriate user interface .The second distinction sometimes intended by the terms \" Item - and - Arrangement \" vs. \" Item - and - Process \" is that between Multiple Underlying Form ( MUF ) models and Single Underlying Form ( SUF ) models .","label":"Background","metadata":{},"score":"45.64759"}{"text":"Beard ( 1981 , 1987 ) provides a general theory of morphological performance which distinguishes most types of extragrammatical derivational processes from those determined by grammar .The predictions of LMBM for a processing theory has been addressed in two preliminary papers , Beard ( 1986 , 1989 ) .","label":"Background","metadata":{},"score":"45.67738"}{"text":"Phonological rules can also be sensitive to part of speech of the word to which they are applying ( necessary e.g. to capture the facts of English stress assignment ) and to rule features .This latter capability , together with the ability to include boundary markers in the left or right environment , allows allomorphy rules to be treated as a subtype of phonological rule .","label":"Background","metadata":{},"score":"45.88896"}{"text":"Phonological rules can also be sensitive to part of speech of the word to which they are applying ( necessary e.g. to capture the facts of English stress assignment ) and to rule features .This latter capability , together with the ability to include boundary markers in the left or right environment , allows allomorphy rules to be treated as a subtype of phonological rule .","label":"Background","metadata":{},"score":"45.88896"}{"text":"In the case of the infix itself , the difficulty is probably not too great ; if we are dealing with a single contiguous infix , its left and right environment begin at its left and right end .However , if the infix has more than one part ( e.g. Semitic voweling , under one analysis ) , then what counts for the infixes ' left and right environment is no longer apparent .","label":"Background","metadata":{},"score":"45.93288"}{"text":"In the case of the infix itself , the difficulty is probably not too great ; if we are dealing with a single contiguous infix , its left and right environment begin at its left and right end .However , if the infix has more than one part ( e.g. Semitic voweling , under one analysis ) , then what counts for the infixes ' left and right environment is no longer apparent .","label":"Background","metadata":{},"score":"45.93288"}{"text":"( The empty feature bundle represented in the above examples by X is actually defined as a natural class in the same way . )In addition to segments whose phonological material is represented by strings or natural classes , morphological rules may insert boundary markers and diacritic ( rule ) features .","label":"Background","metadata":{},"score":"45.973564"}{"text":"( The empty feature bundle represented in the above examples by X is actually defined as a natural class in the same way . )In addition to segments whose phonological material is represented by strings or natural classes , morphological rules may insert boundary markers and diacritic ( rule ) features .","label":"Background","metadata":{},"score":"45.973564"}{"text":"I have in mind now such morphemes as free adpositions , auxiliaries , conjunctions , and pronouns .All but conjunctions are themselves subject to inflection .Pronouns like which and who , as well as free auxiliaries seem to move from one syntactic position to another in some languages .","label":"Background","metadata":{},"score":"46.21451"}{"text":"Mixed systems are quite likely to arise in practice for a field linguist , no matter what his commitment to SUF morphology ( as argued in section 3.2 of the main text ) .I have argued that the proper behavior is : .","label":"Background","metadata":{},"score":"46.32003"}{"text":"Mixed systems are quite likely to arise in practice for a field linguist , no matter what his commitment to SUF morphology ( as argued in section 3.2 of the main text ) .I have argued that the proper behavior is : .","label":"Background","metadata":{},"score":"46.32003"}{"text":"It is also used to maintain coercion mapping s from terms to datatypes , language mapping s from terms to language codes , and list mapping s and set mapping s for terms .Processors must use the lexical form of the property when creating a mapping , as lookup is performed on lexical representations , not expanded IRI representations .","label":"Background","metadata":{},"score":"46.5951"}{"text":"A test requiring that some morpheme to the left or right bear a particular Morpheme Property is the equivalent of a Morpheme Environment Condition ( MEC ) requiring that Morpheme Property to appear to the left or right .The advantage of using the test , rather than a MEC , is that the test can be written once , and used for a number of morphemes .","label":"Background","metadata":{},"score":"46.707703"}{"text":"A test requiring that some morpheme to the left or right bear a particular Morpheme Property is the equivalent of a Morpheme Environment Condition ( MEC ) requiring that Morpheme Property to appear to the left or right .The advantage of using the test , rather than a MEC , is that the test can be written once , and used for a number of morphemes .","label":"Background","metadata":{},"score":"46.707703"}{"text":"5 ] But from the standpoint of this paper , such arguments are irrelevant , as we are concerned not with mapping from an IP morphological description to an IA description , but with the reverse mapping .Hence if certain types of affixation processes can not be modeled in IA morphology , that is irrelevant , so long as any valid IA affix lexical entry can be mapped over to an IP rule .","label":"Background","metadata":{},"score":"46.8071"}{"text":"5 ] But from the standpoint of this paper , such arguments are irrelevant , as we are concerned not with mapping from an IP morphological description to an IA description , but with the reverse mapping .Hence if certain types of affixation processes can not be modeled in IA morphology , that is irrelevant , so long as any valid IA affix lexical entry can be mapped over to an IP rule .","label":"Background","metadata":{},"score":"46.8071"}{"text":"Syntax Tokens and Keywords .This specification adds a number of .keywords to the ones defined in the [ [ !JSON - LD ] ] specification : . @default .Used in Framing to set the default value for an output property when the framed .","label":"Background","metadata":{},"score":"46.945484"}{"text":"Likewise rule ( 4 ) applies to only the four stems listed in the rule .These examples thus demonstrate an important point : allomorphy rules in reality represent the retention in SUF morphology of a form of MUF morphology , disguised as rules .","label":"Background","metadata":{},"score":"46.987"}{"text":"Likewise rule ( 4 ) applies to only the four stems listed in the rule .These examples thus demonstrate an important point : allomorphy rules in reality represent the retention in SUF morphology of a form of MUF morphology , disguised as rules .","label":"Background","metadata":{},"score":"46.987"}{"text":"If no L - derivation applies to ( 1 ) , it will be provided with the lexical categories of Gender , Noun Class , and Number from the lexicon .( Animacy is derivable from Natural Gender ; see Beard 1995a . )","label":"Background","metadata":{},"score":"47.006866"}{"text":"( The question of whether all allomorphs are stored in the lexicon , or whether phonologically conditioned allomorphs are derived by phonological rules , is a separate issue , although often confused with this issue ; see section 3 . )In contrast , under an Item - and - Process theory ( henceforth \" IP \" ) , only roots are morphemes , and therefore only roots are listed in the lexicon .","label":"Background","metadata":{},"score":"47.041645"}{"text":"( The question of whether all allomorphs are stored in the lexicon , or whether phonologically conditioned allomorphs are derived by phonological rules , is a separate issue , although often confused with this issue ; see section 3 . )In contrast , under an Item - and - Process theory ( henceforth \" IP \" ) , only roots are morphemes , and therefore only roots are listed in the lexicon .","label":"Background","metadata":{},"score":"47.041645"}{"text":"When coercing numbers to xsd : integer or xsd : double as it , e.g. , happens during RDF Conversion , implementers must ensure that the result is a canonical lexical representation in the form of a string .A canonical lexical representation is a set of literals from among the valid set of literals for a datatype such that there is a one - to - one mapping between the canonical lexical representation and a value in the value space as defined in [ XMLSCHEMA-2 ] .","label":"Background","metadata":{},"score":"47.088707"}{"text":"Two subclasses of them are introduced and interrelated : logic grammars based on first - order logic and typed feature grammars based on typed feature logic .The two kinds of grammars are defined in a uniform manner in order to stress the relations between them .","label":"Background","metadata":{},"score":"47.14458"}{"text":"The processing algorithms described in this section are provided in order to demonstrate how one might implement a JSON - LD to RDF processor .Conformant implementations are only required to produce the same type and number of statements during the output process and are not required to implement the algorithm exactly as described .","label":"Background","metadata":{},"score":"47.2678"}{"text":"If lexemes are noun , verb , and adjective stems , and if they are the only objects stored in the lexicon , it is natural to ask what determines or generates grammatical morphemes .Grammatical morphemes are the output of purely phonological operations independent of the semantic ( grammatical ) operations which they mark ( ' realize ' ) .","label":"Background","metadata":{},"score":"47.319206"}{"text":"I will use the term \" lexicon \" in the more restricted sense of the set of listemes .I will also ignore the question of the lexical representation of idioms and other phrasal categories .3 I ignore the issue of whether the rule is triggered by the presence of the plural feature on the noun , or whether the rule itself adds the plural feature .","label":"Background","metadata":{},"score":"47.321503"}{"text":"I will use the term \" lexicon \" in the more restricted sense of the set of listemes .I will also ignore the question of the lexical representation of idioms and other phrasal categories .3 I ignore the issue of whether the rule is triggered by the presence of the plural feature on the noun , or whether the rule itself adds the plural feature .","label":"Background","metadata":{},"score":"47.321503"}{"text":"This document outlines an Application Programming Interface and a set of algorithms for programmatically transforming JSON - LD documents .Status of This Document .This document is merely a public working draft of a potential specification .It has no official standing of any kind and does not represent the support or consensus of any standards organisation .","label":"Background","metadata":{},"score":"47.463615"}{"text":"The MS speller waits until the features in its memory correspond to the conditions on some operation .When they do , it obligatorily carries out that operation .This brief introduction to LMBM has outlined the basic assumptions about ( 1 ) the lexicon , ( 2 ) lexical derivation rules , ( 3 ) inflectional derivation rules , and ( 4 ) morphological realization .","label":"Background","metadata":{},"score":"47.57443"}{"text":"I am not aware of a generally agreed - on IA notation for other sorts of affixes .I will therefore of necessity leave the details of the mapping of nonconcatenative morphology from IA to IP open , although it seems likely that it would present no more difficulties than simple prefixes and suffixes .","label":"Background","metadata":{},"score":"47.639107"}{"text":"I am not aware of a generally agreed - on IA notation for other sorts of affixes .I will therefore of necessity leave the details of the mapping of nonconcatenative morphology from IA to IP open , although it seems likely that it would present no more difficulties than simple prefixes and suffixes .","label":"Background","metadata":{},"score":"47.639107"}{"text":"It is unclear to me what the proper behavior should be in this case .Another difficulty arises in the application of allomorphy rules if there is nonconcatenative morphology : the morpheme to which the allomorphy rule is to apply may not be identifiable , or it may not be composed of a contiguous set of segments ( phonemes ) .","label":"Background","metadata":{},"score":"47.861618"}{"text":"It is unclear to me what the proper behavior should be in this case .Another difficulty arises in the application of allomorphy rules if there is nonconcatenative morphology : the morpheme to which the allomorphy rule is to apply may not be identifiable , or it may not be composed of a contiguous set of segments ( phonemes ) .","label":"Background","metadata":{},"score":"47.861618"}{"text":"Frame can be used by a developer on a JSON - LD document to specify a deterministic layout for a graph .How to Read this Document .This document is a detailed specification for a serialization of Linked Data in JSON .","label":"Background","metadata":{},"score":"47.88423"}{"text":"This is apparently the role of pronominals .Pronominals are also tightly constrained by LMBM : categorically , they may only contain those lexical categories determined by the lexicon and the inflectional categories found in syntax .No other type of semantic or grammatical category may be found in a pronominal ( proadjective , pronoun , proverb ) .","label":"Background","metadata":{},"score":"48.0335"}{"text":"Chicago , University of Chicago Press .Sag , I. and T. Wasow ( 1999 ) .Syntactic theory : a formal introduction .Stanford , CSLI .LINGUIST List 12.488 .Thu Feb 22 2001 .Review : Levine and Green .","label":"Background","metadata":{},"score":"48.052444"}{"text":"[ 16 ] .There are several reasons why one might assign non - phonetic features to particular allomorphs : . to indicate a class of allomorphs of more than one morpheme , such that the appearance of all the allomorphs in the class is conditioned by some property in common ; . to indicate that selected allomorphs condition a process which affects other morphemes ; and . to allow dummy ( zero ) morphemes to condition allomorphs .","label":"Background","metadata":{},"score":"48.100945"}{"text":"[ 16 ] .There are several reasons why one might assign non - phonetic features to particular allomorphs : . to indicate a class of allomorphs of more than one morpheme , such that the appearance of all the allomorphs in the class is conditioned by some property in common ; . to indicate that selected allomorphs condition a process which affects other morphemes ; and . to allow dummy ( zero ) morphemes to condition allomorphs .","label":"Background","metadata":{},"score":"48.100945"}{"text":"Under LMBM , L - derivation takes place in the lexicon .Here lexemes with new lexical meanings are formed from from underived lexemes .Inflectional derivation , following the arguments of Matthews ( 1972 ) , Anderson ( 1982 ) , and Aronoff ( 1994 ) , takes place in syntax .","label":"Background","metadata":{},"score":"48.30956"}{"text":"It has a consistent logical structure of the content , elaborate explanations and references within the text body , which facilitates the process of following up and understanding the author 's ideas .One drawback of the book concerns typography : there is missing content of illustrative figures ( for example , fig .","label":"Background","metadata":{},"score":"48.32514"}{"text":"IRI which indicates the literal 's datatype .See languaged - tagged literal in [ [ !RDF - CONCEPTS]].Framing .Framing is the process of taking a JSON - LD document , which expresses a graph of information , and applying a specific graph layout ( called a .","label":"Background","metadata":{},"score":"48.330154"}{"text":"A circumfix , for instance , may be defined by a rule which simultaneously attaches a prefix and a suffix .Finally , so - called zero morphemes are captured simply by a rule which copies its input to its output .","label":"Background","metadata":{},"score":"48.453636"}{"text":"A circumfix , for instance , may be defined by a rule which simultaneously attaches a prefix and a suffix .Finally , so - called zero morphemes are captured simply by a rule which copies its input to its output .","label":"Background","metadata":{},"score":"48.453636"}{"text":"Consider first the morphological process of complete reduplication .After a word has been reduplicated , it is no longer evident which part of the resulting word is the original stem and which is the ' affix ' of reduplication .If the stem is composed of morphemes which have allomorphs , it is therefore unclear to which portion the allomorphy rules should apply .","label":"Background","metadata":{},"score":"48.491917"}{"text":"Consider first the morphological process of complete reduplication .After a word has been reduplicated , it is no longer evident which part of the resulting word is the original stem and which is the ' affix ' of reduplication .If the stem is composed of morphemes which have allomorphs , it is therefore unclear to which portion the allomorphy rules should apply .","label":"Background","metadata":{},"score":"48.491917"}{"text":"If there are no matches for the frame , null must be returned .Exceptions must be thrown if there are errors .The Base IRI to use when expanding the document .This overrides the value of input if it is a URL or if it is a object or object [ ] . boolean optimize .","label":"Background","metadata":{},"score":"48.571617"}{"text":"Nowadays HPSG is a major theory of syntactic representation which is becoming increasingly dominant , particularly in the domain of natural language computation , cf .[Flickinger et al . 2000].This collection of articles can be regarded as a representative reflection of the process of continuous rethinking that the theory has undergone since the appearance of [ Pollard and Sag 1994].","label":"Background","metadata":{},"score":"48.643322"}{"text":"Otherwise , construct output as a new JSON object used for returning the result of compacting element .For each property and value in element : .Perhaps this should also call Value Compaction on native types and strings , which could consolodate potential transformation in one place .","label":"Background","metadata":{},"score":"48.807762"}{"text":"The problem then becomes one of applying the allomorphy rules to a form in such a way that one subrule of each rule is satisfied ; and for each such subrule which has applied , no more specific subrule would be applicable .","label":"Background","metadata":{},"score":"48.880867"}{"text":"The problem then becomes one of applying the allomorphy rules to a form in such a way that one subrule of each rule is satisfied ; and for each such subrule which has applied , no more specific subrule would be applicable .","label":"Background","metadata":{},"score":"48.880867"}{"text":"A simple phonological rule consists of an input , output , and left and right environments .The input and the output usually consist of a sequence of segments or natural classes , both of which are treated internally as feature bundles .","label":"Background","metadata":{},"score":"48.963024"}{"text":"A simple phonological rule consists of an input , output , and left and right environments .The input and the output usually consist of a sequence of segments or natural classes , both of which are treated internally as feature bundles .","label":"Background","metadata":{},"score":"48.963024"}{"text":"LMBM postulates only one integrated MS component for both lexical and and inflectional derivations .Morphological spelling ( MS ) comprises the phonological realization rules of morphology .These are rules which determine the modification of lexical stems , if any , conditioned by the presence of derivational features .","label":"Background","metadata":{},"score":"49.221428"}{"text":"[ End Linguist List , Vol . 2 , No . 150 ] The Universal Grammarical Function Theory , whereby the functions of inflectional and lexical derivation are one and the same ; .The Base Rule Hypothesis , that universal functions must originate in a base component if we are to explain both lexical and syntactic ( inflectional ) derivation ; .","label":"Background","metadata":{},"score":"49.281715"}{"text":"A different classification of morphological theories is based on whether all allomorphs are listed in the lexicon , or whether phonologically conditioned allomorphs are derived from a single listed form .I show that in reality , derivational theories incorporate a device ( allomorphy rules ) which can do virtually the same work as listing the phonologically conditioned allomorphs .","label":"Background","metadata":{},"score":"49.355804"}{"text":"A different classification of morphological theories is based on whether all allomorphs are listed in the lexicon , or whether phonologically conditioned allomorphs are derived from a single listed form .I show that in reality , derivational theories incorporate a device ( allomorphy rules ) which can do virtually the same work as listing the phonologically conditioned allomorphs .","label":"Background","metadata":{},"score":"49.355804"}{"text":"A a set of rules for interpreting a JSON - LD document as specified in The Context of the [ [ JSON - LD ] ] specification .IRI .An Internationalized Resource Identifier as described in [ [ ! RFC3987]].","label":"Background","metadata":{},"score":"49.46093"}{"text":"In such simple cases of suffixation ( or prefixation ) , there is an obvious mapping between an IP analysis and an IA analysis .To go from an IP description to an IA description , it is merely necessary to view the phonological material attached by the rule as if it were the phonological shape of a morpheme in the lexicon , and vice versa for the reverse mapping .","label":"Background","metadata":{},"score":"49.462524"}{"text":"In such simple cases of suffixation ( or prefixation ) , there is an obvious mapping between an IP analysis and an IA analysis .To go from an IP description to an IA description , it is merely necessary to view the phonological material attached by the rule as if it were the phonological shape of a morpheme in the lexicon , and vice versa for the reverse mapping .","label":"Background","metadata":{},"score":"49.462524"}{"text":"Framing makes use of the Node Map Generation algorithm to place each object defined in the JSON - LD document into a flat list of objects , allowing them to be operated upon by the framing algorithm .Framing Algorithm Terms . input frame .","label":"Background","metadata":{},"score":"49.564857"}{"text":"A second way in which the terms ' Item - and - Arrangement ' and ' Item - and - Process ' have been used to distinguish differing approaches to morphology involves the representation of allomorphy : are allomorphs listed or derived by phonological rules ?","label":"Background","metadata":{},"score":"49.589577"}{"text":"A second way in which the terms ' Item - and - Arrangement ' and ' Item - and - Process ' have been used to distinguish differing approaches to morphology involves the representation of allomorphy : are allomorphs listed or derived by phonological rules ?","label":"Background","metadata":{},"score":"49.589577"}{"text":"Much is gained by using a single parsing engine to implement varying theoretical models .One immediate advantage is the lesser amount of programming effort required , assuming the internal engine to be at least as complex as the user interface .","label":"Background","metadata":{},"score":"49.893475"}{"text":"Much is gained by using a single parsing engine to implement varying theoretical models .One immediate advantage is the lesser amount of programming effort required , assuming the internal engine to be at least as complex as the user interface .","label":"Background","metadata":{},"score":"49.893475"}{"text":"Putting this differently , the allomorph property is an arbitrary diacritic which has no inherent link to the phonological process its name describes .A better solution is to describe a process which at the same time deletes a consonant and lengthens a vowel .","label":"Background","metadata":{},"score":"49.894188"}{"text":"Putting this differently , the allomorph property is an arbitrary diacritic which has no inherent link to the phonological process its name describes .A better solution is to describe a process which at the same time deletes a consonant and lengthens a vowel .","label":"Background","metadata":{},"score":"49.894188"}{"text":"The third case in which one might use allomorph properties ( situation ( 3 ) above ) , is one in which the allomorph properties of a non - overt ( zero , or dummy ) morpheme condition allomorphs of an overt morpheme .","label":"Background","metadata":{},"score":"49.96446"}{"text":"The third case in which one might use allomorph properties ( situation ( 3 ) above ) , is one in which the allomorph properties of a non - overt ( zero , or dummy ) morpheme condition allomorphs of an overt morpheme .","label":"Background","metadata":{},"score":"49.96446"}{"text":"This immediately explains empty and zero morphemes .Empty morphemes represent affixation without derivation ; zero morphemes are derivations without affixation .Morphological asymmetry , the many - to - one and one - to - many mappings of morphological forms to function is also explained by Separation .","label":"Background","metadata":{},"score":"49.96634"}{"text":"You must also understand the JSON - LD Syntax [ JSON - LD ] , which is the base syntax used by all of the algorithms in this document .To understand the API and how it is intended to operate in a programming environment , it is useful to have working knowledge of the JavaScript programming language [ ECMA-262 ] and WebIDL [ WEBIDL ] .","label":"Background","metadata":{},"score":"50.007294"}{"text":"This view was for a time the dominant approach under American structuralism , and it has experienced a resurrection ( in modified form ) in work in Natural Generative Phonology ( Hooper 1976 ) , and later work on constraint - based phonology by Bird ( 1995 ) and others .","label":"Background","metadata":{},"score":"50.051044"}{"text":"This view was for a time the dominant approach under American structuralism , and it has experienced a resurrection ( in modified form ) in work in Natural Generative Phonology ( Hooper 1976 ) , and later work on constraint - based phonology by Bird ( 1995 ) and others .","label":"Background","metadata":{},"score":"50.051044"}{"text":"If the frame has no context , compaction is performed with an empty context ( not a null context ) .The compaction result must use the @graph keyword at the top - level , even if the context is empty or if there is only one element to put in the @graph array .","label":"Background","metadata":{},"score":"50.18126"}{"text":"28 ] .In classical generative phonology , the answer to the question of how allomorphy rules were ordered among themselves was straightforward : readjustment rules , of which allomorphy rules were a subclass , were linearly ordered .But in Multiple Underlying Form ( MUF ) theories , conditions on the appearance of allomorphs in MUF morphology are generally construed as conditions to be met at the surface , i.e. as surface - true generalizations .","label":"Background","metadata":{},"score":"50.229332"}{"text":"28 ] .In classical generative phonology , the answer to the question of how allomorphy rules were ordered among themselves was straightforward : readjustment rules , of which allomorphy rules were a subclass , were linearly ordered .But in Multiple Underlying Form ( MUF ) theories , conditions on the appearance of allomorphs in MUF morphology are generally construed as conditions to be met at the surface , i.e. as surface - true generalizations .","label":"Background","metadata":{},"score":"50.229332"}{"text":"A single directed graph can have many different serializations , each expressing exactly the same information .Developers typically work with trees , represented as JSON object s. While mapping a graph to a tree can be done , the layout of the end result must be specified in advance .","label":"Background","metadata":{},"score":"50.37027"}{"text":"It is practical and designed to be as simple as possible , utilizing the large number of JSON parsers and libraries available today .It is designed to be able to express key - value pairs , RDF data , RDFa [ RDFA - CORE ] data , Microformats [ MICROFORMATS ] data , and Microdata [ MICRODATA ] .","label":"Background","metadata":{},"score":"50.52197"}{"text":"Gerdemann , Dale and Paul King ( 1994 )The Correct and Efficient Implementation of Appropriateness Specifications for Typed Feature Structures .Proceedings of the 15th Conference on Computational Linguistics , Kyoto , Japan , pp .956- 960 .Goetz , Thilo and Detmar Meurers ( 1997 )","label":"Background","metadata":{},"score":"50.57113"}{"text":"3.10 Compaction .Compaction is the process of taking a JSON - LD document and applying a context such that the most compact form of the document is generated .JSON is typically expressed in a very compact , key - value format .","label":"Background","metadata":{},"score":"50.615746"}{"text":"First , derivation rules and realization rules operate on the same lexeme during the generation of a derived word .This means that affixation will correspond to the modified features in the stem .( The original features of the stem will also be modified , neutralized , so that they will not trigger affixation . )","label":"Background","metadata":{},"score":"50.63735"}{"text":"Thus , the propagation of parts of speech is determined directly by the hierarchical structure of the word , regardless of the left - to - right order of affixes .The outermost affix for which a part of speech is defined determines the part of speech of the final word .","label":"Background","metadata":{},"score":"50.64286"}{"text":"Thus , the propagation of parts of speech is determined directly by the hierarchical structure of the word , regardless of the left - to - right order of affixes .The outermost affix for which a part of speech is defined determines the part of speech of the final word .","label":"Background","metadata":{},"score":"50.64286"}{"text":"Compacts the given input using the context according to the steps in the Compaction Algorithm .The input must be copied , compacted and returned if there are no errors .If the compaction fails , an appropirate exception must be thrown .","label":"Background","metadata":{},"score":"50.682163"}{"text":"This section is non - normative .JSON - LD is intended to have an easy to parse grammar that closely models existing practice in using JSON for describing object representations .This allows the use of existing libraries for parsing JSON .","label":"Background","metadata":{},"score":"50.803852"}{"text":"AMPLE does not automatically impose category restrictions on the attachment of affixes ; the relevant tests must be written by the user .Some common tests are : .However , things are considerably more complicated if the layering is complex , for instance if the language has both prefixes and suffixes , particularly if the ' layers ' of the word alternate between prefixes and suffixes .","label":"Background","metadata":{},"score":"50.81073"}{"text":"AMPLE does not automatically impose category restrictions on the attachment of affixes ; the relevant tests must be written by the user .Some common tests are : .However , things are considerably more complicated if the layering is complex , for instance if the language has both prefixes and suffixes , particularly if the ' layers ' of the word alternate between prefixes and suffixes .","label":"Background","metadata":{},"score":"50.81073"}{"text":"Set context to the extracted content and process it by starting at Step 2.1 .If context has a @language property , it must have a value of a simple string or null .Add the language to the local context .","label":"Background","metadata":{},"score":"50.834843"}{"text":"Also a concrete system , ConTroll , is shortly discussed along the lines of the typed feature grammars .The second part of the chapter presents a typology of the control strategies with respect to their interrelation : top - down , bottom up and head - driven approaches .","label":"Background","metadata":{},"score":"51.04843"}{"text":"Both analyses take advantage of the expressive power of lexical rules .Aiming at integrating several analyses of German verbal phenomena - verb second ( V2 ) , modal flip ( MF ) , and partial verb phrase ( PVP ) fronting - Baker assumes a common phrase structure for PVPs and MF contexts .","label":"Background","metadata":{},"score":"51.06418"}{"text":"Both analyses take advantage of the expressive power of lexical rules .Aiming at integrating several analyses of German verbal phenomena - verb second ( V2 ) , modal flip ( MF ) , and partial verb phrase ( PVP ) fronting - Baker assumes a common phrase structure for PVPs and MF contexts .","label":"Background","metadata":{},"score":"51.06418"}{"text":"Rule strata can also be defined ( as in Lexical Phonology ) .Rules of a given stratum apply in linear order ( simultaneous rule ordering could be implemented as well ) .Individual phonological rules apply in left - to - right or right - to - left iterative fashion ( simultaneous application could also be added ) .","label":"Background","metadata":{},"score":"51.0757"}{"text":"Rule strata can also be defined ( as in Lexical Phonology ) .Rules of a given stratum apply in linear order ( simultaneous rule ordering could be implemented as well ) .Individual phonological rules apply in left - to - right or right - to - left iterative fashion ( simultaneous application could also be added ) .","label":"Background","metadata":{},"score":"51.0757"}{"text":"I am assuming that the realizations of the pronoun one , i.e. someone , anyone , the one(s ) result from the interplay of features [ Specific ] and [ Definite].Other treatments may be possible but this one serves the purposes of exemplification .","label":"Background","metadata":{},"score":"51.116287"}{"text":"The Defective Adjective Hypothesis , which claims that adpositions are adjectival pronouns in a class with case endings and hence grammatical morphemes rather than lexemes .A morphological performance theory which includes : .The LMBM lexicon is exclusively the domain of lexemes which are defined specifically as noun , verb , and adjective stems and the lexical categories which define them ( Number , Gender , Transitivity , and so on ) .","label":"Background","metadata":{},"score":"51.198463"}{"text":"For 1.0 , this might not require anything , as the default implementation of Subject Flattening should flatten everything into a single graph . 3.11.3Subject Flattening .The algorithm operates on the initially empty subjects and takes as input the current document element .","label":"Background","metadata":{},"score":"51.311745"}{"text":"A conforming JSON - LD processor implementing RDF conversion must implement a processing algorithm that results in the same set of RDF Statement s that the following algorithm generates : .Otherwise , if element is a number , set the active object to a typed literal using a string representation of the value with datatype set to either xsd : integer or xsd : double , depending on if the value contains a fractional and/or an exponential component .","label":"Background","metadata":{},"score":"51.418064"}{"text":"Allomorphy rules should be applied in a block before ( true ) phonological rules are applied .There are potential problems with cyclic phonology , for which I have no clear answer ; fortunately , such problems appear to be minor within the context of segmental ( as opposed to autosegmental ) phonology .","label":"Background","metadata":{},"score":"51.424698"}{"text":"Allomorphy rules should be applied in a block before ( true ) phonological rules are applied .There are potential problems with cyclic phonology , for which I have no clear answer ; fortunately , such problems appear to be minor within the context of segmental ( as opposed to autosegmental ) phonology .","label":"Background","metadata":{},"score":"51.424698"}{"text":"The input must be copied , expanded and returned if there are no errors .If the expansion fails , an appropriate exception must be thrown .Frames the given input using the frame according to the steps in the Framing Algorithm .","label":"Background","metadata":{},"score":"51.609127"}{"text":"Then , by parity of reasoning , one COULD extend to the case of final [ i ] ( or [ I ] , depending on dialect ) , by saying that where necessary we write this as /y/. That is , if there were a relevant contrast between syllabic and nonsyllabic [ r ] , one MIGHT reasonably extend it to the case of syllabic and nonsyllabic [ i]/[I]/[y ] , but there is no such contrast .","label":"Background","metadata":{},"score":"51.636143"}{"text":"Frequently this process will take place across a morpheme boundary , with the lengthened vowel preceding the boundary and the consonant being deleted after the boundary .This situation might be described in AMPLE by assigning an allomorph property ' deleted_C ' to allomorphs from which a consonant has been deleted , and conditioning the appearance of allomorphs with lengthened vowel by this allomorph property .","label":"Background","metadata":{},"score":"51.65752"}{"text":"Frequently this process will take place across a morpheme boundary , with the lengthened vowel preceding the boundary and the consonant being deleted after the boundary .This situation might be described in AMPLE by assigning an allomorph property ' deleted_C ' to allomorphs from which a consonant has been deleted , and conditioning the appearance of allomorphs with lengthened vowel by this allomorph property .","label":"Background","metadata":{},"score":"51.65752"}{"text":"If rank is greater than highest rank , clear terms and set highest rank to rank .When selecting among multiple possible terms for a given property , it may be that multiple terms are defined with the same IRI , but differ in @type , @container or @language .","label":"Background","metadata":{},"score":"51.715893"}{"text":"[ 4 ] ( The \" SUBCATEGORIZATION : N \" field represents the fact the input to the rule is a noun , while the \" SYNTAX : N \" field represents the fact that the output of the rule is a Noun .","label":"Background","metadata":{},"score":"51.77692"}{"text":"[ 4 ] ( The \" SUBCATEGORIZATION : N \" field represents the fact the input to the rule is a noun , while the \" SYNTAX : N \" field represents the fact that the output of the rule is a Noun .","label":"Background","metadata":{},"score":"51.77692"}{"text":"An MUF model , then , assigns a fundamental status to allomorphs : all allomorphs ( up to , but not including , allophonic variants ) are stored in the lexicon , and a particular allomorph is chosen for lexical insertion based on the phonological and/or morphosyntactic environment .","label":"Background","metadata":{},"score":"51.81981"}{"text":"An MUF model , then , assigns a fundamental status to allomorphs : all allomorphs ( up to , but not including , allophonic variants ) are stored in the lexicon , and a particular allomorph is chosen for lexical insertion based on the phonological and/or morphosyntactic environment .","label":"Background","metadata":{},"score":"51.81981"}{"text":"HPSG - [ Pollard and Sag 1987 ; Pollard and Sag 1994 ; Sag and Wasow 1999 ] - is a constraint - based lexicalist theory that invokes only a single level of syntactic representation .A crucial property of HPSG is the explicit assignment of linguistic objects to membership in a hierarchically organised network of types , where constraints associated with any given type are inherited by all of its subtypes .","label":"Background","metadata":{},"score":"51.920944"}{"text":"A crucial property of HPSG is the explicit assignment of linguistic objects to membership in a hierarchically organised network of types , where constraints associated with any given type are inherited by all of its subtypes .On the basis of detailed empirical analyses , the contributors suggest ways of extending and revising the current framework .","label":"Background","metadata":{},"score":"52.0709"}{"text":"Japanese causatives are treated as single verbal forms with complex morphological structure .Crucially , they are associated with hierarchical ( \" nested \" ) lexical argument structures , which are acquired derivationally ( i.e. by means of derivational types ) , and the resulting constituent structure is clearly mono - clausal .","label":"Background","metadata":{},"score":"52.323204"}{"text":"Japanese causatives are treated as single verbal forms with complex morphological structure .Crucially , they are associated with hierarchical ( \" nested \" ) lexical argument structures , which are acquired derivationally ( i.e. by means of derivational types ) , and the resulting constituent structure is clearly mono - clausal .","label":"Background","metadata":{},"score":"52.323204"}{"text":"This is clearest in the case of the third person prefix .Suppose that the underlying form is s- .Then we require a rule to turn /s/ into /y/ before a vowel .But it is not clear how the feature [ + strident ] is to be eliminated ( is this done automatically because there are no [ + strident -consonantal ] sounds ? ) , or how the values of the features [ voiced ] , [ anterior ] and [ distributed ] are changed .","label":"Background","metadata":{},"score":"52.323647"}{"text":"This is clearest in the case of the third person prefix .Suppose that the underlying form is s- .Then we require a rule to turn /s/ into /y/ before a vowel .But it is not clear how the feature [ + strident ] is to be eliminated ( is this done automatically because there are no [ + strident -consonantal ] sounds ? ) , or how the values of the features [ voiced ] , [ anterior ] and [ distributed ] are changed .","label":"Background","metadata":{},"score":"52.323647"}{"text":"Otherwise , if value contains an @id key , the compacted value is value with the value of @id processed according to the IRI Compaction steps .Otherwise , if the active context contains a @language , which matches the @language of the value , or the value has only a @value key , the compacted value is the value associated with the @value key .","label":"Background","metadata":{},"score":"52.323997"}{"text":"[ 2 ] This is the position of Aronoff ( 1976 ) , Zwicky ( 1985 ) and Anderson ( 1992 ) , among others .With this view of the distinction between IA and IP models of morphology , consider how an IA analysis might be represented in an implementation of an IP model .","label":"Background","metadata":{},"score":"52.3297"}{"text":"[ 2 ] This is the position of Aronoff ( 1976 ) , Zwicky ( 1985 ) and Anderson ( 1992 ) , among others .With this view of the distinction between IA and IP models of morphology , consider how an IA analysis might be represented in an implementation of an IP model .","label":"Background","metadata":{},"score":"52.3297"}{"text":"JSON - LD is designed as a light - weight syntax that can be used to express Linked Data .It is primarily intended to be a way to use Linked Data in Javascript and other Web - based programming environments .","label":"Background","metadata":{},"score":"52.37593"}{"text":"Unlike free morphemes , then , bound morphemes are phonological modifications ( only ) of the phonological representations of lexemes which mark the fact that the lexeme has undergone lexical or inflectional derivation ( the Empty Morpheme Entailment ) .Neither type of morpheme has any meaning and thus morphemes attribute no meaning to the stems to which they attach .","label":"Background","metadata":{},"score":"52.38817"}{"text":"The application of a set of allomorphy rules then constitutes a constraint satisfaction problem .Suppose that for each morpheme , there is an allomorphy rule , with each allomorphy rule having one or more subrules .The subrules are ordered from specific to general , so that if two subrules are applicable to the same representation , only the more specific subrule applies .","label":"Background","metadata":{},"score":"52.454712"}{"text":"The application of a set of allomorphy rules then constitutes a constraint satisfaction problem .Suppose that for each morpheme , there is an allomorphy rule , with each allomorphy rule having one or more subrules .The subrules are ordered from specific to general , so that if two subrules are applicable to the same representation , only the more specific subrule applies .","label":"Background","metadata":{},"score":"52.454712"}{"text":"array , append output , otherwise append output to .active property in parent .At the completion of the recursive algorithm , results will contain the top - level .node definition s. .The final two steps of the framing algorithm require results to be compacted according to the Compaction Algorithm by using the context provided in the . input frame .","label":"Background","metadata":{},"score":"52.523514"}{"text":"There is a set of morphemes which undergoes vowel shortening , and another set of morphemes which triggers this shortening process .The latter class is provided with a Morpheme Property ' foreshortens . 'One way to ensure that morphemes of the first class appear with shortened vowels appear always and only before morphemes of the second class , would be to attach MECs to the allomorphs of the first class , for instance : .","label":"Background","metadata":{},"score":"52.64779"}{"text":"There is a set of morphemes which undergoes vowel shortening , and another set of morphemes which triggers this shortening process .The latter class is provided with a Morpheme Property ' foreshortens . 'One way to ensure that morphemes of the first class appear with shortened vowels appear always and only before morphemes of the second class , would be to attach MECs to the allomorphs of the first class , for instance : .","label":"Background","metadata":{},"score":"52.64779"}{"text":"Consider for instance the Tzeltal suffixes -hib ' place or instrument nominalizer ' and -hom ' agentive , agentive nominalizer ' ( Slocum 1948 ) .Not only would it be difficult to derive both sets of allomorphs by general phonological rules , but the resulting rules would be very odd , since neither set of environments constitutes a natural class .","label":"Background","metadata":{},"score":"52.724716"}{"text":"Consider for instance the Tzeltal suffixes -hib ' place or instrument nominalizer ' and -hom ' agentive , agentive nominalizer ' ( Slocum 1948 ) .Not only would it be difficult to derive both sets of allomorphs by general phonological rules , but the resulting rules would be very odd , since neither set of environments constitutes a natural class .","label":"Background","metadata":{},"score":"52.724716"}{"text":"Chapter 4 , \" Top - down Control and Recursion on Structure \" focuses on the termination properties of top - down control in the light of syntactic under - determination .As the structural recursion is often used in lexicalist - based formalisms like HPSG , the author seeks adequate repairing of the problematic cases .","label":"Background","metadata":{},"score":"52.76124"}{"text":"The morphological parsing program AMPLE is often used in CARLA applications .Theories of morphology have been classified as Item - and - Arrangement ( in which both roots and affixes are treated as morphemes ) , or Item - and - Process ( in which roots are morphemes , but affixes are rules ) .","label":"Background","metadata":{},"score":"52.86941"}{"text":"a flag specifying that objects should be directly embedded in the output , instead of being referred to by their IRI . explicit inclusion flag .a flag specifying that for properties to be included in the output , they must be explicitly declared in the . framing context . omit default flag .","label":"Background","metadata":{},"score":"52.931694"}{"text":"These conditions on allomorphs in an AMPLE lexical entry include ' morpheme environment constraints ' and ' string environment constraints . 'String environment constraints encode phonetic properties of the environment in which the allomorph is allowed to appear , or in which it must not appear .","label":"Background","metadata":{},"score":"52.94726"}{"text":"These conditions on allomorphs in an AMPLE lexical entry include ' morpheme environment constraints ' and ' string environment constraints . 'String environment constraints encode phonetic properties of the environment in which the allomorph is allowed to appear , or in which it must not appear .","label":"Background","metadata":{},"score":"52.94726"}{"text":"All JSON - LD tokens and keywords are case - sensitive .a context that is specified to the algorithm before processing begins .The contents of the initial context is defined in Appendix B . active subject .the currently active subject that the processor should use when processing .","label":"Background","metadata":{},"score":"52.990963"}{"text":"25 Here I abstract away from the distinction in AMPLE between final tests and tests on the current morpheme .26 It has been argued that prefixes and suffixes behave differently with respect to feature percolation ( Di Sciullo and Williams 1987 ) , but this is far from universally accepted .","label":"Background","metadata":{},"score":"53.07521"}{"text":"25 Here I abstract away from the distinction in AMPLE between final tests and tests on the current morpheme .26 It has been argued that prefixes and suffixes behave differently with respect to feature percolation ( Di Sciullo and Williams 1987 ) , but this is far from universally accepted .","label":"Background","metadata":{},"score":"53.07521"}{"text":"JSON - LD input , but present in the . input frame should be omitted from the output .Framing Algorithm .This algorithm is a work in progress .Presently , it only works for documents without named graphs .Currently , framing allows just to select node definitions based on @type matching or duck typing for included properties .","label":"Background","metadata":{},"score":"53.1079"}{"text":"In classical generative phonology , the question of when in the course of a derivation allomorphy rules were to be applied also had a simple answer : the allomorphy rules applied in a block after affixation , and immediately before the true phonological rules .","label":"Background","metadata":{},"score":"53.166656"}{"text":"In classical generative phonology , the question of when in the course of a derivation allomorphy rules were to be applied also had a simple answer : the allomorphy rules applied in a block after affixation , and immediately before the true phonological rules .","label":"Background","metadata":{},"score":"53.166656"}{"text":"In a seminal paper , Hockett ( 1954 ) divided theories of morphology into two classes : Item - and - Arrangement and Item - and - Process .[ 1 ] .Under an Item - and - Arrangement theory ( henceforth \" IA \" ) , roots and affixes are both treated as morphemes , with at least one allomorph of each stored in the lexicon .","label":"Background","metadata":{},"score":"53.282894"}{"text":"In a seminal paper , Hockett ( 1954 ) divided theories of morphology into two classes : Item - and - Arrangement and Item - and - Process .[ 1 ] .Under an Item - and - Arrangement theory ( henceforth \" IA \" ) , roots and affixes are both treated as morphemes , with at least one allomorph of each stored in the lexicon .","label":"Background","metadata":{},"score":"53.282894"}{"text":"39 - 79 ) by Manning , Sag and Iida considers the lexical integrity of Japanese causatives .Chapter 2 ( pp .80 - 118 ) by Johnston proposes a syntax and semantics for ( English ) purposive adjuncts .Chapter 3 ( pp .","label":"Background","metadata":{},"score":"53.347008"}{"text":"Chapter 1 ( pp .39 - 79 ) by Manning , Sag and Iida considers the lexical integrity of Japanese causatives .Chapter 2 ( pp .80 - 118 ) by Johnston proposes a syntax and semantics for ( English ) purposive adjuncts .","label":"Background","metadata":{},"score":"53.460438"}{"text":"Otherwise , if frame has a @type property only a empty .JSON object , matches any .node definition with a @type property , regardless of the actual values .Otherwise , match if the .node definition contains all of the non- .","label":"Background","metadata":{},"score":"53.50302"}{"text":"Hockett , Charles .\" Two models of grammatical description .\" Word 10 : 210 - 231 .Reprinted in Joos ( 1957 ) , pages 386 - 399 .Kiparsky , Paul . \" ' Elsewhere ' in phonology . \"","label":"Background","metadata":{},"score":"53.54722"}{"text":"Hockett , Charles .\" Two models of grammatical description .\" Word 10 : 210 - 231 .Reprinted in Joos ( 1957 ) , pages 386 - 399 .Kiparsky , Paul . \" ' Elsewhere ' in phonology . \"","label":"Background","metadata":{},"score":"53.54722"}{"text":"This document is a detailed specification for a serialization of Linked Data in JSON .The document is primarily intended for the following audiences : .Authors that want a very detailed view of how JSON - LD processors operate .Software developers that want to implement processors and APIs for JSON - LD .","label":"Background","metadata":{},"score":"53.59053"}{"text":"The concise and well - organised overview provided by the editors is very helpful in navigating through the volume .REFERENCES Flickinger , D. , S. Oepen , J. Tsujii and H. Uszkoreit , Eds .Journal of Natural Language Engineering .","label":"Background","metadata":{},"score":"53.738724"}{"text":"The concise and well - organised overview provided by the editors is very helpful in navigating through the volume .REFERENCES Flickinger , D. , S. Oepen , J. Tsujii and H. Uszkoreit , Eds .Journal of Natural Language Engineering .","label":"Background","metadata":{},"score":"53.738724"}{"text":"Like Allomorph Properties , Morpheme Properties are designed to express cooccurrence restrictions ( WBM : 128 ) ; but unlike Allomorph Properties , Morpheme Properties are assigned to all allomorphs of a given morpheme .Their use encompasses both morphosyntactic features and diacritic ( rule ) features .","label":"Background","metadata":{},"score":"54.005585"}{"text":"Like Allomorph Properties , Morpheme Properties are designed to express cooccurrence restrictions ( WBM : 128 ) ; but unlike Allomorph Properties , Morpheme Properties are assigned to all allomorphs of a given morpheme .Their use encompasses both morphosyntactic features and diacritic ( rule ) features .","label":"Background","metadata":{},"score":"54.005585"}{"text":"frame provided to the framing algorithm . framing context .a context containing a . map of embeds , the . object embed flag , the .explicit inclusion flag and the . omit default flag . map of embeds .a map that tracks if a subject is to be embedded in the output of the Framing Algorithm ; it maps a subject @id to a parent .","label":"Background","metadata":{},"score":"54.297134"}{"text":"Theories of morphology have been classified as Item - and - Arrangement ( in which both roots and affixes are treated as morphemes ) , or Item - and - Process ( in which roots are morphemes , but affixes are rules ) .","label":"Background","metadata":{},"score":"54.423412"}{"text":"The output of this series of processes is then submitted to morphological spelling ( the MS - module ) , similar to ' Spellout ' in related models .Of course , the lexical description of the verb bake is preserved in the deivation and will continue to determine government and binding properties .","label":"Background","metadata":{},"score":"54.505054"}{"text":"What PVP and split NP topicalisation have in common , on their approach , is that the material missing from the topic appears as a complement in the non-topicalised position .Summing up : most of the issues explored in this book are central to the HPSG theory and tackle very specific problems in considerable depth .","label":"Background","metadata":{},"score":"54.542698"}{"text":"What PVP and split NP topicalisation have in common , on their approach , is that the material missing from the topic appears as a complement in the non-topicalised position .Summing up : most of the issues explored in this book are central to the HPSG theory and tackle very specific problems in considerable depth .","label":"Background","metadata":{},"score":"54.542698"}{"text":"The reported results are somewhat controversial : the module is faster in some cases but slower in others ( such as : delayed goals ) .The problem sources are detected and pointed out along with the areas that need further exploration .","label":"Background","metadata":{},"score":"54.57227"}{"text":"The left and right environments are a sort of regular expression whose leaf elements may be natural classes , segments , or boundary markers , and whose nonterminal elements encode optionality and repetition .Finally , it is possible to require agreement between feature values in the input , output , and environment ( i.e. so - called \" alpha \" variables are supported ) .","label":"Background","metadata":{},"score":"54.576504"}{"text":"The left and right environments are a sort of regular expression whose leaf elements may be natural classes , segments , or boundary markers , and whose nonterminal elements encode optionality and repetition .Finally , it is possible to require agreement between feature values in the input , output , and environment ( i.e. so - called \" alpha \" variables are supported ) .","label":"Background","metadata":{},"score":"54.576504"}{"text":"Each of them starts with a motivation section and concludes with a related work section and a summary section .Chapter 3 is entitled \" Top - down Control and Syntactic Under- determination \" .In it , the problem of syntactic under - determination is explored via the ratio between some linguistic phenomena ( e. g. topicalisation and empty heads ) , the order of the processing steps and the head - driven control .","label":"Background","metadata":{},"score":"54.659645"}{"text":"The effect is not unlike a case structure in many programming languages , with the code to be executed by each case statement followed by a break , and the final case applying if none of the earlier cases have applied .","label":"Background","metadata":{},"score":"54.70013"}{"text":"The effect is not unlike a case structure in many programming languages , with the code to be executed by each case statement followed by a break , and the final case applying if none of the earlier cases have applied .","label":"Background","metadata":{},"score":"54.70013"}{"text":"One of the traditional arguments in favor of IP morphology is that such nonconcatenative morphology can not be represented in IA terms .Anderson ( 1992 , chapter three ) provides an overview of these issues , making the claim that at least some of the classical arguments against IA morphology are still valid .","label":"Background","metadata":{},"score":"54.705982"}{"text":"One of the traditional arguments in favor of IP morphology is that such nonconcatenative morphology can not be represented in IA terms .Anderson ( 1992 , chapter three ) provides an overview of these issues , making the claim that at least some of the classical arguments against IA morphology are still valid .","label":"Background","metadata":{},"score":"54.705982"}{"text":"In other words , the rule takes a noun stem ( whose phonological content is represented by X 1 ) and attaches a suffix ( represented by ut ) to it ; the resulting word has part of speech of verb .","label":"Background","metadata":{},"score":"54.706657"}{"text":"In other words , the rule takes a noun stem ( whose phonological content is represented by X 1 ) and attaches a suffix ( represented by ut ) to it ; the resulting word has part of speech of verb .","label":"Background","metadata":{},"score":"54.706657"}{"text":"node reference .It then recursively removes any entries in the . map of embeds that had the removed .node definition in their parent chain .About as clear as mud .The current behaviour avoids embedding the same data multiple times in the result makes it difficult to work with the output .","label":"Background","metadata":{},"score":"54.70791"}{"text":"This step will terminate when there are no more embed entries containing the removed subject definition 's @id in their parent chain .If item is a JSON object with the key @list , then create a new JSON object with a key @list and a value of an empty array and add it to output , appending if output is an array , and appending to active property otherwise .","label":"Background","metadata":{},"score":"54.887115"}{"text":"Unless subjects as an entry for name create a new entry in subjects initialized using a new JSON object with @id set to name as subject .Otherwise , use that existing entrpy as subject .For each property and value in element other than @id : .","label":"Background","metadata":{},"score":"55.02292"}{"text":"Authors who want to query JSON - LD documents to create representations more appropriate for a given use case .Software developers that want to implement processors and APIs for JSON - LD .To understand the basics in this specification you must first be familiar with JSON , which is detailed in [ [ ! RFC4627]].","label":"Background","metadata":{},"score":"55.033447"}{"text":"A number is is similar to that used in most programming languages , except that the octal and hexadecimal formats are not used and that leading zeros are not allowed . true and false .Boolean values . null .The use of the null value within JSON - LD is used to ignore or reset values . subject definition .","label":"Background","metadata":{},"score":"55.05892"}{"text":"Such a rule might be written as follows : .The braces indicate that the two subrules belong to a single affixation rule , and apply disjunctively in the stated order ( that is , the second subrule applies to a given word only if the first subrule is unable to apply ) .","label":"Background","metadata":{},"score":"55.201096"}{"text":"Such a rule might be written as follows : .The braces indicate that the two subrules belong to a single affixation rule , and apply disjunctively in the stated order ( that is , the second subrule applies to a given word only if the first subrule is unable to apply ) .","label":"Background","metadata":{},"score":"55.201096"}{"text":"Alternatively , third order affixes could prohibit the stem from bearing the feature [ 3 order ] or any higher feature values . )The resulting stem would bear the feature [ 3 order ] , since the feature values of the affix override any conflicting feature values on the stem to which they attach .","label":"Background","metadata":{},"score":"55.239944"}{"text":"Alternatively , third order affixes could prohibit the stem from bearing the feature [ 3 order ] or any higher feature values . )The resulting stem would bear the feature [ 3 order ] , since the feature values of the affix override any conflicting feature values on the stem to which they attach .","label":"Background","metadata":{},"score":"55.239944"}{"text":"Moreover , movement may simply be the phonological realization of grammatical morphemes in positions other than that in which the morphological features determining such realization appear ( Beard 1995 ) .Derivation rules operate in the lexicon ( L - derivation ) and in syntax ( I - derivation ) .","label":"Background","metadata":{},"score":"55.336056"}{"text":"A number of striking parallels between these \" for \" PPs and infinitival purposives are systematically considered , enriching thus the overall picture .III .Alternative accounts of basic constructions in Japanese , with special attention to causatives ( Chapters 1 and 3 ) and topicalisation ( Chapter 5 ) .","label":"Background","metadata":{},"score":"55.394623"}{"text":"A number of striking parallels between these \" for \" PPs and infinitival purposives are systematically considered , enriching thus the overall picture .III .Alternative accounts of basic constructions in Japanese , with special attention to causatives ( Chapters 1 and 3 ) and topicalisation ( Chapter 5 ) .","label":"Background","metadata":{},"score":"55.394623"}{"text":"This constraint says that a particular root must be followed by one of the suffixes whose names are ' IN ' , ' OUT ' , ' UP ' , or ' DOWN ' .The Obligatory Head Feature requirement means that some value of the designated Head Feature must be assigned by the end of the derivation .","label":"Background","metadata":{},"score":"55.410007"}{"text":"This constraint says that a particular root must be followed by one of the suffixes whose names are ' IN ' , ' OUT ' , ' UP ' , or ' DOWN ' .The Obligatory Head Feature requirement means that some value of the designated Head Feature must be assigned by the end of the derivation .","label":"Background","metadata":{},"score":"55.410007"}{"text":"University of Tuebingen , Germany .Hoehfeld , Markus and Gert Smolka ( 1988 )Definite relations over Constraint Languages .Tecnical Report 53 .IBM , Germany .Petya Osenova is researcher in Linguistics .She is assistant professor in syntax at the Sofia University as well .","label":"Background","metadata":{},"score":"55.462616"}{"text":"Consider an example of phonologically conditioned allomorphy which resists easy description by phonological rules .The verbal person - marking prefixes of Tzeltal are given in the following table ( the same prefixes are also used on nouns to mark the person of possessors ) : .","label":"Background","metadata":{},"score":"55.63285"}{"text":"Consider an example of phonologically conditioned allomorphy which resists easy description by phonological rules .The verbal person - marking prefixes of Tzeltal are given in the following table ( the same prefixes are also used on nouns to mark the person of possessors ) : .","label":"Background","metadata":{},"score":"55.63285"}{"text":"( m ) ( X(m )( m X(m ) ) .28 It might seem that the notion of conjugation classes ( or declension classes ) would require a condition of the form ' for every morpheme X , class(X ) holds ' .","label":"Background","metadata":{},"score":"55.645744"}{"text":"( m ) ( X(m )( m X(m ) ) .28 It might seem that the notion of conjugation classes ( or declension classes ) would require a condition of the form ' for every morpheme X , class(X ) holds ' .","label":"Background","metadata":{},"score":"55.645744"}{"text":"A character is represented as a single character string . number .A number is similar to that used in most programming languages , except that the octal and hexadecimal formats are not used and that leading zeros are not allowed . true and . false .","label":"Background","metadata":{},"score":"55.67583"}{"text":"Outwardly sensitive constraints set up by affixes will work in the same fashion , since a morphological rule can add Obligatory Head Feature requirements .[21 ] . 3.8 Infix location . 'Infix locations ' in AMPLE have two uses : . to define the sort of morpheme into which another morpheme can be infixed ; and . to define the phonological environment in which the infix may be found ( after the first consonant of a stem , etc . ) .","label":"Background","metadata":{},"score":"55.745712"}{"text":"Outwardly sensitive constraints set up by affixes will work in the same fashion , since a morphological rule can add Obligatory Head Feature requirements .[21 ] . 3.8 Infix location . 'Infix locations ' in AMPLE have two uses : . to define the sort of morpheme into which another morpheme can be infixed ; and . to define the phonological environment in which the infix may be found ( after the first consonant of a stem , etc . ) .","label":"Background","metadata":{},"score":"55.745712"}{"text":"The author comes to the conclusion that lexical lookup needs to be constrained .Hence two grammar transformations are proposed in order to improve processing constraint propagation and unfold transformation .As to the implementation of the tool in question , it is implemented in Prolog by Detmar Meurers , the author and in cooperation with Dieter Martini .","label":"Background","metadata":{},"score":"55.804665"}{"text":"Maxwell , Michael .\"Phonological Analysis and Opaque Rule Orders .\" Proceedings of the Second International Workshop on Parsing Technologies .Pittsburgh : SIGPARSE group of the Association for Computational Linguistics .Maxwell , Michael .\" Parsing using Linearly Ordered Phonological Rules . \"","label":"Background","metadata":{},"score":"55.883766"}{"text":"Maxwell , Michael .\"Phonological Analysis and Opaque Rule Orders .\" Proceedings of the Second International Workshop on Parsing Technologies .Pittsburgh : SIGPARSE group of the Association for Computational Linguistics .Maxwell , Michael .\" Parsing using Linearly Ordered Phonological Rules . \"","label":"Background","metadata":{},"score":"55.883766"}{"text":"However , specific implementations may choose to operate on the document as a normal JSON description of objects having attributes .graph name .A IRI or Blank Node used to identify statements belonging to a named graph .5.3 Convert to RDF Algorithm .","label":"Background","metadata":{},"score":"55.947998"}{"text":"Tania Avgustinova , Saarland University This book contains a collection of articles on recent developments in the framework of head - driven phrase structure grammar ( HPSG ) , all resulting from a closer investigation of a variety of non - trivial phenomena found in languages like German , Japanese , and English .","label":"Background","metadata":{},"score":"56.00083"}{"text":"I object to this because this is completely arbitrary : you can do anything you want once you are allowed to take impossible sound sequences and put them in your URs .If there are alternations , that is one thing .","label":"Background","metadata":{},"score":"56.046307"}{"text":"Create . framing context using . null for the . map of embeds , the . object embed flag set to . true , the .explicit inclusion flag set to .false , and the . omit default flag set to . false along with . map of flattened subjects set to the @merged property of the result of performing the Node Map Generation algorithm on expanded input .","label":"Background","metadata":{},"score":"56.11397"}{"text":"To solve this problem , the author proposes a grammar transformation technique , called ' literal rearrangement ' and describes its implementation in Prolog .The procedure takes as input a grammar and a description of the instantiation of the grammar input .","label":"Background","metadata":{},"score":"56.114788"}{"text":"The result is a single V incorrectly positioned under an NP .When this occurs , the lexicon 's job is to transpose the illegal category to the legal one , i.e. provide the verb with nominal category functions ( 4 ) .","label":"Background","metadata":{},"score":"56.139908"}{"text":"Theories of morphology are commonly classified as being either Item - and - Arrangement ( in which both roots and affixes are treated as morphemes ) , or Item - and - Process ( in which roots are morphemes , but affixes are rules ) .","label":"Background","metadata":{},"score":"56.179802"}{"text":"Theories of morphology are commonly classified as being either Item - and - Arrangement ( in which both roots and affixes are treated as morphemes ) , or Item - and - Process ( in which roots are morphemes , but affixes are rules ) .","label":"Background","metadata":{},"score":"56.179802"}{"text":"active property in output .Process each property and value in frame , where property is not a keyword , ordered by property : .Set property frame to the first item in value or a newly created .JSON object if value is empty .","label":"Background","metadata":{},"score":"56.185738"}{"text":"333 - 335 ) .The references are listed immediately after each contribution .The research presented in this volume focuses on four major topics .I. The morphology / syntax interface with respect to agreement phenomena ( Chapter 6 ) .","label":"Background","metadata":{},"score":"56.261482"}{"text":"333 - 335 ) .The references are listed immediately after each contribution .The research presented in this volume focuses on four major topics .I. The morphology / syntax interface with respect to agreement phenomena ( Chapter 6 ) .","label":"Background","metadata":{},"score":"56.261482"}{"text":"Reprinted in Studies on Semantics in Generative Grammar , by Noam Chomsky ( 1972 ) , pg .The Hague : Mouton .Halle , Morris .Phonological Features .Pg .207 - 212 in The International Encyclopedia of Linguistics , vol .","label":"Background","metadata":{},"score":"56.403397"}{"text":"Reprinted in Studies on Semantics in Generative Grammar , by Noam Chomsky ( 1972 ) , pg .The Hague : Mouton .Halle , Morris .Phonological Features .Pg .207 - 212 in The International Encyclopedia of Linguistics , vol .","label":"Background","metadata":{},"score":"56.403397"}{"text":"Now consider infixes .For concreteness , suppose the infix -n- attaches after the first consonant + vowel of the stem .Such an affix might be represented as follows : .[ C 1 V 2 X 3 ] N [ 1 2 n 3 ] V .","label":"Background","metadata":{},"score":"56.46468"}{"text":"Now consider infixes .For concreteness , suppose the infix -n- attaches after the first consonant + vowel of the stem .Such an affix might be represented as follows : .[ C 1 V 2 X 3 ] N [ 1 2 n 3 ] V .","label":"Background","metadata":{},"score":"56.46468"}{"text":"active property as property and add to . map of embeds .Initialize a new .node definition o to act as the embedded .node definition .For each property and value in the expanded definition for item in subjects : .","label":"Background","metadata":{},"score":"56.669086"}{"text":"Otherwise , if the active context contains a coercion target for the key that matches the expression of the value , compact the value using the following steps : .If the coercion target is an @id , the compacted value is the value associated with the @id key , processed according to the IRI Compaction steps .","label":"Background","metadata":{},"score":"56.713173"}{"text":"A JSON - LD document is a representation of a directed graph .A single directed graph can have many different serializations , each expressing exactly the same information .Developers typically work with trees , represented as .JSON object s. While mapping a graph to a tree can be done , the layout of the end result must be specified in advance .","label":"Background","metadata":{},"score":"56.753876"}{"text":"In particular , they could provide the foundations for a more comprehensive theory of agreement than the one developed in [ Pollard and Sag 1994].The discussion involves data from French , German , Latin , Swahili , Spanish , Italian , Russian , Serbo - Croatian , Korean , and , of course , English .","label":"Background","metadata":{},"score":"56.881027"}{"text":"In particular , they could provide the foundations for a more comprehensive theory of agreement than the one developed in [ Pollard and Sag 1994].The discussion involves data from French , German , Latin , Swahili , Spanish , Italian , Russian , Serbo - Croatian , Korean , and , of course , English .","label":"Background","metadata":{},"score":"56.881027"}{"text":"We expect these discussions to be informal and interactive ; and the author of the book discussed is cordially invited to join in .If you are interested in leading a book discussion , look for books announced on LINGUIST as \" available for discussion . \"","label":"Background","metadata":{},"score":"56.894707"}{"text":"We expect these discussions to be informal and interactive ; and the author of the book discussed is cordially invited to join in .If you are interested in leading a book discussion , look for books announced on LINGUIST as \" available for discussion . \"","label":"Background","metadata":{},"score":"56.894707"}{"text":"It is also common in AMPLE to test that the ' FINAL tocategory ' belongs to a set of admissible categories , in order to ensure that all necessary affixes have been attached .In general , many of the tests done in AMPLE with categories ( parts of speech ) are more conveniently treated in Hermit Crab with features or subcategorization lists .","label":"Background","metadata":{},"score":"56.934593"}{"text":"It is also common in AMPLE to test that the ' FINAL tocategory ' belongs to a set of admissible categories , in order to ensure that all necessary affixes have been attached .In general , many of the tests done in AMPLE with categories ( parts of speech ) are more conveniently treated in Hermit Crab with features or subcategorization lists .","label":"Background","metadata":{},"score":"56.934593"}{"text":"They are used for normalization , fromRDF , and from toRDF interfaces .The name associated with the Statement identifying it as a member of a named graph .If the attribute is present , it indicates that this statement is a member of a named graph associated with name .","label":"Background","metadata":{},"score":"56.986477"}{"text":"119 - 160 ) by Gungi is on lexicalist treatment of Japanese causatives .Chapter 4 ( pp .161 - 198 ) by Baker looks at \" modal flip \" and partial verb phrase fronting in German .Chapter 5 ( pp .","label":"Background","metadata":{},"score":"57.030853"}{"text":"The input is used to build the framed output and is returned if there are no errors .If there are no matches for the frame , . null MUST be returned .Exceptions MUST be thrown if there are errors . object or object [ ] or IRI input .","label":"Background","metadata":{},"score":"57.091805"}{"text":"The assumption of sign base morphology ( Saussure 1916 ) , results from the fact that the default procedure for the MS ( spelling ) component is to realize features in the order in which it encounters them .You may see an illustration of derivational and spelling operations by clicking here .","label":"Background","metadata":{},"score":"57.22023"}{"text":"Proceedings of the Association of Computational Linguistics post - conference workshop on Computational Environments for Grammar and Linguistic Engineering , Madrid , Spain .Hinrichs , Erhard , Detmar Meurers , Frank Richter , Manfred Sailer and Heike Winhart ( 1997 )","label":"Background","metadata":{},"score":"57.296417"}{"text":"Furthermore , in the case where there could be analogous alternations ( between syllabic and nonsyllabic r ) , they do not work out as one would want .It is NOT the case that syllabic r appears before suffixes in morphemes which take penultimate stress and nonsyllabic in those with antepenultimate stress .","label":"Background","metadata":{},"score":"57.322327"}{"text":"If the property 's value is a simple string , determine the IRI mapping value by performing IRI Expansion on the associated value .If the result of the IRI mapping is an absolute IRI , merge the property into the local context term mapping , unless the property is a JSON - LD keyword , in which case throw an exception .","label":"Background","metadata":{},"score":"57.368904"}{"text":"In such cases ( which , according to Carstairs 1987 , are rare ) , the outward sensitivity will need to be handled by an allomorphy rule applying after the outer suffix is attached , assuming the test in question determines the choice of allomorph .","label":"Background","metadata":{},"score":"57.447845"}{"text":"In such cases ( which , according to Carstairs 1987 , are rare ) , the outward sensitivity will need to be handled by an allomorphy rule applying after the outer suffix is attached , assuming the test in question determines the choice of allomorph .","label":"Background","metadata":{},"score":"57.447845"}{"text":"The latter comprises the left recursion in parsing and the head recursion in generation .Then the notion of ' argument sequence ' is proposed .In this way it is possible to predetermine whether a recursive procedure is guaranteed to terminate .","label":"Background","metadata":{},"score":"57.461452"}{"text":"RDF - CONCEPTS]].General Terminology .The intent of the Working Group and the Editors of this specification is to eventually align terminology used in this document with the terminology used in the RDF Concepts document to the extent to which it makes sense to do so .","label":"Background","metadata":{},"score":"57.469734"}{"text":"In such a language , a number of phonological processes , none of them difficult to state in current phonological theories , affect affixes .For instance , suffix vowels might agree in the feature [ back ] with the vowel to their left , while high vowels might agree in the feature [ round ] as well .","label":"Background","metadata":{},"score":"57.554173"}{"text":"In such a language , a number of phonological processes , none of them difficult to state in current phonological theories , affect affixes .For instance , suffix vowels might agree in the feature [ back ] with the vowel to their left , while high vowels might agree in the feature [ round ] as well .","label":"Background","metadata":{},"score":"57.554173"}{"text":"For instance , if the backness and rounding features of the vowel were determined by vowel harmony , one might modify the above rule as follows : .[X ] N [ X high_back_vowel t ] V .-- where high_back_vowel had been previously defined as a \" natural class \" bearing the appropriate phonetic features , e.g. : .","label":"Background","metadata":{},"score":"57.56845"}{"text":"For instance , if the backness and rounding features of the vowel were determined by vowel harmony , one might modify the above rule as follows : .[X ] N [ X high_back_vowel t ] V .-- where high_back_vowel had been previously defined as a \" natural class \" bearing the appropriate phonetic features , e.g. : .","label":"Background","metadata":{},"score":"57.56845"}{"text":"Beard ( 1988 , 1995 ) describes four types of L - derivation : transpositions , functional derivation , feature switches , and expressive derivation .Lexical switches modify the value of inherent lexical features such as those of Gender , Number , and Paradigm Class .","label":"Background","metadata":{},"score":"57.629097"}{"text":"the currently active property that the processor should use when processing .The active property is represented in the original lexical form , which is used for finding coercion mappings in the active context .active object .the currently active object that the processor should use when processing .","label":"Background","metadata":{},"score":"57.74523"}{"text":"If property is a keyword , add property and a copy of value to output and continue with the next property from subject .If property is not in frame : .If explicitOn is false , Embed values from subject in output using subject as element and property as active property .","label":"Background","metadata":{},"score":"57.75827"}{"text":"JSON - LD ] ] , which is the base syntax used by all of the algorithms in this document , and the JSON - LD API [ [ !JSON - LD - API]].To understand the API and how it is intended to operate in a programming environment , it is useful to have working knowledge of the JavaScript programming language [ [ ECMA-262 ] ] and WebIDL [ [ ! WEBIDL]].","label":"Background","metadata":{},"score":"57.837543"}{"text":"LMBM , then , distinguishes itself from other lexeme - based theories in that it maintains a pristine distinction between lexemes and grammatical morphemes and consequently predicts this distinction at every level of language and speech .Lexeme - Morpheme Base Morphology ( LMBM ) is a variant of what Aronoff ( 1994 ) refers to as a ' lexeme - base ' morphological theory .","label":"Background","metadata":{},"score":"58.01114"}{"text":"The temporary identifier of the BlankNode .The nominalValue must not be relied upon in any way between two separate processing runs of the same document .Developers and authors must not assume that the nominalValue of a BlankNode will remain the same between two processing runs .","label":"Background","metadata":{},"score":"58.09813"}{"text":"Invoke the recursive algorithm using . framing context ( state ) , the . map of flattened subjects ( subjects ) , expanded frame ( frame ) , result as parent , and . null as .active property .The following series of steps is the recursive portion of the framing algorithm : .","label":"Background","metadata":{},"score":"58.105213"}{"text":"Otherwise , if the property is @value or @language the value must not be a JSON object or an array .Otherwise , if the property is @list , @set , or @graph , expand value recursively using this algorithm , passing copies of the active context and active property .","label":"Background","metadata":{},"score":"58.127274"}{"text":"30 Such an analysis would imply that it would be impossible to have allomorphs of the stem which are conditioned by the shape of the infix .Chomsky , Noam . \"Remarks on nominalization . \"Pg .184 - 221 in Readings in English Transformational Grammar , edited by Roderick A. Jacobs and Peter S. Rosenbaum .","label":"Background","metadata":{},"score":"58.139397"}{"text":"30 Such an analysis would imply that it would be impossible to have allomorphs of the stem which are conditioned by the shape of the infix .Chomsky , Noam . \"Remarks on nominalization . \"Pg .184 - 221 in Readings in English Transformational Grammar , edited by Roderick A. Jacobs and Peter S. Rosenbaum .","label":"Background","metadata":{},"score":"58.139397"}{"text":"A . language - tagged string is a .literal without a datatype , including a language .See languaged - tagged string in [ [ !RDF - CONCEPTS]]. typed literal .A . typed literal is a .","label":"Background","metadata":{},"score":"58.14945"}{"text":"In contrast , Hinrics and Nakazawa , who build on their previous work in argument composition , treat the fronted PVP as a completely saturated constituent , with the missing material being extracted ( hence , recorded in the SLASH specification of the V head ) .","label":"Background","metadata":{},"score":"58.291107"}{"text":"In contrast , Hinrics and Nakazawa , who build on their previous work in argument composition , treat the fronted PVP as a completely saturated constituent , with the missing material being extracted ( hence , recorded in the SLASH specification of the V head ) .","label":"Background","metadata":{},"score":"58.291107"}{"text":"There are several other Tzeltal suffixes having approximately the shape of one or the other of these allomorphs , but none which undergoes this particular alternation .It therefore seems unlikely that this alternation should , or even could , be accounted for by a general phonological rule , despite its phonological conditioning .","label":"Background","metadata":{},"score":"58.31022"}{"text":"There are several other Tzeltal suffixes having approximately the shape of one or the other of these allomorphs , but none which undergoes this particular alternation .It therefore seems unlikely that this alternation should , or even could , be accounted for by a general phonological rule , despite its phonological conditioning .","label":"Background","metadata":{},"score":"58.31022"}{"text":"IV .Argument structure and constituency in German ( Chapters 4 and 7 ) .The two contributions on this topic share a number of common perspectives on the analysis of German clausal structure as well as the nature of the lexical entries for auxiliaries .","label":"Background","metadata":{},"score":"58.35298"}{"text":"IV .Argument structure and constituency in German ( Chapters 4 and 7 ) .The two contributions on this topic share a number of common perspectives on the analysis of German clausal structure as well as the nature of the lexical entries for auxiliaries .","label":"Background","metadata":{},"score":"58.35298"}{"text":"93 - 106 in A Festschrift for Morris Halle , edited by Stephen R. Anderson and Paul Kiparsky .New York : Holt , Rinehart and Winston .Lieber , Rochelle .\" On the Organization of the Lexicon . \"Ph.D. dissertation , MIT ; published 1981 by the Indiana University Linguistics Club .","label":"Background","metadata":{},"score":"58.371674"}{"text":"93 - 106 in A Festschrift for Morris Halle , edited by Stephen R. Anderson and Paul Kiparsky .New York : Holt , Rinehart and Winston .Lieber , Rochelle .\" On the Organization of the Lexicon . \"Ph.D. dissertation , MIT ; published 1981 by the Indiana University Linguistics Club .","label":"Background","metadata":{},"score":"58.371674"}{"text":"Blank nodes may be named or unnamed and often take on the role of a variable that may represent either an IRI or a literal . compact IRI . a compact IRI is has the form of prefix and suffix and is used as a way of expressing an IRI without needing to define separate term definitions for each IRI contained within a common vocabulary identified by prefix .","label":"Background","metadata":{},"score":"58.396957"}{"text":"It can be difficult to distinguish between a compact IRI and an absolute IRI , as a compact IRI may seem to be a valid IRI scheme .When performing repeated IRI expansion , a term used as a prefix may not have a valid mapping due to dependencies in resolving term definitions .","label":"Background","metadata":{},"score":"58.41165"}{"text":"Would n't it make more biological sense to let the person get on with their life and the business of propagating their genes ?It occurred to me that perhaps the deterrance is not just for you -- but for those around you , and that this factor could help explain why it is so highly debilitating ( if in fact this actually requires any separate explanation ) .","label":"Background","metadata":{},"score":"58.516563"}{"text":"Somerset , NJ : Association for Computational Linguistics .Editor 's note : This paper was originally presented at SIL 's General CARLA Conference , 14 - 15 November 1996 , Waxhaw , NC .CARLA , for Computer - Assisted Related Language Adaptation , is the application of machine translation techniques between languages that are so closely related to each other that a literal translation can produce a useful first draft .","label":"Background","metadata":{},"score":"58.640858"}{"text":"( The ' 1 ' and ' 2 ' in the output of the subrules correspond to the first and second elements of the inputs , which are simply copied over to the output ; see the discussion in appendix 1 . )","label":"Background","metadata":{},"score":"58.663418"}{"text":"( The ' 1 ' and ' 2 ' in the output of the subrules correspond to the first and second elements of the inputs , which are simply copied over to the output ; see the discussion in appendix 1 . )","label":"Background","metadata":{},"score":"58.663418"}{"text":"Thus , each affix is subject to a number of phonological processes , in some cases resulting in a large number of allomorphs .Some affixes may be exceptions to some of these otherwise general processes .For example , in the Turkish suffix -Iyor ' momentary action ' , only the first vowel undergoes harmony .","label":"Background","metadata":{},"score":"58.881805"}{"text":"Thus , each affix is subject to a number of phonological processes , in some cases resulting in a large number of allomorphs .Some affixes may be exceptions to some of these otherwise general processes .For example , in the Turkish suffix -Iyor ' momentary action ' , only the first vowel undergoes harmony .","label":"Background","metadata":{},"score":"58.881805"}{"text":"Linked Data is a technique for creating a graph of interlinked data across different documents or Web sites .Data entities are described using IRI s , which are typically dereferencable and thus may be used to find more information about an entity , creating a \" Web of Knowledge \" .","label":"Background","metadata":{},"score":"58.931435"}{"text":"( The allomorphy can easily be derived by classical generative phonological rules , of the type used in The Sound Pattern of English , for instance . )This is perhaps a case for not using an up - to - date theory !","label":"Background","metadata":{},"score":"58.93579"}{"text":"( The allomorphy can easily be derived by classical generative phonological rules , of the type used in The Sound Pattern of English , for instance . )This is perhaps a case for not using an up - to - date theory !","label":"Background","metadata":{},"score":"58.93579"}{"text":"For example , assume the following JSON - LD input document : .Running the JSON - LD Expansion algorithm against the JSON - LD input document provided above would result in the following output : .If element is an array , process each entry in element recursively using this algorithm , passing copies of the active context and active property .","label":"Background","metadata":{},"score":"59.102642"}{"text":"At times , a JSON - LD document may be received that is not in its most compact form .JSON - LD , via the API , provides a way to compact a JSON - LD document .For example , assume the following JSON - LD input document : .","label":"Background","metadata":{},"score":"59.250732"}{"text":"The algorithm for compaction optimization is beyond the scope of this specification and thus not defined .Consequently , different implementations may implement different optimization algorithms . boolean noType .If set to true , the JSON - LD processor will not use the @type property when generating the output , and will use the expanded rdf : type IRI as the property instead of @type .","label":"Background","metadata":{},"score":"59.29588"}{"text":"Pass the first value from frame for property as frame , output as parent , and property as .active property .Passing a .node reference does n't work if this map is used recursively .Presently pass .node definition from original . map of flattened subjects .","label":"Background","metadata":{},"score":"59.50463"}{"text":"If the expanded entry is null , drop it .If it 's an array , merge it 's entries with element 's entries .Otherwise , if value is an array , all elements must be either a string or subject reference .","label":"Background","metadata":{},"score":"59.774975"}{"text":"the currently active property that the processor should use when processing .The active property is represented in the original lexical form , which is used for finding coercion mappings in the . active context .active object .the currently active object that the processor should use when processing . active context .","label":"Background","metadata":{},"score":"59.78174"}{"text":"And since in the times when evolution was at work we lived mostly in tribal groups with large numbers of relatives , Kin selection would explain how this kind of grief could evolve to serve \" both \" these purposes .Perhaps just the right impact on the grief is where it has a large precautionary effect on the other kin members at the expense of really debilitating the grieving person ?","label":"Background","metadata":{},"score":"59.864063"}{"text":"An inwardly sensitive positive ( negative ) Morpheme Co - occurrence Constraint represents the fact that an affix requires ( forbids ) some other morpheme to be present in the stem to which it attaches .( Examples of both positive and negative constraints are given in WBM section 11.3.6 , page 75 . )","label":"Background","metadata":{},"score":"59.97745"}{"text":"An inwardly sensitive positive ( negative ) Morpheme Co - occurrence Constraint represents the fact that an affix requires ( forbids ) some other morpheme to be present in the stem to which it attaches .( Examples of both positive and negative constraints are given in WBM section 11.3.6 , page 75 . )","label":"Background","metadata":{},"score":"59.97745"}{"text":"// Convert the JSON - LD document to RDF ; this converts 42 to a string .// Convert the RDF triples back to a JavaScript object .At this point , myObj1 and myObj2 will have different values for the \" number \" property .","label":"Background","metadata":{},"score":"60.052235"}{"text":"The use of the .null value within JSON - LD is used to ignore or reset values . keyword .A JSON key that is specific to JSON - LD , specified in the JSON - LD Syntax specification [ [ !","label":"Background","metadata":{},"score":"60.109516"}{"text":"Return the mapped identifier .Otherwise , increment next identifier by adding one to the integer suffix and return its original value .3.9 Expansion .Expansion is the process of taking a JSON - LD document and applying a context such that all IRI , datatypes , and literal values are expanded so that the context is no longer necessary .","label":"Background","metadata":{},"score":"60.123672"}{"text":"Sproat 1992 , section 3.6.5 , particularly footnote 62 ) .For instance , AMPLE has no built - in behavior with regard to Morpheme Properties ; any special behavior must be programmed in by the user .Nor does AMPLE have any built - in notion of a hierarchy of morphological structure ; one can only write tests concerning morphemes to the left or right of a given morpheme .","label":"Background","metadata":{},"score":"60.189438"}{"text":"Sproat 1992 , section 3.6.5 , particularly footnote 62 ) .For instance , AMPLE has no built - in behavior with regard to Morpheme Properties ; any special behavior must be programmed in by the user .Nor does AMPLE have any built - in notion of a hierarchy of morphological structure ; one can only write tests concerning morphemes to the left or right of a given morpheme .","label":"Background","metadata":{},"score":"60.189438"}{"text":"Running the JSON - LD Compaction algorithm given the context supplied above against the JSON - LD input document provided above would result in the following output : .The compaction algorithm also enables the developer to map any expanded format into an application - specific compacted format .","label":"Background","metadata":{},"score":"60.21875"}{"text":"The JsonLdOptions type is used to convert a set of options to an interface method .See .JsonLdOptions definition in [ [ !JSON - LD - API]].Algorithms .All algorithms described in this section are intended to operate on language - native data structures .","label":"Background","metadata":{},"score":"60.220795"}{"text":"9 Perhaps Haeckel was right ; perhaps ontogeny does recapitulate phylogeny . 10 Admittedly , this is not always possible , for instance if the description uses mechanisms of IP morphology which have no counterpoint in IA morphology .11 Relaxing the minimum length from one to zero gives phonologically null stems , should this be deemed desirable .","label":"Background","metadata":{},"score":"60.251457"}{"text":"9 Perhaps Haeckel was right ; perhaps ontogeny does recapitulate phylogeny . 10 Admittedly , this is not always possible , for instance if the description uses mechanisms of IP morphology which have no counterpoint in IA morphology .11 Relaxing the minimum length from one to zero gives phonologically null stems , should this be deemed desirable .","label":"Background","metadata":{},"score":"60.251457"}{"text":"A JSON object is a subject definition if it does not contain they keys @value , @list or @set and it has one or more keys other than @id .Note that the definition for Linked Data above is silent on the topic of unlabeled nodes .","label":"Background","metadata":{},"score":"60.257988"}{"text":"The author gives details concerning the implementation of the ' selective magic HPSG parser ' .It was implemented in Prolog by the author himself for the ConTroll system and tested with a linearization grammar of German ( Hinrichs et . al .","label":"Background","metadata":{},"score":"60.28509"}{"text":"It may be that this capability should be added .For instance , the allomorphy rule given in example ( 6 ) and repeated here seems to require this power : .( 7 ) -fy -fic / _ _ -Ation .","label":"Background","metadata":{},"score":"60.332375"}{"text":"It may be that this capability should be added .For instance , the allomorphy rule given in example ( 6 ) and repeated here seems to require this power : .( 7 ) -fy -fic / _ _ -Ation .","label":"Background","metadata":{},"score":"60.332375"}{"text":"For instance , an affix which belongs to a particular order , say order 3 , might bear the feature [ 3 order ] , and require that the stem to which it attaches bear the feature [ 2 order].","label":"Background","metadata":{},"score":"60.408947"}{"text":"For instance , an affix which belongs to a particular order , say order 3 , might bear the feature [ 3 order ] , and require that the stem to which it attaches bear the feature [ 2 order].","label":"Background","metadata":{},"score":"60.408947"}{"text":"Chapter 6 ( pp .223 - 274 ) by Kathol considers the problems of agreement in languages with richer morphology than English .Chapter 7 ( pp .275 - 332 ) by Hinrichs and Nakazawa presents an analysis of partial VP and split NP topicalisation in German .","label":"Background","metadata":{},"score":"60.510406"}{"text":"The algorithm is invoked with a . framing context and subject i d i d .Find embed from . map of embeds for i d .Let parent and property be from embed .If parent is an array , replace the .","label":"Background","metadata":{},"score":"60.574814"}{"text":"REFERENCES Calcagno , Mike and Carl Pollard ( 1995 ) Lexical Rules in HPSG : What are they ?Manuscript , Ohio State University , Columbus , Ohio , USA .Earley , Jay ( 1970 )An efficient Context - free Parsing Algorithm .","label":"Background","metadata":{},"score":"60.95037"}{"text":"The former is roughly the position of Lieber ( 1980 ) and of Di Sciullo and Williams ( 1987 ) , while the latter is the position of Matthews ( 1972a ) and Matthews ( 1972b ) , if his work is interpreted as Item - and - Arrangement .","label":"Background","metadata":{},"score":"61.012768"}{"text":"The former is roughly the position of Lieber ( 1980 ) and of Di Sciullo and Williams ( 1987 ) , while the latter is the position of Matthews ( 1972a ) and Matthews ( 1972b ) , if his work is interpreted as Item - and - Arrangement .","label":"Background","metadata":{},"score":"61.012768"}{"text":"Second point : when I contend that English stress is lexical in nature , I am not obliged to admit that EVERY logical possibility must be allowed .Greek only allows stress on the last three syllables of a word , but within that span it is lexical .","label":"Background","metadata":{},"score":"61.04175"}{"text":"If element has a single item , the compacted value is that item ; otherwise the compacted value is element .Otherwise , if the active property has a @container mapping to @list and element has a corresponding @list property , recursively compact that property 's value passing a copy of the active context and the active property ensuring that the result is an array and removing null values .","label":"Background","metadata":{},"score":"61.224983"}{"text":"Cambridge , Cambridge University Press .Pollard , C. and I. Sag ( 1987 ) .Information - Based Syntax and Semantics .Stanford , California , Center for the Study of Language and Information , Stanford University .Pollard , C. and I. Sag ( 1994 ) .","label":"Background","metadata":{},"score":"61.256363"}{"text":"Cambridge , Cambridge University Press .Pollard , C. and I. Sag ( 1987 ) .Information - Based Syntax and Semantics .Stanford , California , Center for the Study of Language and Information , Stanford University .Pollard , C. and I. Sag ( 1994 ) .","label":"Background","metadata":{},"score":"61.256363"}{"text":"In AMPLE , such an affix might be specified to have a large number of part of speech pairs : one for each subcategory of verb ( intransitive , transitive , ditransitive , citative , particle - taking verbs , etc . ) .","label":"Background","metadata":{},"score":"61.275383"}{"text":"In AMPLE , such an affix might be specified to have a large number of part of speech pairs : one for each subcategory of verb ( intransitive , transitive , ditransitive , citative , particle - taking verbs , etc . ) .","label":"Background","metadata":{},"score":"61.275383"}{"text":"Oxford : Oxford University Press .Halle , Morris ; and Alec Marantz . \"Distributed Morphology and the Pieces of Inflection . \"Pg . 111 - 176 in The View from Building 20 , edited by Kenneth Hale and Sylvain Bromberger .","label":"Background","metadata":{},"score":"61.439735"}{"text":"Oxford : Oxford University Press .Halle , Morris ; and Alec Marantz . \"Distributed Morphology and the Pieces of Inflection . \"Pg . 111 - 176 in The View from Building 20 , edited by Kenneth Hale and Sylvain Bromberger .","label":"Background","metadata":{},"score":"61.439735"}{"text":"Examples may contain references to existing vocabularies and use prefix es to refer to vocabularies .The following is a list of all vocabularies and their prefix abbreviations , as used in this document : .JSON [ RFC4627 ] defines several terms which are used throughout this document : .","label":"Background","metadata":{},"score":"61.45625"}{"text":"I do n't know whether anyone has brought this up before , but since I have n't come across it , I thought I might as well jot it down here ... .People have often wondered about the biological function of the kind of deep , lasting grief that accompanies events such as the loss of a child .","label":"Background","metadata":{},"score":"61.474556"}{"text":"Otherwise , if active property is the target of typed literal coercion , expand value into an object with key - value pairs .The first key - value pair will be @value and the unexpanded value .The second key - value pair will be @type and the associated coercion datatype expanded according to the IRI Expansion rules .","label":"Background","metadata":{},"score":"61.538612"}{"text":"The first key - value pair will be @value and the unexpanded value .The second key - value pair will be @language and value of the language tagging from the active context .3.7 Value Compaction .Some values , such as IRIs and typed literals , may be expressed in an expanded form in JSON - LD .","label":"Background","metadata":{},"score":"61.561035"}{"text":"V [ -consonantal + syllabic ] .C [ + consonantal -syllabic ] .As stated , this infixation rule would not apply to a stem which did not begin with a consonant plus a vowel .In some languages , if the stem is not parsable in such a way , the affix would instead apply as an prefix .","label":"Background","metadata":{},"score":"61.569145"}{"text":"V [ -consonantal + syllabic ] .C [ + consonantal -syllabic ] .As stated , this infixation rule would not apply to a stem which did not begin with a consonant plus a vowel .In some languages , if the stem is not parsable in such a way , the affix would instead apply as an prefix .","label":"Background","metadata":{},"score":"61.569145"}{"text":"223 - 274 ) by Kathol considers the problems of agreement in languages with richer morphology than English .Chapter 7 ( pp .275 - 332 ) by Hinrichs and Nakazawa presents an analysis of partial VP and split NP topicalisation in German .","label":"Background","metadata":{},"score":"61.591934"}{"text":"LiteralNodes represent values such as numbers , dates and strings in RDF data .A LiteralNode is comprised of three attributes : .LiteralNodes representing plain text in a natural language may have a language attribute specified by a text string token , as specified in [ BCP47 ] , normalized to lowercase ( e.g. , ' en ' , ' fr ' , ' en - gb ' ) .","label":"Background","metadata":{},"score":"61.657112"}{"text":"It was determined that this added too much complexity , but the issue can be re - examined in the future based on community input .3.5 IRI Compaction .Some keys and values are expressed using IRI s. This section defines an algorithm for transforming an IRI ( iri ) to a term or compact IRI using the term s specified in the active context using an optional value .","label":"Background","metadata":{},"score":"61.758957"}{"text":"Add output to parent .If parent is an array , append output , otherwise append output to active property in parent .At the completion of the recursive algorithm , results will contain the top - level subject definition s. .","label":"Background","metadata":{},"score":"62.095"}{"text":"BlankNode s nominalValues will often be generated differently by different processors .Implementers must ensure that BlankNode nominalValues are unique within the current environment , two BlankNode s are considered equal if , and only if , their nominalValues are strictly equal .","label":"Background","metadata":{},"score":"62.1445"}{"text":"Get values for embedOn and explicitOn by looking in frame for the keys @embed and @explicit using the current values for . object embed flag and .explicit inclusion flag from state if not found .For each i d and subject from the set of matched subjects , ordered by i d : .","label":"Background","metadata":{},"score":"62.20063"}{"text":"If , after replacement , an array contains only the value . null remove the value , leaving an empty array .The resulting value is the final .JSON - LD output .Remove Embedded Definition .This algorithm replaces an already embedded .","label":"Background","metadata":{},"score":"62.29249"}{"text":"( This means that the publisher has sent us a review copy . )Then contact Simin Karimi at simin linguistlist.org or Terry Langendoen at terry linguistlist.org .Directory .Studies in Contemporary Phrase Structure Grammar .Levine , Robert D. , and Georgia M. Green , Eds .","label":"Background","metadata":{},"score":"62.337006"}{"text":"An . object expressed as a value such as a string , number or in expanded form .The # json - ld IRC channel is available for real - time discussion on irc.freenode.net .The Application Programming Interface .This API provides a clean mechanism that enables developers to convert JSON - LD data into a a variety of output formats that are easier to work with in various programming languages .","label":"Background","metadata":{},"score":"62.377174"}{"text":"If value is not null , either merge value into an existing property property of element or create a new property property with value as value .If the processed element has an @value property .element must not have more than one other property , which can either be @language or @type with a string value . if @value is the only property or the value of @value equals null , replace element with the value of @value .","label":"Background","metadata":{},"score":"62.52851"}{"text":"RDF - CONCEPTS]].named graph .A . linked data graph that is identified by an .IRI . graph name .The .IRI identifying a .named graph . default graph .When executing an algorithm , the graph where data should be placed if a .","label":"Background","metadata":{},"score":"62.58458"}{"text":"node reference .If parent is a .JSON object , replace the .node definition for property that matches i d with a .node reference .Remove dependents for i d in . map of embeds by scanning the map for entries with parent that have an @id of i d , removing that definition from the map , and then removing the dependents for the parent i d recursively by repeating this step .","label":"Background","metadata":{},"score":"62.72162"}{"text":"If element has an @set or @list property , it must be the only property .Set element to the value of @set ; leave @list untouched .If , after the algorithm outlined above is run , the resulting element is an JSON object with just a @graph property , element is set to the value of @graph 's value .","label":"Background","metadata":{},"score":"63.006336"}{"text":"As the problematic cases go mainly into building recursion , a transformation scheme , called ' Building recursion reversal ' ( BRR ) is suggested .This mechanism is intended to transform a non - terminate grammar into its terminate semantically equivalent grammar , more precisely -- into a peeling argument sequence , and then the problem with the recursion is solved .","label":"Background","metadata":{},"score":"63.066853"}{"text":"Kiril Simov is researcher in Computer Science .His scientific interests are in computational Linguistics , constraint - based formalisms and logics , knowledge representation and Ontologies .Abstract .JSON [RFC4627 ] has proven to be a highly useful object serialization and messaging format .","label":"Background","metadata":{},"score":"63.24646"}{"text":"A .JSON object used to reference a node having only the @id key .blank node .A .node in the .linked data graph that does not contain a de - referenceable identifier because it is either ephemeral in nature or does not contain information that needs to be linked to from outside of the linked data graph .","label":"Background","metadata":{},"score":"63.422176"}{"text":"RDF Conversion .A JSON - LD document may be converted between other RDF - compatible document formats using the algorithms specified in this section .The JSON - LD Processing Model describes processing rules for extracting RDF from a JSON - LD document , and for transforming an array of Statement retrieved by processing another serialization format into JSON - LD .","label":"Background","metadata":{},"score":"63.562263"}{"text":"The Subjective ( Agentive ) nominalization , e.g. bake : baker , is a familiar L - derivation .It invokes three of the four L - derivation types , a functional derivation illustrated in ( 1 - 3 ) , a transposition , whose output is ( 3 ) , and a featural switch , whose output is illustrated in ( 4 ) below : .","label":"Background","metadata":{},"score":"63.56556"}{"text":"The first key - value pair will be @value and the string representation of value as defined in the section Data Round Tripping .The second key - value pair will be @type and the associated coercion datatype expanded according to the IRI Expansion rules .","label":"Background","metadata":{},"score":"63.614166"}{"text":"The terms \" Item - and - Arrangement \" ( IA ) morphology and \" Item - and - Process \" ( IP ) morphology cover two distinctions which are sometimes confused .In the first usage , the question is whether affixes are to be treated as lexical items , on a par with roots and other \" listemes , \" or whether affixes should be treated as rules ( processes ) .","label":"Background","metadata":{},"score":"63.62095"}{"text":"The terms \" Item - and - Arrangement \" ( IA ) morphology and \" Item - and - Process \" ( IP ) morphology cover two distinctions which are sometimes confused .In the first usage , the question is whether affixes are to be treated as lexical items , on a par with roots and other \" listemes , \" or whether affixes should be treated as rules ( processes ) .","label":"Background","metadata":{},"score":"63.62095"}{"text":"The compaction result MUST use the @graph keyword at the top - level , even if the context is empty or if there is only one element to put in the @graph array .Subsequently , replace all key - value pairs where the key is @preserve with the value from the key - pair .","label":"Background","metadata":{},"score":"63.69103"}{"text":"Two dynamic control strategies are presented and compared : semi - naive magic control and Earley control .Then the author proposes a ' selective magic HPSG parser ' which combines the bottom - up processing and top - down control .","label":"Background","metadata":{},"score":"63.773293"}{"text":"If explicitOn is . false , Embed values from subject in output using subject as element and property as active property .Continue to next property .If item is a .JSON object with the key @list , then create a .","label":"Background","metadata":{},"score":"63.85599"}{"text":"IRI referencing the JSON - LD document to frame . object or IRI frame .The frame to use when re - arranging the data of input ; either in the form of an .JSON object or as .IRI .","label":"Background","metadata":{},"score":"63.893555"}{"text":"This rule is at least more plausible ( there are no instances of /y/ before a consonant in Tzeltal , while there are numerous words containing /s/ followed by a vowel ) ; but again , it is not clear how to effect the change .","label":"Background","metadata":{},"score":"63.936237"}{"text":"This rule is at least more plausible ( there are no instances of /y/ before a consonant in Tzeltal , while there are numerous words containing /s/ followed by a vowel ) ; but again , it is not clear how to effect the change .","label":"Background","metadata":{},"score":"63.936237"}{"text":"A relative IRI is an IRI that is relative some other absolute IRI ; in the case of JSON - LD this is the base location of the document .The algorithm for generating an IRI is : .If the active context contains a term mapping for the value using a case - sensitive comparison , use the mapped value as an IRI .","label":"Background","metadata":{},"score":"63.93637"}{"text":"For concreteness , consider the attachment of the English inflectional suffix -s to a plural noun .In IP morphology , this might be expressed by the following rule : .That is , the rule of -s inflection simply attaches the phoneme s to the end of whatever phonological material the noun consists of , here represented by the variable X .","label":"Background","metadata":{},"score":"64.13009"}{"text":"For concreteness , consider the attachment of the English inflectional suffix -s to a plural noun .In IP morphology , this might be expressed by the following rule : .That is , the rule of -s inflection simply attaches the phoneme s to the end of whatever phonological material the noun consists of , here represented by the variable X .","label":"Background","metadata":{},"score":"64.13009"}{"text":"[ 13 ] These two parts of the feature percolation convention are supplied in Hermit Crab morphological rules by two fields , the required features and ( head ) features fields .The required features must unify with the stem 's features , while the head features are added to the stem 's features to become those of the resulting word ( with affixal features overriding any conflicting feature values of the stem ) .","label":"Background","metadata":{},"score":"64.14131"}{"text":"[ 13 ] These two parts of the feature percolation convention are supplied in Hermit Crab morphological rules by two fields , the required features and ( head ) features fields .The required features must unify with the stem 's features , while the head features are added to the stem 's features to become those of the resulting word ( with affixal features overriding any conflicting feature values of the stem ) .","label":"Background","metadata":{},"score":"64.14131"}{"text":"Set the value of property in output to a new .JSON object with a property @preserve and a value that is a copy of the value of @default in frame if it exists , or the string @null otherwise .Add output to parent .","label":"Background","metadata":{},"score":"64.160835"}{"text":"If property is @list and any entry in value is a JSON object containing an @list property , throw an exception , as lists of lists are not supported .If property is not a keyword and active property has a @container @list and the expanded value is not null , convert value to an object with an @list property whose value is set to value ( unless value is already in that form ) .","label":"Background","metadata":{},"score":"64.184364"}{"text":"As with lexical items which represent stems ( see section 2.7 above ) , there is no direct translation of this property into Hermit Crab 's model .Filtering out affixes which are not to be loaded is the job of the user interface .","label":"Background","metadata":{},"score":"64.20542"}{"text":"As with lexical items which represent stems ( see section 2.7 above ) , there is no direct translation of this property into Hermit Crab 's model .Filtering out affixes which are not to be loaded is the job of the user interface .","label":"Background","metadata":{},"score":"64.20542"}{"text":"The following is an explanation of the general terminology used in this document : .JSON object .An object structure is represented as a pair of curly brackets surrounding zero or more name - value pairs .A name is a . string .","label":"Background","metadata":{},"score":"64.21006"}{"text":"Ad Wojcik : It is important to remember that Ulaszyn , the Leningrad phonologists , and the American structuralists of the 1930 's ( but not earlier ! ! ) all agreed in placing the phonemic level exactly where Halle found it -- and found it wanting , that is , AFTER all neutralizing rules and before all allophonic ones .","label":"Background","metadata":{},"score":"64.21327"}{"text":"Initialize highest rank to 0 , and set a flag list container to false .If value is a JSON object containing only the property @list and list container is false and term has a container set to @list , then set list container to true , clear terms , set highest rank to rank , and add term to terms .","label":"Background","metadata":{},"score":"64.424515"}{"text":"A . term is a short word defined in a context that MAY be expanded to an .IRI . prefix .A . prefix is a . term that expands to a vocabulary base IRI .It is typically used along with a suffix to form a . compact IRI to create an IRI within a vocabulary .","label":"Background","metadata":{},"score":"64.51385"}{"text":"A set of documents , each containing a representation of a .linked data graph .linked data graph or . dataset .An unordered labeled directed graph , where .nodes are .IRIs or .Blank Nodes , or other values .","label":"Background","metadata":{},"score":"64.57737"}{"text":"But I 'd deny that Halle & Chomsky just failed to be explicit about this relevance of kind of evidence - I see no evidence that they saw any need for it at all .And the resulting confusion tends to cast discredit on the entire field .","label":"Background","metadata":{},"score":"64.68106"}{"text":"The algorithm should descend into @graph and create a parallel flattened structure of subject to object within that @graph representation .Recursive @graph definitions are also flattened into the default graph .The algorithm should also take an option which descends into @graph and flattens all definitions at the same level , effectively flatting default and named graphs into a single default graph ; this should be the default implementation for 1.0 .","label":"Background","metadata":{},"score":"64.74159"}{"text":"[Flickinger et al . 2000].This collection of articles can be regarded as a representative reflection of the process of continuous rethinking that the theory has undergone since the appearance of [ Pollard and Sag 1994].The book is organised as follows .","label":"Background","metadata":{},"score":"65.204056"}{"text":"For example , the MEC . is equivalent to the AMPLE test .FOR_SOME_RIGHT RIGHT property is FUT .( i.e. ( x FUT(x ) ) , ignoring the directionality ) ; and the MEC . is equivalent to the AMPLE test .","label":"Background","metadata":{},"score":"65.33663"}{"text":"For example , the MEC . is equivalent to the AMPLE test .FOR_SOME_RIGHT RIGHT property is FUT .( i.e. ( x FUT(x ) ) , ignoring the directionality ) ; and the MEC . is equivalent to the AMPLE test .","label":"Background","metadata":{},"score":"65.33663"}{"text":"IANA Considerations .This section is included merely for standards community review and will be submitted to the Internet Engineering Steering Group if this specification becomes a W3C Recommendation . application / ld - frame+json . application .Subtype name : . ld - frame+json .","label":"Background","metadata":{},"score":"65.3748"}{"text":"JsonLdProcessor .The JSON - LD processor interface is the high - level programming structure that developers use to access the JSON - LD transformation methods .The definition below is an experimental extension of the interface defined in the [ [ JSON - LD - API]]. void frame ( ) .","label":"Background","metadata":{},"score":"65.50812"}{"text":"The work of Dave Lehn and Mike Johnson are appreciated for reviewing , and performing several implementations of the specification .Ian Davis is thanked for this work on RDF / JSON .Editor 's note : This paper was originally presented at SIL 's General CARLA Conference , 14 - 15 November 1996 , Waxhaw , NC .","label":"Background","metadata":{},"score":"65.702805"}{"text":"A crucial theoretical role is played by the type hierarchy which assigns them to appropriate ontological statuses bearing on their grammatical behaviour .Johnston identifies three separate interpretations of English \" for \" PP adjuncts , namely , \" recipient \" , \" benefactive \" , and \" acquire \" .","label":"Background","metadata":{},"score":"65.76091"}{"text":"A crucial theoretical role is played by the type hierarchy which assigns them to appropriate ontological statuses bearing on their grammatical behaviour .Johnston identifies three separate interpretations of English \" for \" PP adjuncts , namely , \" recipient \" , \" benefactive \" , and \" acquire \" .","label":"Background","metadata":{},"score":"65.76091"}{"text":"Otherwise , if value is a string , it represents a string value with no @language .If term has @language null , or term has no @type or @language and the active context has no @language , term rank is 3 , otherwise 0 .","label":"Background","metadata":{},"score":"65.82298"}{"text":"Translating Bloch 's analysis into an AMPLE analysis , we would say that there is a zero allomorph of the past tense which bears an allomorph property , say causes_ablaut , while the morpheme take has a morpheme property ablautable , and an allomorph took with allomorph property ablauted .","label":"Background","metadata":{},"score":"65.92269"}{"text":"Translating Bloch 's analysis into an AMPLE analysis , we would say that there is a zero allomorph of the past tense which bears an allomorph property , say causes_ablaut , while the morpheme take has a morpheme property ablautable , and an allomorph took with allomorph property ablauted .","label":"Background","metadata":{},"score":"65.92269"}{"text":"At this point , Hermit Crab 's allomorphy rules do not have the capability of referring to the features ( or glosses ) of adjacent morphemes , but this could easily be added .In addition to conditions on the appearance of an allomorph , AMPLE can assign Allomorph Properties to individual allomorphs ( as opposed to the morpheme properties , which are assigned to all allomorphs of a given morpheme ) .","label":"Background","metadata":{},"score":"65.97153"}{"text":"At this point , Hermit Crab 's allomorphy rules do not have the capability of referring to the features ( or glosses ) of adjacent morphemes , but this could easily be added .In addition to conditions on the appearance of an allomorph , AMPLE can assign Allomorph Properties to individual allomorphs ( as opposed to the morpheme properties , which are assigned to all allomorphs of a given morpheme ) .","label":"Background","metadata":{},"score":"65.97153"}{"text":"Set property frame to the first item in value or a newly created JSON object if value is empty .Skip to the next property in frame if property is in output or if property frame contains @omitDefault which is true or if it does not contain @omitDefault but the value of omit default flag true .","label":"Background","metadata":{},"score":"65.97655"}{"text":"For each statement in input : .If property is rdf : first , create a new entry in listMap with for name and subject and an array value containing object representation and skip to the next statement .If property is rdf : rest , and object is a BlankNode , create a new entry in restMap to map name and subject to a value being the result of IRI expansion on object and skip to the next statement .","label":"Background","metadata":{},"score":"66.03264"}{"text":"active property in parent otherwise .Otherwise : .Process each property and value in the matched subject , ordered by property : .If property is a .keyword , add property and a copy of value to output and continue with the next property from subject .","label":"Background","metadata":{},"score":"66.166115"}{"text":"node definition 's @id in their parent chain .Embed Values .This algorithm recursively embeds property values in .node definition output , given a . framing context , input .node definition element , . active property , and output .","label":"Background","metadata":{},"score":"66.17079"}{"text":"If existing has a parent which is an .array containing a .JSON object with @id equal to i d , element has already been embedded and can be overwritten , so set embedOn to . true .Otherwise , existing has a parent which is a .","label":"Background","metadata":{},"score":"66.18579"}{"text":"Then contact Simin Karimi at simin linguistlist.org or Terry Langendoen at terry linguistlist.org .Directory .Studies in Contemporary Phrase Structure Grammar .Levine , Robert D. , and Georgia M. Green , Eds .( 1999 ) Studies in Contemporary Phrase Structure Grammar , Cambridge University Press , 335 pages .","label":"Background","metadata":{},"score":"66.31478"}{"text":"If the prefix is a ' _ ' ( underscore ) , the value represents a named blank node .Note that an empty suffix and no suffix ( meaning the value contains no ' : ' string at all ) are treated equivalently .","label":"Background","metadata":{},"score":"66.35299"}{"text":"The Separation Hypothesis splits all derivation , lexical and inflectional alike , into three processes : lexical ( L- ) derivation , inflectional ( I- ) derivation , and morphological spelling .Derivation involves operations on abstract lexical and inflectional category functions such as [ + Plural , -Singular ] , [ + Past , -Present ] , [ +1st ] , and the like .","label":"Background","metadata":{},"score":"66.36992"}{"text":"Create a new JSON object containing @list and an array created by performing this algorithm recursively on each item in the list and add to subject along with property .Otherwise , value must be an array .Add property to subject and an array value created by performing this algorithm recursively on each item in the array .","label":"Background","metadata":{},"score":"66.48818"}{"text":"active property of element : .If item is a .JSON object with the key @list , then create a new .JSON object with a key @list and a value of an empty array and add it to output , appending if output is an array , and appending to .","label":"Background","metadata":{},"score":"66.56944"}{"text":"Set embedOn to . true if any of the items in parent property is a .node definition or .node reference for i d because the embed can be overwritten .If embedOn is . false , add output to parent by either appending to parent if it is an .","label":"Background","metadata":{},"score":"66.61096"}{"text":"An object structure is represented as a pair of curly brackets surrounding zero or more name / value pairs ( or members ) .A name is a string .A single colon comes after each name , separating the name from the value .","label":"Background","metadata":{},"score":"66.86926"}{"text":"The selection can then be based , partly , on the term having the highest term rank .Otherwise , if value is a JSON object containing only the property @list : .If the @list property is an empty array , if term has @container set to @list , term rank is 1 , otherwise 0 .","label":"Background","metadata":{},"score":"66.940094"}{"text":"The variable next identifier is initialized to prefix appended with 0 .If the old identifier is not null and is in identifier map return the mapped identifier .Otherwise , if old identifier is not null , create a new entry in identifier map initialized to the current value of next identifier .","label":"Background","metadata":{},"score":"67.00046"}{"text":"The suffix itself , represented by the string ut in the above example , is translated internally from such a string representation into a sequence of feature bundles .It is also possible to represent all or part of the suffix as a feature bundle externally .","label":"Background","metadata":{},"score":"67.014435"}{"text":"The suffix itself , represented by the string ut in the above example , is translated internally from such a string representation into a sequence of feature bundles .It is also possible to represent all or part of the suffix as a feature bundle externally .","label":"Background","metadata":{},"score":"67.014435"}{"text":"Inflectional Morphology : A Theoretical Study Based on Aspects of Latin Verb Conjugation .Cambridge Studies in Linguistics 6 .Cambridge : Cambridge University Press .Matthews , P.H. 1972b . \"Huave verb morphology : some comments from a non - tagmemic viewpoint .","label":"Background","metadata":{},"score":"67.05966"}{"text":"Inflectional Morphology : A Theoretical Study Based on Aspects of Latin Verb Conjugation .Cambridge Studies in Linguistics 6 .Cambridge : Cambridge University Press .Matthews , P.H. 1972b . \"Huave verb morphology : some comments from a non - tagmemic viewpoint .","label":"Background","metadata":{},"score":"67.05966"}{"text":"[ 24 ] .Hermit Crab has rough equivalents to these two tests ( or their equivalent MECs ) , in that an affix can require that the stem to which it is attached bear a particular feature value or not bear a feature value .","label":"Background","metadata":{},"score":"67.17833"}{"text":"[ 24 ] .Hermit Crab has rough equivalents to these two tests ( or their equivalent MECs ) , in that an affix can require that the stem to which it is attached bear a particular feature value or not bear a feature value .","label":"Background","metadata":{},"score":"67.17833"}{"text":"node .A piece of information that is represented in a .linked data graph .node definition .A .JSON object used to represent a .node and one or more properties of that node .A .JSON object is a node definition if it does not contain the keys @value , @list or @set and it has one or more keys other than @id .","label":"Background","metadata":{},"score":"67.17985"}{"text":"Recursively call this algorithm passing item as element , @list as .active property , and the new array as output .Continue to the next item .If item is a .node reference : .If . map of embeds does not contain an entry for the @id of item : .","label":"Background","metadata":{},"score":"67.49441"}{"text":"The canonical lexical representation of an integer , i.e. , a number without fractions or a number coerced to xsd : integer , is a finite - length sequence of decimal digits ( 0 - 9 ) with an optional leading minus sign ; leading zeroes are prohibited .","label":"Background","metadata":{},"score":"67.95752"}{"text":"A single comma separates a value from a following name .The names within an object SHOULD be unique . array .An array is represented as square brackets surrounding zero or more values that are separated by commas . string .","label":"Background","metadata":{},"score":"67.9704"}{"text":"It consists of two chapters ( 6 and 7 ) .The structure follows the section types of Part I : each chapter starts with a motivation section and concludes with a related work section and a summary section .Chapter 6 , \" Lexical Rules as Systematic Covariation in Lexical Entries \" , proposes a new computational treatment of lexical rules in HPSG .","label":"Background","metadata":{},"score":"68.01431"}{"text":"Chapter 4 ( pp .161 - 198 ) by Baker looks at \" modal flip \" and partial verb phrase fronting in German .Chapter 5 ( pp .199 - 222 ) by Fukushima presents Japanese syntactic topicalisation from a lexicalist perspective .","label":"Background","metadata":{},"score":"68.09483"}{"text":"There is no plausible sequence of phonological rules in English that would result in the epenthesis of n before vowels , or in the deletion of n before consonants ; rather , the alternation between n and zero is confined to this particular morpheme .","label":"Background","metadata":{},"score":"68.12067"}{"text":"There is no plausible sequence of phonological rules in English that would result in the epenthesis of n before vowels , or in the deletion of n before consonants ; rather , the alternation between n and zero is confined to this particular morpheme .","label":"Background","metadata":{},"score":"68.12067"}{"text":"[26 ] .Similar to the above test would be a requirement in Hermit Crab that a stem not bear any value for a given feature ( implemented using a designated null feature value ) , corresponding roughly to the AMPLE requirement that no morpheme bear a particular property .","label":"Background","metadata":{},"score":"68.25324"}{"text":"[26 ] .Similar to the above test would be a requirement in Hermit Crab that a stem not bear any value for a given feature ( implemented using a designated null feature value ) , corresponding roughly to the AMPLE requirement that no morpheme bear a particular property .","label":"Background","metadata":{},"score":"68.25324"}{"text":"Issue 43 concerns performing IRI expansion in the key position of a context definition .3.4 IRI Expansion .Keys and some values are evaluated to produce an IRI .This section defines an algorithm for transforming a value representing an IRI into an actual IRI .","label":"Background","metadata":{},"score":"68.38482"}{"text":"An Internationalized Resource Identifier ( IRI ) , as described in [ RFC3987 ] , is a mechanism for representing unique identifiers on the web .In Linked Data , an IRI is commonly used for expressing a subject , a property or an object .","label":"Background","metadata":{},"score":"68.57413"}{"text":"While this is a possible analysis of strong verbs , it is perhaps not the most perspicuous analysis , in part because of its reliance on zero morphemes .In Hermit Crab , two other analyses are available .Without going into details , the first is an IP analysis in which a subrule of the morphological rule for past tense ablauts the stem vowels and assigns a morphosyntactic feature such as [ past tense]. 2.3 Categories .","label":"Background","metadata":{},"score":"68.808975"}{"text":"While this is a possible analysis of strong verbs , it is perhaps not the most perspicuous analysis , in part because of its reliance on zero morphemes .In Hermit Crab , two other analyses are available .Without going into details , the first is an IP analysis in which a subrule of the morphological rule for past tense ablauts the stem vowels and assigns a morphosyntactic feature such as [ past tense]. 2.3 Categories .","label":"Background","metadata":{},"score":"68.808975"}{"text":"A .node in a .linked data graph with at least one outgoing edge , related to an . object node through a . property . quad .A piece of information that contains four items ; a . subject , a . property , an . object , and a . graph name .","label":"Background","metadata":{},"score":"69.06976"}{"text":"The . active context is the context contained within the .processor state . compact IRI . a compact IRI is has the form of . prefix and suffix and is used as a way of expressing an IRI without needing to define separate . term definitions for each IRI contained within a common vocabulary identified by . prefix .","label":"Background","metadata":{},"score":"69.4081"}{"text":"Pass the first value from frame for property as frame , list as parent , and @list as .active property .Otherwise , append a copy of listitem to @list in list .If item is a .node reference process item recursively using this algorithm passing a new map as subjects that contains the @id of item as the key and the .","label":"Background","metadata":{},"score":"69.47502"}{"text":"Meanwhile our friend \" canister \" was apparently of older origins and derived from the ultimate Latin from which \" canastra \" was also derived .Where simplicity arguments are convincing is where there is n't some alternative explanation to that offered by synchronic mental structure ( at what is essentially Christopher Peacocke 's ' level 1.5 ' ( Language and Mind , 1986 ) ) .","label":"Background","metadata":{},"score":"70.025116"}{"text":"This is because the basic data model of JSON - LD is a linked data graph , which is inherently unordered . string .A string is a sequence of zero or more Unicode characters , wrapped in double quotes , using backslash escapes .","label":"Background","metadata":{},"score":"70.18092"}{"text":"This same capacity allows the MS component to reorder affixes , such as in Turkish gelir - ler - se and gelir - se - ler both of which mean ' if they come ' .Let us imagine the inflectional realization of the input to baker illustrated in ( 5 ) .","label":"Background","metadata":{},"score":"70.21752"}{"text":"As in the case of stem categories , the translation can be made trivially , by translating a single AMPLE affix into multiple Hermit Crab affix rules , one for each category pair .However , the result is liable to be very messy if the affix attaches to multiple categories .","label":"Background","metadata":{},"score":"70.40625"}{"text":"As in the case of stem categories , the translation can be made trivially , by translating a single AMPLE affix into multiple Hermit Crab affix rules , one for each category pair .However , the result is liable to be very messy if the affix attaches to multiple categories .","label":"Background","metadata":{},"score":"70.40625"}{"text":"Subtractive ( truncation ) affixes present an even worse problem of distinguishing stem from affix ; fortunately , subtractive affixes are rare almost to the point of nonexistence .Simulfixes also cause problems in the application of allomorphy rules .Consider the morphological process which applies to some stop - initial stems in Mezquital Otomi ( Wallis 1956 ) by voicing the initial stop ; the following rule might be used to express this process : .","label":"Background","metadata":{},"score":"70.43273"}{"text":"Subtractive ( truncation ) affixes present an even worse problem of distinguishing stem from affix ; fortunately , subtractive affixes are rare almost to the point of nonexistence .Simulfixes also cause problems in the application of allomorphy rules .Consider the morphological process which applies to some stop - initial stems in Mezquital Otomi ( Wallis 1956 ) by voicing the initial stop ; the following rule might be used to express this process : .","label":"Background","metadata":{},"score":"70.43273"}{"text":"Thus , inflectional affixes do not bear a feature for conjugation class , they only check it .The check is easily implemented in Hermit Crab as a required feature constraint on the affixes affected .29 Note that under cyclic application , an allomorphy rule may apply to an affix on a cycle later than that on which the affix is attached .","label":"Background","metadata":{},"score":"71.24596"}{"text":"Thus , inflectional affixes do not bear a feature for conjugation class , they only check it .The check is easily implemented in Hermit Crab as a required feature constraint on the affixes affected .29 Note that under cyclic application , an allomorphy rule may apply to an affix on a cycle later than that on which the affix is attached .","label":"Background","metadata":{},"score":"71.24596"}{"text":"@explicit .Used in Framing to override the value of .explicit inclusion flag within a specific frame .@omitDefault .Used in Framing to override the value of . omit default flag within a specific frame .@embed .Used in Framing to override the value of . object embed flag within a specific frame .","label":"Background","metadata":{},"score":"71.43357"}{"text":"For instance , Halle and Marantz 's rule given above as ( 4 ) is inadequate as it stands , in that it will incorrectly apply to the verbs can ' to preserve by canning ' and will ' to deed over effective on one 's death . '","label":"Background","metadata":{},"score":"71.48624"}{"text":"For instance , Halle and Marantz 's rule given above as ( 4 ) is inadequate as it stands , in that it will incorrectly apply to the verbs can ' to preserve by canning ' and will ' to deed over effective on one 's death . '","label":"Background","metadata":{},"score":"71.48624"}{"text":"If the value from the key - pair is @null , replace the value with null .If , after replacement , an array contains only the value null remove the value , leaving an empty array .The resulting value is the final JSON - LD output .","label":"Background","metadata":{},"score":"71.500305"}{"text":"If value has a @type property matching a @type coercion for term , term rank is 3 , otherwise if term has no @type coersion and no @language , term rank is 1 , otherwise 0 .Otherwise , if term has @type coerced to @id , term rank is 3 , otherwise if term has no @type coersion and no @language , term rank is 1 , otherwise 0 .","label":"Background","metadata":{},"score":"71.5144"}{"text":"Additionally , if we admit that words like Orchestra exist and are stressed as marked , then there is no reason to even want to analyze Industry and its ilk differently .That is , whatever rule gives orchestra its initial stress should also work for industry .","label":"Background","metadata":{},"score":"71.69369"}{"text":"processor state copied into a new .processor state when entering a new .JSON object .JSON - LD input .The JSON - LD data structure that is provided as input to the algorithm .JSON - LD output .","label":"Background","metadata":{},"score":"71.94231"}{"text":"a context that is specified within a .JSON object , specified via the @context . keyword .processor state .the .processor state , which includes the . active context , . active subject , and .active property .","label":"Background","metadata":{},"score":"72.032364"}{"text":"Append list to property in output .Process each listitem in the @list array as follows : .If listitem is a .node reference process listitem recursively using this algorithm passing a new map of subjects that contains the @id of listitem as the key and the .","label":"Background","metadata":{},"score":"72.34625"}{"text":"Then contact Simin Karimi at simin linguistlist.org or Terry Langendoen at terry linguistlist.org .You get 30 % off on Blackwells books , and free shipping and postage !Minnen , Guido ( 2001 )Efficient Processing with Constraint - Logic Grammars Using Grammar Compilation .","label":"Background","metadata":{},"score":"72.83267"}{"text":"23Adding a filter to Hermit Crab to block analyses in which the outermost part of speech is not a member of a specified set would be trivial .The use of Realizational Morphology would also be a way of ensuring completeness of affixation .","label":"Background","metadata":{},"score":"72.94714"}{"text":"23Adding a filter to Hermit Crab to block analyses in which the outermost part of speech is not a member of a specified set would be trivial .The use of Realizational Morphology would also be a way of ensuring completeness of affixation .","label":"Background","metadata":{},"score":"72.94714"}{"text":"If the value has a @container property , it 's value must be @list or @set .Merge the list mapping or set mapping into the local context using the lexical value of the property .If the value has a @language property but no @type property , the value of the @language property must be a string or null .","label":"Background","metadata":{},"score":"73.245186"}{"text":"Construct a JSON object listMap to map graph names and subjects to objects derived from statements having a property of rdf : first .Construct a JSON object restMap to map graph names and subjects to objects derived from statements having a property of rdf : rest .","label":"Background","metadata":{},"score":"73.885956"}{"text":"The following rule , for example , indicates that the first CV(V ) of the stem is reduplicated .[ C 1 V 2 ( V 3 ) X 4 ] V [ 1 2 3 1 2 3 4 ] V .","label":"Background","metadata":{},"score":"74.071754"}{"text":"The following rule , for example , indicates that the first CV(V ) of the stem is reduplicated .[ C 1 V 2 ( V 3 ) X 4 ] V [ 1 2 3 1 2 3 4 ] V .","label":"Background","metadata":{},"score":"74.071754"}{"text":"Negative string environment constraints , however , do not have a straightforward translation , and must be converted into a disjunction of environments .[ 15 ] .The translation of AMPLE 's Morpheme Environment Constraints ( MECs ) into a Hermit Crab structure is a more complex issue .","label":"Background","metadata":{},"score":"74.73715"}{"text":"Negative string environment constraints , however , do not have a straightforward translation , and must be converted into a disjunction of environments .[ 15 ] .The translation of AMPLE 's Morpheme Environment Constraints ( MECs ) into a Hermit Crab structure is a more complex issue .","label":"Background","metadata":{},"score":"74.73715"}{"text":"The names within an object should be unique . array .An array is an ordered collection of values .An array structure is represented as square brackets surrounding zero or more values ( or elements ) .Elements are separated by commas .","label":"Background","metadata":{},"score":"74.85544"}{"text":"Create a set of matched subjects by filtering subjects checking the . map of flattened subjects against frame : .If frame has a @type property containing one or more .IRIs match any .node definition with a @type property including any of those .","label":"Background","metadata":{},"score":"75.105225"}{"text":"JsonLdCallback .The JsonLdCallback is used to return a processed JSON - LD representation as the result of processing an API method .See .JsonLdCallback definition in [ [ !JSON - LD - API]].Data Structures .","label":"Background","metadata":{},"score":"75.13972"}{"text":"As far as I know , the only such words are derivates such as Admiralty .If this is a genuine generalization , then it is a constraint on the freedom of lexical stress , but not proof that English stress is predictable .","label":"Background","metadata":{},"score":"76.00319"}{"text":"A convention for specification of the features to be realized on a given word would need to be added to Hermit Crab . 15 A common use of negative string environment constraints is for phenomena which are dependent on position within a syllable .","label":"Background","metadata":{},"score":"76.10718"}{"text":"A convention for specification of the features to be realized on a given word would need to be added to Hermit Crab . 15 A common use of negative string environment constraints is for phenomena which are dependent on position within a syllable .","label":"Background","metadata":{},"score":"76.10718"}{"text":"To convert the number in JavaScript , implementers can use the following snippet of code : .( value ) .toExponential ( ) .replace(/e\\+ ?/,'E ' ) .xsd : double 's value space is defined by the IEEE double - precision 64-bit floating point type [ IEEE-754 - 1985 ] .","label":"Background","metadata":{},"score":"76.20035"}{"text":"Some JSON serializers , such as PHP 's native implementation in some versions , backslash - escape the forward slash character .This is problematic as other JSON parsers might not understand those escaping characters .There is no need to backslash - escape forward slashes in JSON - LD .","label":"Background","metadata":{},"score":"76.38502"}{"text":"( value ) .toFixed(0 ) .toString ( ) .The canonical lexical representation of a double , i.e. , a number with fractions or a number coerced to xsd : double , consists of a mantissa followed by the character \" E \" , followed by an exponent .","label":"Background","metadata":{},"score":"76.40641"}{"text":"Hermit Crab uses a designated null value for this purpose .In addition , rule features may be specified for such purposes as conjugation or declension classes ; their behavior is similar to that of morphosyntactic features .Hermit Crab also allows the use of phonological rules , making it possible to take an SUF view of morphology .","label":"Background","metadata":{},"score":"76.55238"}{"text":"Hermit Crab uses a designated null value for this purpose .In addition , rule features may be specified for such purposes as conjugation or declension classes ; their behavior is similar to that of morphosyntactic features .Hermit Crab also allows the use of phonological rules , making it possible to take an SUF view of morphology .","label":"Background","metadata":{},"score":"76.55238"}{"text":"Otherwise , recursively call this algorithm passing value as element , property as .active property and o as output .Set item to o .If output is an .array , append a copy of item , otherwise append a copy of item to .","label":"Background","metadata":{},"score":"77.499016"}{"text":"Like lexical entries which are not to be loaded , comments can be stored in the dictionary database maintained by the user interface , but not passed to Hermit Crab .As discussed above , AMPLE takes the IA perspective , and therefore considers affixes to be lexical entries ( items ) in dictionaries .","label":"Background","metadata":{},"score":"77.591415"}{"text":"Like lexical entries which are not to be loaded , comments can be stored in the dictionary database maintained by the user interface , but not passed to Hermit Crab .As discussed above , AMPLE takes the IA perspective , and therefore considers affixes to be lexical entries ( items ) in dictionaries .","label":"Background","metadata":{},"score":"77.591415"}{"text":"There are a number of ways that one may participate in the development of this specification : .The # json - ld IRC channel is available for real - time discussion on irc.freenode.net .The Application Programming Interface .This API provides a clean mechanism that enables developers to convert JSON - LD data into a a variety of output formats that are easier to work with in various programming languages .","label":"Background","metadata":{},"score":"77.59236"}{"text":"active property is . null , set the . map of embeds in state to an empty map .Initialize output with @id and i d .Initialize embed with parent and .active property to property .If embedOn is . true , and i d is in . map of embeds from state : .","label":"Background","metadata":{},"score":"77.8931"}{"text":"A negative inwardly sensitive constraint can be modeled in the same way , except that the designated feature value(s ) must be absent from the stem .A Morpheme Co - occurrence Constraint that works in the outward direction , that is where a morpheme sets up a requirement that an affix attached outside of the given affix must be present , is represented differently in Hermit Crab .","label":"Background","metadata":{},"score":"78.39883"}{"text":"A negative inwardly sensitive constraint can be modeled in the same way , except that the designated feature value(s ) must be absent from the stem .A Morpheme Co - occurrence Constraint that works in the outward direction , that is where a morpheme sets up a requirement that an affix attached outside of the given affix must be present , is represented differently in Hermit Crab .","label":"Background","metadata":{},"score":"78.39883"}{"text":"The exponent must be an integer .Leading zeroes and a preceding plus sign ( + ) are prohibited in the exponent .If the exponent is zero , it must be indicated by E0 .For the mantissa , the preceding optional plus sign is prohibited and the decimal point is required .","label":"Background","metadata":{},"score":"78.50571"}{"text":"This field is used by AMPLE only to define the beginning of a lexical entry record , and is therefore irrelevant to this comparison .( Lexical entry records in Hermit Crab are delineated by brackets in a manner which need not concern us here . )","label":"Background","metadata":{},"score":"79.71567"}{"text":"This field is used by AMPLE only to define the beginning of a lexical entry record , and is therefore irrelevant to this comparison .( Lexical entry records in Hermit Crab are delineated by brackets in a manner which need not concern us here . )","label":"Background","metadata":{},"score":"79.71567"}{"text":"The following two sections discuss morphological and phonological rules .Hermit Crab takes an Item - and - Process view of morphology .That is , affixes are treated internally as rules , rather than as lexical items .A very simple rule attaching a verbalizing suffix might be expressed as follows : .","label":"Background","metadata":{},"score":"79.926834"}{"text":"The following two sections discuss morphological and phonological rules .Hermit Crab takes an Item - and - Process view of morphology .That is , affixes are treated internally as rules , rather than as lexical items .A very simple rule attaching a verbalizing suffix might be expressed as follows : .","label":"Background","metadata":{},"score":"79.926834"}{"text":"Ad Hammond : There seems to be some confusion regarding my position on exception marking .I said that canAsta , KentUcky , and so on are not exceptions because they are neither perceived as foreign nor as forming an unproductive class .","label":"Background","metadata":{},"score":"80.017"}{"text":"27 More ( or perhaps less ) perspicuously , the following two AMPLE conditions have rough correlates in Hermit Crab ( abstracting away from left / right conditions ) : .( m X(m ) )( m ) ( X(m ) ) .","label":"Background","metadata":{},"score":"80.73587"}{"text":"27 More ( or perhaps less ) perspicuously , the following two AMPLE conditions have rough correlates in Hermit Crab ( abstracting away from left / right conditions ) : .( m X(m ) )( m ) ( X(m ) ) .","label":"Background","metadata":{},"score":"80.73587"}{"text":"Thus , instead of the long list of part of speech pairs required in AMPLE , in Hermit Crab the causative affix would have a single input part of speech requirement and effect a single change to the complement list of the output .","label":"Background","metadata":{},"score":"80.81771"}{"text":"Thus , instead of the long list of part of speech pairs required in AMPLE , in Hermit Crab the causative affix would have a single input part of speech requirement and effect a single change to the complement list of the output .","label":"Background","metadata":{},"score":"80.81771"}{"text":"A comparison of this behavior with that of features in Hermit Crab appears in section 2.5 above , and section 4 below .3.7 Morpheme Co - occurrence Constraints .AMPLE 's Morpheme Co - occurrence Constraints do not have any direct translation in Hermit Crab , although they can generally be represented by a different concept .","label":"Background","metadata":{},"score":"80.87242"}{"text":"A comparison of this behavior with that of features in Hermit Crab appears in section 2.5 above , and section 4 below .3.7 Morpheme Co - occurrence Constraints .AMPLE 's Morpheme Co - occurrence Constraints do not have any direct translation in Hermit Crab , although they can generally be represented by a different concept .","label":"Background","metadata":{},"score":"80.87242"}{"text":"There are no corresponding tests in Hermit Crab .[ 27 ] But again , it seems unlikely that these tests represent a correct view of what happens in natural language , so we may not be missing out on much by not allowing for such tests in Hermit Crab .","label":"Background","metadata":{},"score":"80.88336"}{"text":"There are no corresponding tests in Hermit Crab .[ 27 ] But again , it seems unlikely that these tests represent a correct view of what happens in natural language , so we may not be missing out on much by not allowing for such tests in Hermit Crab .","label":"Background","metadata":{},"score":"80.88336"}{"text":"Again , comments should be treated by the user interface , and not passed to Hermit Crab at all ( see section 2.8 above ) .In addition to assigning string constraints and morpheme constraints to allomorphs , AMPLE allows the user to set up more general tests to be applied to analyses ( WBM , chapter 13 ) .","label":"Background","metadata":{},"score":"81.05987"}{"text":"Again , comments should be treated by the user interface , and not passed to Hermit Crab at all ( see section 2.8 above ) .In addition to assigning string constraints and morpheme constraints to allomorphs , AMPLE allows the user to set up more general tests to be applied to analyses ( WBM , chapter 13 ) .","label":"Background","metadata":{},"score":"81.05987"}{"text":"Note that in Hermit Crab , it is possible for affix1 to be a suffix and affix2 a prefix ; what is relevant is not the linear ordering of the morphemes , as in AMPLE , but their hierarchical relationships .There is no corresponding notion of hierarchy in AMPLE .","label":"Background","metadata":{},"score":"81.207855"}{"text":"Note that in Hermit Crab , it is possible for affix1 to be a suffix and affix2 a prefix ; what is relevant is not the linear ordering of the morphemes , as in AMPLE , but their hierarchical relationships .There is no corresponding notion of hierarchy in AMPLE .","label":"Background","metadata":{},"score":"81.207855"}{"text":"If item is a JSON object with the key @list , then create a JSON object named list with the key @list and the value of an empty array .Append list to property in output .Process each listitem in the @list array as follows : .","label":"Background","metadata":{},"score":"81.4067"}{"text":"[ 18 ] That is , the alternation is treated in Hermit Crab as a phonological process affecting vowels , rather than as an alternation between named allomorphs .Putting this differently , Hermit Crab allows the linguist to make generalizations directly using phonological structure , rather than indirectly using names of allomorphs .","label":"Background","metadata":{},"score":"81.45328"}{"text":"[ 18 ] That is , the alternation is treated in Hermit Crab as a phonological process affecting vowels , rather than as an alternation between named allomorphs .Putting this differently , Hermit Crab allows the linguist to make generalizations directly using phonological structure , rather than indirectly using names of allomorphs .","label":"Background","metadata":{},"score":"81.45328"}{"text":"[ 25 ] However , while the intent of such a test in AMPLE is often close to the intent of the test in Hermit Crab , there are a number of asymmetries between percolation on the one hand , and left / right searches on the other .","label":"Background","metadata":{},"score":"81.70076"}{"text":"[ 25 ] However , while the intent of such a test in AMPLE is often close to the intent of the test in Hermit Crab , there are a number of asymmetries between percolation on the one hand , and left / right searches on the other .","label":"Background","metadata":{},"score":"81.70076"}{"text":"AMPLE 's string conditions are essentially equivalent to the phonetic environment conditions of allomorphy rules in Hermit Crab .There are , on the other hand , significant differences between the treatment of Morpheme Properties in AMPLE and morphosyntactic features in Hermit Crab ; see the discussion in section 2.5 above and in section 4 below . 3.3 Morph name .","label":"Background","metadata":{},"score":"82.38346"}{"text":"AMPLE 's string conditions are essentially equivalent to the phonetic environment conditions of allomorphy rules in Hermit Crab .There are , on the other hand , significant differences between the treatment of Morpheme Properties in AMPLE and morphosyntactic features in Hermit Crab ; see the discussion in section 2.5 above and in section 4 below . 3.3 Morph name .","label":"Background","metadata":{},"score":"82.38346"}{"text":"However , AMPLE allows the use of morph names in conditioning environments for allomorphs and in tests ; Hermit Crab does not .3.4 Category pairs .AMPLE and Hermit Crab diverge in two ways in their treatment of categories ( parts of speech ) .","label":"Background","metadata":{},"score":"83.23467"}{"text":"However , AMPLE allows the use of morph names in conditioning environments for allomorphs and in tests ; Hermit Crab does not .3.4 Category pairs .AMPLE and Hermit Crab diverge in two ways in their treatment of categories ( parts of speech ) .","label":"Background","metadata":{},"score":"83.23467"}{"text":"Somerset , NJ : Association for Computational Linguistics .Directory .The statement is made that exceptions such as \" canasta \" are often \" perceived as foreign .\" In fact , the Oxford English Dictionary places stress on the penult for both caNASta and caNASter , which may not sound right to ears west of the caNARy Islands , but is British preference ( for the latter ) since the mid Nineteenth - Century .","label":"Background","metadata":{},"score":"83.50548"}{"text":"In this hypothetical word , affix1 's value for the feature foo ' shields ' affix2 from seeing the root 's value for that same feature .Is this restriction in Hermit Crab a great loss ?I would doubt it ; it is , after all , predicted by the linguistic theories on which Hermit Crab 's behavior is based , that there will be no need to test the value of such a ' shielded ' feature .","label":"Background","metadata":{},"score":"83.57292"}{"text":"In this hypothetical word , affix1 's value for the feature foo ' shields ' affix2 from seeing the root 's value for that same feature .Is this restriction in Hermit Crab a great loss ?I would doubt it ; it is , after all , predicted by the linguistic theories on which Hermit Crab 's behavior is based , that there will be no need to test the value of such a ' shielded ' feature .","label":"Background","metadata":{},"score":"83.57292"}{"text":"It might help to use an English example , viz . cats ' ( the possessive plural of cat ) : Morphophonemic kaetzz Moscow - phonemic kaetz Leningrad - phonemic kaets As noted earlier , what I call Moscow - phonemic is the level called phonemic by Baudouin , by the Moscow phonologists , and by Stampe .","label":"Background","metadata":{},"score":"83.81358"}{"text":"It is of course quite possible to use allomorphy rules to describe inward sensitivity as well .Indeed , it might be more appropriate to use allomorphy rules for both inward and outward sensitivity , reserving the use of Hermit Crab subrules for other purposes .","label":"Background","metadata":{},"score":"83.95259"}{"text":"It is of course quite possible to use allomorphy rules to describe inward sensitivity as well .Indeed , it might be more appropriate to use allomorphy rules for both inward and outward sensitivity , reserving the use of Hermit Crab subrules for other purposes .","label":"Background","metadata":{},"score":"83.95259"}{"text":"The implication of these two points is that a single computational implementation can serve a variety of theoretical approaches .In appendix 1 and appendix 2 , I explore as a case study the degree to which the particular Item - and - Arrangement notation of AMPLE corresponds to the Hermit Crab implementation of Item - and - Process morphology .","label":"Background","metadata":{},"score":"84.06528"}{"text":"The implication of these two points is that a single computational implementation can serve a variety of theoretical approaches .In appendix 1 and appendix 2 , I explore as a case study the degree to which the particular Item - and - Arrangement notation of AMPLE corresponds to the Hermit Crab implementation of Item - and - Process morphology .","label":"Background","metadata":{},"score":"84.06528"}{"text":"Continue to the next item .Otherwise , recursively call this algorithm passing value as element , property as active property and o as output .Set item to o .If output is an array , append a copy of item , otherwise append a copy of item to active property in output .","label":"Background","metadata":{},"score":"84.07153"}{"text":"16In the case where allomorphs are treated by the use of multiple subrules of morphological rules , Hermit Crab can assign particular Morphological/ Phonological Rule Features or Head ( morphosyntactic ) Features to allomorphs .However , the use of morphological subrules is arguably not the best way to treat allomorphy .","label":"Background","metadata":{},"score":"84.370346"}{"text":"16In the case where allomorphs are treated by the use of multiple subrules of morphological rules , Hermit Crab can assign particular Morphological/ Phonological Rule Features or Head ( morphosyntactic ) Features to allomorphs .However , the use of morphological subrules is arguably not the best way to treat allomorphy .","label":"Background","metadata":{},"score":"84.370346"}{"text":"Nevertheless , there is a fairly direct translation from AMPLE 's approach to Hermit Crab 's ( as argued for in the abstract in section 2 of the body of this paper ) .I base the discussion here on that in WBM chapter 11 , section 2 .","label":"Background","metadata":{},"score":"84.6315"}{"text":"Nevertheless , there is a fairly direct translation from AMPLE 's approach to Hermit Crab 's ( as argued for in the abstract in section 2 of the body of this paper ) .I base the discussion here on that in WBM chapter 11 , section 2 .","label":"Background","metadata":{},"score":"84.6315"}{"text":"The general theoretical perspective of Hermit Crab is that of classical generative phonology , i.e. generative phonology as practiced between the time of SPE ( Chomsky and Halle 1968 ) and the rise of autosegmental phonology .Phonological representations are treated as sequences of feature bundles , and phonological rules apply to such feature bundles by inserting feature values or copying feature values ( rather than by spreading features ) .","label":"Background","metadata":{},"score":"84.78642"}{"text":"The general theoretical perspective of Hermit Crab is that of classical generative phonology , i.e. generative phonology as practiced between the time of SPE ( Chomsky and Halle 1968 ) and the rise of autosegmental phonology .Phonological representations are treated as sequences of feature bundles , and phonological rules apply to such feature bundles by inserting feature values or copying feature values ( rather than by spreading features ) .","label":"Background","metadata":{},"score":"84.78642"}{"text":"AMPLE uses the affix marker only to define the beginning of the lexical entry record .As such , it is superfluous for Hermit Crab . 3.2 Allomorph .Inasmuch as AMPLE models MUF morphology , while Hermit Crab models SUF morphology , the allomorph fields represent a divergence between the two programs .","label":"Background","metadata":{},"score":"85.25522"}{"text":"AMPLE uses the affix marker only to define the beginning of the lexical entry record .As such , it is superfluous for Hermit Crab . 3.2 Allomorph .Inasmuch as AMPLE models MUF morphology , while Hermit Crab models SUF morphology , the allomorph fields represent a divergence between the two programs .","label":"Background","metadata":{},"score":"85.25522"}{"text":"In AMPLE it is possible to test for morpheme properties on the adjacent morpheme on the left or right using ' left property ' or ' right property ' ( equivalent MECs can be written ) .Such a test is not possible in Hermit Crab , as this program 's behavior is currently specified .","label":"Background","metadata":{},"score":"85.35949"}{"text":"In AMPLE it is possible to test for morpheme properties on the adjacent morpheme on the left or right using ' left property ' or ' right property ' ( equivalent MECs can be written ) .Such a test is not possible in Hermit Crab , as this program 's behavior is currently specified .","label":"Background","metadata":{},"score":"85.35949"}{"text":"However , I am not convinced that this is so , as a matter of fact .Words such as ROckefeller , sAlamander , and so on ( as opposed to AlexAnder and its ilk ) do have the primary stress on the preantepenultimate syllable .","label":"Background","metadata":{},"score":"85.96386"}{"text":"( See also the discussion of category pairs of affixes , below . )Note that Hermit Crab does allow for a single lexical entry to have multiple subcategorizations ( i.e. lists of syntactic complements ) .2.4 Etymology .The etymology field corresponds to Hermit Crab 's gloss field .","label":"Background","metadata":{},"score":"86.238144"}{"text":"( See also the discussion of category pairs of affixes , below . )Note that Hermit Crab does allow for a single lexical entry to have multiple subcategorizations ( i.e. lists of syntactic complements ) .2.4 Etymology .The etymology field corresponds to Hermit Crab 's gloss field .","label":"Background","metadata":{},"score":"86.238144"}{"text":"Morpheme Co - occurrence Constraints .Hermit Crab has nothing corresponding directly to AMPLE 's morpheme co - occurrence constraints .However , a similar behavior can usually be imposed by the use of diacritic features .As discussed in appendix 1 , Hermit Crab also allows specifying that a given diacritic feature be absent , corresponding to a negative cooccurrence constraint .","label":"Background","metadata":{},"score":"86.95623"}{"text":"Morpheme Co - occurrence Constraints .Hermit Crab has nothing corresponding directly to AMPLE 's morpheme co - occurrence constraints .However , a similar behavior can usually be imposed by the use of diacritic features .As discussed in appendix 1 , Hermit Crab also allows specifying that a given diacritic feature be absent , corresponding to a negative cooccurrence constraint .","label":"Background","metadata":{},"score":"86.95623"}{"text":"In AMPLE , a single lexical entry may bear multiple categories , whereas in Hermit Crab a lexical entry has a single part of speech .This difference may be readily bridged , however , by creating one copy of the AMPLE lexical entry for each corresponding part of speech , an expedient which may be necessary in AMPLE in any case if syntactic features are used ( Buseman et al .","label":"Background","metadata":{},"score":"89.89754"}{"text":"In AMPLE , a single lexical entry may bear multiple categories , whereas in Hermit Crab a lexical entry has a single part of speech .This difference may be readily bridged , however , by creating one copy of the AMPLE lexical entry for each corresponding part of speech , an expedient which may be necessary in AMPLE in any case if syntactic features are used ( Buseman et al .","label":"Background","metadata":{},"score":"89.89754"}{"text":"Thanks also to Nathan Rixham , Bradley P. Allen , Kingsley Idehen , Glenn McDonald , Alexandre Passant , Danny Ayers , Ted Thibodeau Jr. , Olivier Grisel , Niklas Lindstrm , Markus Lanthaler , and Richard Cyganiak for their input on the specification .","label":"Background","metadata":{},"score":"90.11565"}{"text":"Another ameliorating factor is that Hermit Crab allows affixes to select for multiple subcategorizations .( Minor category distinctions in AMPLE , such as that between transitive and intransitive verbs , will often translate into distinctions in subcategorization in Hermit Crab . )","label":"Background","metadata":{},"score":"90.33392"}{"text":"Another ameliorating factor is that Hermit Crab allows affixes to select for multiple subcategorizations .( Minor category distinctions in AMPLE , such as that between transitive and intransitive verbs , will often translate into distinctions in subcategorization in Hermit Crab . )","label":"Background","metadata":{},"score":"90.33392"}{"text":"Hermit Crab does not directly support order classes .[20 ] In many cases , order classes can be simulated by placing the affix rules in a linear order ( as advocated e.g. by Anderson 1992 ) .This may not be sufficient , however , if there are affixes whose appearance is unconstrained by the order classes .","label":"Background","metadata":{},"score":"90.37598"}{"text":"Hermit Crab does not directly support order classes .[20 ] In many cases , order classes can be simulated by placing the affix rules in a linear order ( as advocated e.g. by Anderson 1992 ) .This may not be sufficient , however , if there are affixes whose appearance is unconstrained by the order classes .","label":"Background","metadata":{},"score":"90.37598"}{"text":"This appendix presents a brief overview of Hermit Crab and its theoretical perspective .The presentation is done in an informal way by presenting example rules in a notation which should be more or less familiar to linguists .While Hermit Crab 's internal notation is somewhat different , it is not intended to be used by humans ; the reader will have to take my word that the notations used in this appendix can be directly translated into Hermit Crab 's notation .","label":"Background","metadata":{},"score":"90.40958"}{"text":"This appendix presents a brief overview of Hermit Crab and its theoretical perspective .The presentation is done in an informal way by presenting example rules in a notation which should be more or less familiar to linguists .While Hermit Crab 's internal notation is somewhat different , it is not intended to be used by humans ; the reader will have to take my word that the notations used in this appendix can be directly translated into Hermit Crab 's notation .","label":"Background","metadata":{},"score":"90.40958"}{"text":"----------------------------------------------------Ad Hutchinson : It is important to point out , as I do whenever I get the chance , that Larry Hutchinson essentially discovered lexical phonology many years before it became official .Yet , while formally this can indeed be assured , it seems to me that Halle 's point can be strengthened by saying that no one has yet shown the factual differences between the cases at issue which would justify such a distinction .","label":"Background","metadata":{},"score":"90.69765"}{"text":"As stated above , Hermit Crab treats segments ( phones , phonemes etc . ) as feature bundles ; hence the representation above is a simplification .In particular , the variable X representing the stem 's phonological content is actually a regular expression consisting of an empty feature bundle repeated from one [ 11 ] to infinitely many times .","label":"Background","metadata":{},"score":"90.79724"}{"text":"As stated above , Hermit Crab treats segments ( phones , phonemes etc . ) as feature bundles ; hence the representation above is a simplification .In particular , the variable X representing the stem 's phonological content is actually a regular expression consisting of an empty feature bundle repeated from one [ 11 ] to infinitely many times .","label":"Background","metadata":{},"score":"90.79724"}{"text":"Filtering out certain lexical entries is more properly the job of the interface ; that is , lexical entries which are not to be loaded into Hermit Crab should not be passed to it in the first place .( LinguaLinks , for instance , has a concept of \" filters \" which could be adapted for this purpose . )","label":"Background","metadata":{},"score":"91.813385"}{"text":"Filtering out certain lexical entries is more properly the job of the interface ; that is , lexical entries which are not to be loaded into Hermit Crab should not be passed to it in the first place .( LinguaLinks , for instance , has a concept of \" filters \" which could be adapted for this purpose . )","label":"Background","metadata":{},"score":"91.813385"}{"text":"( Hermit Crab also implements Foot Features , but these are irrelevant to the discussion here . )Hermit Crab 's Rule Features correspond to AMPLE 's Allomorph and Morpheme Properties , while Head Features correspond approximately to AMPLE 's \" features . \"","label":"Background","metadata":{},"score":"95.81498"}{"text":"( Hermit Crab also implements Foot Features , but these are irrelevant to the discussion here . )Hermit Crab 's Rule Features correspond to AMPLE 's Allomorph and Morpheme Properties , while Head Features correspond approximately to AMPLE 's \" features . \"","label":"Background","metadata":{},"score":"95.81498"}{"text":"Acknowledgements .A large amount of thanks goes out to the JSON - LD Community Group participants who worked through many of the technical issues on the mailing list and the weekly telecons - of special mention are Niklas Lindstrm , Franois Daoust , and Zdenko ' Denny ' Vrandei .","label":"Background","metadata":{},"score":"99.30914"}{"text":"( i.e. ( ( x FUT(x ) ) , or equivalently , ( x FUT(x ) ) ) .Since the general tests subsume the specific MEC tests , I will defer the question of the equivalence between the AMPLE and Hermit Crab tests to the discussion in section 4 below .","label":"Background","metadata":{},"score":"100.884674"}{"text":"( i.e. ( ( x FUT(x ) ) , or equivalently , ( x FUT(x ) ) ) .Since the general tests subsume the specific MEC tests , I will defer the question of the equivalence between the AMPLE and Hermit Crab tests to the discussion in section 4 below .","label":"Background","metadata":{},"score":"100.884674"}{"text":"One major difference between the two programs is that AMPLE takes a \" string \" view of the world , while Hermit Crab takes a phonetic feature - based view .Thus , while it is possible to define natural classes of sounds in AMPLE , the definition is in terms of a set of strings ( as suggested by the name used in AMPLE for such natural classes , namely \" string class \" ) .","label":"Background","metadata":{},"score":"107.52402"}{"text":"One major difference between the two programs is that AMPLE takes a \" string \" view of the world , while Hermit Crab takes a phonetic feature - based view .Thus , while it is possible to define natural classes of sounds in AMPLE , the definition is in terms of a set of strings ( as suggested by the name used in AMPLE for such natural classes , namely \" string class \" ) .","label":"Background","metadata":{},"score":"107.52402"}{"text":"Section 4 discusses the advantages to be gained by making use of these mappings in the context of computational implementations of morphological models .The first two appendices constitute a case study in this mapping : appendix 1 documents the capabilities of a particular Item - and - Process morphology program , Hermit Crab , while appendix 2 describes some differences between this program 's capabilities and those of an Item - and - Arrangement program , AMPLE .","label":"Background","metadata":{},"score":"108.56058"}{"text":"Section 4 discusses the advantages to be gained by making use of these mappings in the context of computational implementations of morphological models .The first two appendices constitute a case study in this mapping : appendix 1 documents the capabilities of a particular Item - and - Process morphology program , Hermit Crab , while appendix 2 describes some differences between this program 's capabilities and those of an Item - and - Arrangement program , AMPLE .","label":"Background","metadata":{},"score":"108.56058"}{"text":"To summarize the discussion in the body of this paper , AMPLE represents an MUF approach to allomorphy , whereas Hermit Crab takes an SUF approach .Nevertheless , there is good reason to allow the user to set up allomorphy statements apart from phonological rules ( as argued above in section 3 of the body of this paper ) , and these allomorphy statements can be used to simulate an MUF model .","label":"Background","metadata":{},"score":"108.90911"}{"text":"To summarize the discussion in the body of this paper , AMPLE represents an MUF approach to allomorphy , whereas Hermit Crab takes an SUF approach .Nevertheless , there is good reason to allow the user to set up allomorphy statements apart from phonological rules ( as argued above in section 3 of the body of this paper ) , and these allomorphy statements can be used to simulate an MUF model .","label":"Background","metadata":{},"score":"108.90911"}{"text":"Because of AMPLE 's programming language approach , there are a great many tests that one could perform in AMPLE which have no direct equivalent in Hermit Crab .It is not my intention to explore all the possibilities AMPLE 's tests offer , as its programming language approach would render this an open ended exercise .","label":"Background","metadata":{},"score":"122.873505"}{"text":"Because of AMPLE 's programming language approach , there are a great many tests that one could perform in AMPLE which have no direct equivalent in Hermit Crab .It is not my intention to explore all the possibilities AMPLE 's tests offer , as its programming language approach would render this an open ended exercise .","label":"Background","metadata":{},"score":"122.873505"}