{"text": "After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .This process is a very powerful extension of what is possible in other parsers such as Yacc .", "label": "", "metadata": {}, "score": "42.35354"}
{"text": "After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .This process is a very powerful extension of what is possible in other parsers such as Yacc .", "label": "", "metadata": {}, "score": "42.35354"}
{"text": "After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .This process is a very powerful extension of what is possible in other parsers such as Yacc .", "label": "", "metadata": {}, "score": "42.35354"}
{"text": "After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .This process is a very powerful extension of what is possible in other parsers such as Yacc .", "label": "", "metadata": {}, "score": "42.35354"}
{"text": "The N - gram - enabled parser is co - trained with another parser that only considers the translation of the noun phrase ; this parser resolves ambiguities on the basis of the word order in the translation .The co - training happens in a bitext where translations are available , but the resulting N - gram - enabled parser works amazingly well on new domains .", "label": "", "metadata": {}, "score": "43.741615"}
{"text": "Taking the dependency layer as the parsing unit , the proposed parser has a lower computational complexity than graph - based models which search for a whole dependency graph and alleviates the error propagation that transition - based models suffer from to some extent .", "label": "", "metadata": {}, "score": "45.060112"}
{"text": "Experimental results indicate that the proposed approach offers desirable accuracies and especially a fast parsing speed . ... mplementations in projective case .The Classifier Splitting heuristic strategy and SVM speeding up methods ( Goldberg and Elhadad , 2008 ) are gold choi ... . \" ...", "label": "", "metadata": {}, "score": "45.26615"}
{"text": "Our gold - standard NP data is now available and will be useful for all parsers .We present three statistical methods for parsing NP structure .Firstly , we apply the Collins ( 2003 ) model , and find that its recovery of NP structure is significantly worse than its overall performance .", "label": "", "metadata": {}, "score": "45.831814"}
{"text": "Anders S\u00f8gaard and Christian Rish\u00f8j .Semi - supervised dependency parsing using generalized tri - training .Joseph Turian et al .2010 .Word representations : a simple and general method for semi - supervised learning .In ACL .Shuicheng Yan and Huan Wang .", "label": "", "metadata": {}, "score": "46.08663"}
{"text": "To address this challenge , many QA systems have incorporated semantic resources for answer ranking in a single language .However , there has been little research on a generalized probabilistic framework that models the correctness and correlation of answer candidates for multiple languages .", "label": "", "metadata": {}, "score": "46.34324"}
{"text": "Kenji Sagae and Andrew Gordon .Clustering words by syntactic similarity improves dependency parsing of predicate - argument structures .In IWPT .Drahomira Spoustova et al . , 2009 .Semi - supervised training for the averaged perceptron POS tagger .", "label": "", "metadata": {}, "score": "47.316406"}
{"text": "This includes , but is not limited to POS tagging , grammar induction and parsing , named entity recognition , word sense induction and disambiguation , machine translation , sentiment analysis and taxonomy learning .Our goal is to evaluate known unsupervised and semi - supervised learning algorithms , foster novel and more robust ones and discuss positive and negative results that may otherwise not appear in a technical paper at a major conference .", "label": "", "metadata": {}, "score": "48.099815"}
{"text": "3 ) Manual Filtering Other than the features mentioned above , we manually created many rules for numeric and temporal questions to filter out invalid answers .For example , when the question is looki ... . \" ...Data - driven function tag assignment has been studied for English using Penn Treebank data .", "label": "", "metadata": {}, "score": "48.107376"}
{"text": "Simple semi - supervised dependency parsing .In ACL - HLT .Rada Mihalcea .Co- training and self - training for word sense disambiguation .In CoNLL .Kenji Sagae and Jun'ichi Tsujii .Dependency parsing and domain adaptation with LR models and parser ensembles .", "label": "", "metadata": {}, "score": "48.791542"}
{"text": "This paper presents a language - independent probabilistic answer ranking framework for question answering .The framework estimates the probability of an individual answer candidate given the degree of answer relevance and the amount of supporting evidence provided in the set of answer candidates for the question .", "label": "", "metadata": {}, "score": "49.20659"}
{"text": "We find that NPs are particularly reliant on this lexical information , due to their exceptional productivity and the reduced explicitness present in modifier sequences .Our results show that NP parsing is a significantly harder task than parsing in general .", "label": "", "metadata": {}, "score": "49.328747"}
{"text": "Secondly , we construct a wide - coverage , large - scale NP Bracketing system , applying a supervised model to achieve excellent results .Our Penn Treebank data set , which is orders of magnitude larger than those used previously , makes this possible for the first time .", "label": "", "metadata": {}, "score": "50.719063"}
{"text": "Having achieved this , we use the NP Bracketing system to reanalyse NPs outputted by the Collins ( 2003 ) parser .Our post - processor outperforms this state - of - the - art parser .For our third model , we convert the NP data to CCGbank ( Hockenmaier and Steedman , 2007 ) , a corpus that uses the Combinatory Categorial Grammar ( CCG ) formalism .", "label": "", "metadata": {}, "score": "50.77771"}
{"text": "Results In this section we will first discuss our NTC ... .by Ping Jian , Chengqing Zong - Proceedings of the 23rd Pacific Asia Conference on Language , Information and Computation ( PACLIC , 2009 . \" ... Abstract .In this paper , a layer - based projective dependency parsing approach is presented .", "label": "", "metadata": {}, "score": "50.967575"}
{"text": "We also evaluate the CCG parser against the Briscoe and Carroll ( 2006 ) reannotation of DepBank ( King et al . , 2003 ) , another corpus that annotates NP structure .This supplies further evidence that parser performance is increased by improving the representation of NP structure .", "label": "", "metadata": {}, "score": "50.973015"}
{"text": "This paper proposes a method to improve shift - reduce constituency parsing by using lexical dependencies .The lexical dependency information is obtained from a large amount of auto - parsed data that is generated by a baseline shift - reduce parser on unlabeled data .", "label": "", "metadata": {}, "score": "51.404625"}
{"text": "This paper proposes a method to improve shift - reduce constituency parsing by using lexical dependencies .The lexical dependency information is obtained from a large amount of auto - parsed data that is generated by a baseline shift - reduce parser on unlabeled data .", "label": "", "metadata": {}, "score": "51.404625"}
{"text": "Under those circumstances , I think Spirit , or frameworks like it , will start to become more common .On a final personal note , I find STL and Boost to be invaluable tools for the programmer .Whether you need them every time you start to code is another matter , but they are still great tools when the time is right .", "label": "", "metadata": {}, "score": "51.58245"}
{"text": "I decided that in this case , I would demonstrate another commonly used tool associated with parsing , the conversion of input into a composite tree .Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .", "label": "", "metadata": {}, "score": "52.2994"}
{"text": "I decided that in this case , I would demonstrate another commonly used tool associated with parsing , the conversion of input into a composite tree .Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .", "label": "", "metadata": {}, "score": "52.2994"}
{"text": "I decided that in this case , I would demonstrate another commonly used tool associated with parsing , the conversion of input into a composite tree .Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .", "label": "", "metadata": {}, "score": "52.2994"}
{"text": "I decided that in this case , I would demonstrate another commonly used tool associated with parsing , the conversion of input into a composite tree .Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .", "label": "", "metadata": {}, "score": "52.2994"}
{"text": "In this article , I will add in the necessary code to carry out semantic actions on the input , and therefore provide a fully functional modular arithmetic calculator .Background .There are numerous ways to parse input from files , the command line , or elsewhere .", "label": "", "metadata": {}, "score": "52.52149"}
{"text": "In this article , I will add in the necessary code to carry out semantic actions on the input , and therefore provide a fully functional modular arithmetic calculator .Background .There are numerous ways to parse input from files , the command line , or elsewhere .", "label": "", "metadata": {}, "score": "52.52149"}
{"text": "In this article , I will add in the necessary code to carry out semantic actions on the input , and therefore provide a fully functional modular arithmetic calculator .Background .There are numerous ways to parse input from files , the command line , or elsewhere .", "label": "", "metadata": {}, "score": "52.52149"}
{"text": "If I want to do high performance linear algebra , I do n't need to go to Fortran , I can use boost::numeric::ublas .The list goes on ... .5 for this message ( and I 'll give you 5 for the article when I actually take time to carefully read it ) .", "label": "", "metadata": {}, "score": "52.79571"}
{"text": "The framework estimates the probability of an individual answer candidate given the degree of answer relevance and the amount of supporting evidence provided in the set of answer candidates for ... \" .This paper presents a language - independent probabilistic answer ranking framework for question answering .", "label": "", "metadata": {}, "score": "52.876183"}
{"text": "The features can help to disambiguate action conflicts during decoding .Experimental results show that the new features achieve absolute improvements over a strong baseline by 0.9 % and 1.1 % on English and Chinese respectively .Moreover , the improved parser outperforms all previously reported shift - reduce constituency parsers . .", "label": "", "metadata": {}, "score": "53.251076"}
{"text": "( a )The problem language is complex .This stems from the fact that the problem is complex .If the problem of parsing was easy we would have already seen a near - perfect solution - but we have n't .", "label": "", "metadata": {}, "score": "53.26532"}
{"text": "( a )The problem language is complex .This stems from the fact that the problem is complex .If the problem of parsing was easy we would have already seen a near - perfect solution - but we have n't .", "label": "", "metadata": {}, "score": "53.26532"}
{"text": "( a )The problem language is complex .This stems from the fact that the problem is complex .If the problem of parsing was easy we would have already seen a near - perfect solution - but we have n't .", "label": "", "metadata": {}, "score": "53.26532"}
{"text": "My list of things that I would like to see in the standard probably includes : . 1 ) Some advancements to templates to improve their use in libraries .The export keyword ( virtually unsupported on compilers ) and explicit instantiation are only a partial solution in my view .", "label": "", "metadata": {}, "score": "53.58087"}
{"text": "Unsupervised and minimally unsupervised NLP also sees rapid growth .Mixture models have also been successfully used ( Suzuki and Isozaki , 2008 ; Suzuki et al . , 2009 ) .While feature - based methods seem relatively robust , self - training and co - training are very parameter - sensitive , and parameter tuning has therefore become an important research topic ( Goldberg and Zhu , 2009 ) .", "label": "", "metadata": {}, "score": "54.09008"}
{"text": "The recent explosive growth of online , accessible corpora of spoken language interactions opens up new opportunities for the development of high accuracy parsing approaches to the analysis of spoken language .The availability of high accuracy parsers will in turn provide a platform for development of a wide range of new applications , as well as for advanced research on the nature of conversational interactions .", "label": "", "metadata": {}, "score": "54.13375"}
{"text": "The problem language is complex .This stems from the fact that the problem is complex .If the problem of parsing was easy we would have already seen a near - perfect solution - but we have n't .In my view we are getting closer to solving the problem - and Spirit moves us a step closer .", "label": "", "metadata": {}, "score": "54.489777"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "To those of you familiar with the process of building a balanced binary tree , this process is remarkably similar .The diagram below demonstrates the process : .Following this process through , we can see that the first two steps involve adding numeric leaf nodes to the root node .", "label": "", "metadata": {}, "score": "54.583298"}
{"text": "Inside the layer the dependency graphs are searched exhaustively while between the layers the parser state transfers deterministically .Taking the ... \" .Abstract .In this paper , a layer - based projective dependency parsing approach is presented .This novel approach works layer by layer from the bottom up .", "label": "", "metadata": {}, "score": "54.816246"}
{"text": "the compile time evaluation of templates more typically results in compact code with redundant branches eliminated by the compiler . a ) the problem language is complex .a simple interface can at best veil the complexity , but at some layer it is still there .", "label": "", "metadata": {}, "score": "55.256233"}
{"text": "the compile time evaluation of templates more typically results in compact code with redundant branches eliminated by the compiler . a ) the problem language is complex .a simple interface can at best veil the complexity , but at some layer it is still there .", "label": "", "metadata": {}, "score": "55.256233"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Once the input has been parsed , an expression tree will exist in the m_parser object .You can visit this tree to get out the results of the expression , or to print the tree in a formatted way .For example : .", "label": "", "metadata": {}, "score": "55.675095"}
{"text": "Our contributions allow wide - coverage , large - scale NP parsers to be constructed for the first time , and motivate further NP parsing research for the future .The results of our work can provide significant benefits for many NLP tasks , as the crucial information contained in NP structure is now available for all downstream systems .", "label": "", "metadata": {}, "score": "56.04017"}
{"text": "N - gram - enabled systems not only work better on new domains , they also permit interesting new semi - supervised training strategies .For example , I present a semi - supervised approach to noun phrase parsing that exploits bilingual data .", "label": "", "metadata": {}, "score": "56.10499"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "For example , if you use a functor which has not yet been defined , you will quite often get a C1001 , Internal Compiler Error .Conclusions .Once you have created a parser in the Spirit Framework , it is pretty easy to plumb in semantic actions .", "label": "", "metadata": {}, "score": "56.68334"}
{"text": "With ( b ) , you have options .I consider the approach of Spirit interestingat least : mapping a formal language to C++ .( and , on a meta - level , it is philosophically interesting : mapping a meta - language using meta - language constructs ) .", "label": "", "metadata": {}, "score": "56.744324"}
{"text": "With ( b ) , you have options .I consider the approach of Spirit interestingat least : mapping a formal language to C++ .( and , on a meta - level , it is philosophically interesting : mapping a meta - language using meta - language constructs ) .", "label": "", "metadata": {}, "score": "56.744324"}
{"text": "With ( b ) , you have options .I consider the approach of Spirit interestingat least : mapping a formal language to C++ .( and , on a meta - level , it is philosophically interesting : mapping a meta - language using meta - language constructs ) .", "label": "", "metadata": {}, "score": "56.744324"}
{"text": "I will deal with the details of these functors in a later section in this article .There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .", "label": "", "metadata": {}, "score": "57.48919"}
{"text": "I will deal with the details of these functors in a later section in this article .There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .", "label": "", "metadata": {}, "score": "57.48919"}
{"text": "I will deal with the details of these functors in a later section in this article .There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .", "label": "", "metadata": {}, "score": "57.48919"}
{"text": "I will deal with the details of these functors in a later section in this article .There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .", "label": "", "metadata": {}, "score": "57.48919"}
{"text": "There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .In fact , this concept is used by the calculators that come as demonstration projects with the Spirit library .", "label": "", "metadata": {}, "score": "57.55376"}
{"text": "There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .In fact , this concept is used by the calculators that come as demonstration projects with the Spirit library .", "label": "", "metadata": {}, "score": "57.55376"}
{"text": "There are many ways in which input can be processed .In the case of a simple command line calculator , it is usually possible to simply process the input as it comes in , with an evaluation stack .In fact , this concept is used by the calculators that come as demonstration projects with the Spirit library .", "label": "", "metadata": {}, "score": "57.55376"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "Firstly , you need to place the functors in suitable locations within the grammar .Secondly , you need to ensure that the functors can pass any action onto the application appropriately .If you look back at the two functors defined above , both of them take a reference to a CParser which in the case of this application is the overall managing class .", "label": "", "metadata": {}, "score": "58.00406"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "To demonstrate the process of placing functors in the grammar , I will show you a section of the grammar : . definition ( Syntax const & self ) .uint_p [ Private::AddNumericChild ( self.m_parser ) ] .; // Parse a bracketed expression , a single integer , or a unary // plus or minus .", "label": "", "metadata": {}, "score": "58.195236"}
{"text": "An overall analysis and a detailed module - by - module analysis are presented . ...S - MSRSeg [ 23].We also performed NE tagging using BBN 's Identifinder [ 6 ] , and merged with NE tags produced by S - MSRSeg .", "label": "", "metadata": {}, "score": "58.60728"}
{"text": "Comments and Discussions . a ) the problem language is complex .a simple interface can at best veil the complexity , but at some layer it is still there .b )The conversion is n't perfect ( you 'll encounter enough template issues of their own ) , and compiler diagnostics etc . are not customized .", "label": "", "metadata": {}, "score": "59.020355"}
{"text": "Comments and Discussions .i totally agree .i think a lot of the real benefits of templates and boost are obscure until you want ( need ) to accomplish certain things and realize how much work they would be using more ' traditional ' methods .", "label": "", "metadata": {}, "score": "59.331123"}
{"text": "Parameter - sensitivity is even more dramatic in unsupervised learning of structured variables , e.g. unsupervised part - of - speech tagging and grammar induction .By more robust unsupervised or semi - supervised learning algorithms we mean algorithms with few parameters that give good results across different data sets and different applications .", "label": "", "metadata": {}, "score": "59.41889"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "I have written two visitors for the composite tree .The first is a left to right visitor that will print the expression represented by the tree .The second is a bottom to top visitor that evaluates the expression represented by the tree .", "label": "", "metadata": {}, "score": "59.475918"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "If you use the built in number parsers , for example , the uint_p parser will require a functor that takes a single unsigned int .This can be seen below : . struct AddNumericChild .m_parser .private : .Communicating Between the Parser and the Application .", "label": "", "metadata": {}, "score": "59.549965"}
{"text": "Steven Abney .Semi - supervised learning for computational linguistics .Chapman & Hall .Andrew Goldberg and Jerry Zhu .Keepin ' it real : semi - supervised learning with realistic tuning .In NAACL .Terry Koo et al .", "label": "", "metadata": {}, "score": "59.694374"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "The iterator parameters give you access to the input just parsed , although in this example I did not need the input .When you are designing a functor , it is important to understand the lifetime of these functors .A new functor is not created each time a semantic action is used , instead the same functor exists for the lifetime of the grammar object .", "label": "", "metadata": {}, "score": "60.229042"}
{"text": "An initial approach to parsing another language in CHILDES would involve repeating the procedure for parsing English described throughout this dissertation .The first ... . \" ...We present a new probabilistic model based on the lexical PCFG model , which can easily utilize the Chinese character information to solve the lexical information sparseness in lexical PCFG model .", "label": "", "metadata": {}, "score": "60.27826"}
{"text": "Despite significant advances in syntactic parsing of written text , the application of these techniques to spontaneous spoken language has received more limited attention .The recent explosive growth of online , a ... \" .Automatic analysis of syntax is one of the core problems in natural language processing .", "label": "", "metadata": {}, "score": "60.70716"}
{"text": "For me , Boost is an extension of all the things I like about C++ .If I want to do high performance linear algebra , I do n't need to go to Fortran , I can use boost::numeric::ublas .The list goes on ... .", "label": "", "metadata": {}, "score": "60.755795"}
{"text": "b )The conversion is n't perfect ( you 'll encounter enough template issues of their own ) , and compiler diagnostics etc . are not customized .( But then , I rather debug my own \" template - bloated \" code , than the output of a code generator . )", "label": "", "metadata": {}, "score": "61.054325"}
{"text": "Comments and Discussions .I have played around a bit with the spirit parser , and done a bit of programming with WTL .And after quite an extended acceptance period ( that is a period when I simply could n't understand how this hangs together ) , I 'm now a firm believer in this programming technique .", "label": "", "metadata": {}, "score": "61.105556"}
{"text": "new unsupervised or semi - supervised methods for NLP problems .positive and negative results on using of unsupervised or semi - supervised methods in applications .application - oriented evaluation of unsupervised or semi - supervised methods . comparison and combination of unsupervised or semi - supervised methods .", "label": "", "metadata": {}, "score": "61.243767"}
{"text": "Thanks - I 've always found parsing to be one of those things for which there are loads of programming tools , but none of them are quite satisfactory .Spirit gets the closest in my view .It has some weaknesses , but I think these are outweighed by the advantages .", "label": "", "metadata": {}, "score": "61.77345"}
{"text": "For Japanese , Chasen 4 was used .6.2.2 Answer Similarity Features As Chinese and Japanese factoid questions require short text phrases as answers , the similarity between two answer candidates can be calculated with string distance ... . \" ...This paper presents a language - independent probabilistic answer ranking framework for question answering .", "label": "", "metadata": {}, "score": "61.805206"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "GetModular ( ) ) ; value ( m_parser . pop ( ) ; .This code sets the base of the modular arithmetic on the CCalculateTreeVisitor , runs the visitor on the expression tree , and gets the result from the top of the visitor stack .", "label": "", "metadata": {}, "score": "61.974937"}
{"text": "Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "62.23293"}
{"text": "Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "62.23293"}
{"text": "Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "62.23293"}
{"text": "IMHO , we will see compilers get better and better at working with templates with debugging and error reporting getting more advanced .Under those circumstances , I think Spirit , or frameworks like it , will start to become more common .", "label": "", "metadata": {}, "score": "62.30786"}
{"text": "IMHO , we will see compilers get better and better at working with templates with debugging and error reporting getting more advanced .Under those circumstances , I think Spirit , or frameworks like it , will start to become more common .", "label": "", "metadata": {}, "score": "62.30786"}
{"text": "IMHO , we will see compilers get better and better at working with templates with debugging and error reporting getting more advanced .Under those circumstances , I think Spirit , or frameworks like it , will start to become more common .", "label": "", "metadata": {}, "score": "62.30786"}
{"text": "How to further enrich feature representations for better shift - reduce constituency parsing becomes a very challenging problem .In this paper , we solve this issue by using the ... . \" ... question answering To my family for love and support . iv Question answering ( QA ) aims at finding exact answers to a user 's natural language question from a large collection of documents .", "label": "", "metadata": {}, "score": "62.670845"}
{"text": "The conversion is n't perfect ( you 'll encounter enough template issues of their own ) , and compiler diagnostics etc . are not customized .( But then , I rather debug my own \" template - bloated \" code , than the output of a code generator . )", "label": "", "metadata": {}, "score": "62.87527"}
{"text": "The conversion is n't perfect ( you 'll encounter enough template issues of their own ) , and compiler diagnostics etc . are not customized .( But then , I rather debug my own \" template - bloated \" code , than the output of a code generator . )", "label": "", "metadata": {}, "score": "62.87527"}
{"text": "The best thing about modern C++ is the flexibility : we can easily mix high - level abstractions with low - level C ( or even assembly ) code when necessary .I think there has to be an article out there by someone concerning the future of C++ .", "label": "", "metadata": {}, "score": "62.891518"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "AddChild ( CParser & parser , createPtr create ) : . m_parser .m_parser .private : .CParser & m_parser ; .Here , we have two operator ( ) s , one taking a single IteratorT , and the other taking a pair of IteratorT s. The single parameter version will be called when you attach an action to a single character parser , for example , the ch_p parser .", "label": "", "metadata": {}, "score": "63.180557"}
{"text": "In addition to simply extend previous method from English to Chinese , we also proposed an ... \" .Data - driven function tag assignment has been studied for English using Penn Treebank data .In this paper , we address the question of whether such method can be applied to other languages and Treebank resources .", "label": "", "metadata": {}, "score": "63.204124"}
{"text": "Comments and Discussions .I find Boost is generally very usable and straightforward .I 've used loads of the Boost libraries in industrial strength code , including smart pointers , regex , ublas , operators and spirit .In every case the code that has been produced has been smaller , faster and more understandable as a result .", "label": "", "metadata": {}, "score": "63.585983"}
{"text": "Comments and Discussions .I find Boost is generally very usable and straightforward .I 've used loads of the Boost libraries in industrial strength code , including smart pointers , regex , ublas , operators and spirit .In every case the code that has been produced has been smaller , faster and more understandable as a result .", "label": "", "metadata": {}, "score": "63.585983"}
{"text": "Empirical results from testing on NT - CIR factoid questions show a 40 % performance improvement in Chinese answer selection and a 45 % improvement in Japanese answer selection . ... nce between an answer candidate and question keywords , segmentation was done with linguistic tools .", "label": "", "metadata": {}, "score": "63.594173"}
{"text": "This is a great article .But it takes no sense to evaluate it if not interested in the \" boost \" things .I could n't agree more .Design patterns are great - but they are only one of the many tools in the programmers toolbox .", "label": "", "metadata": {}, "score": "63.710262"}
{"text": "Hand - coded parsers are impossible to change , debug , get working in the first place , etc .Lex and yacc are excellent , but the code they produce is unreadable , and you need to learn a whole new file format to use them - plus the format is n't even standardised so each time you use a new implementation you re - learn a load of code .", "label": "", "metadata": {}, "score": "63.74227"}
{"text": "Hand - coded parsers are impossible to change , debug , get working in the first place , etc .Lex and yacc are excellent , but the code they produce is unreadable , and you need to learn a whole new file format to use them - plus the format is n't even standardised so each time you use a new implementation you re - learn a load of code .", "label": "", "metadata": {}, "score": "63.74227"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "I tend to solve this particular problem by growing the tree below a customized root node .As each node in the tree is created , it is added to the root node .Initially , leaf nodes are added , but as composite nodes are added , they detach certain leaf nodes from underneath the root node , and add them to their own children lists .", "label": "", "metadata": {}, "score": "64.24718"}
{"text": "For example : SQL scripts or mathematical expressions .Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "64.32062"}
{"text": "For example : SQL scripts or mathematical expressions .Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "64.32062"}
{"text": "For example : SQL scripts or mathematical expressions .Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "64.32062"}
{"text": "For example : SQL scripts or mathematical expressions .Once you have the composite tree , performing a variety of actions on the tree simply becomes a problem of writing an appropriate composite visitor .A visitor can easily re - output the tree in a new file format , or output the data after it has been edited by the program .", "label": "", "metadata": {}, "score": "64.32062"}
{"text": "Simple , Effective , Robust Semi - Supervised Learning , Thanks To Google N - grams Invited talk by Shane Bergsma ( Johns Hopkins University ) .Systems trained on labeled data have become the dominant technology in academic NLP , but it 's questionable how robust and therefore how practical these systems really are .", "label": "", "metadata": {}, "score": "64.863914"}
{"text": "I want templates to be able to exist in a separate compilation unit without massive recompilation times . 2 ) Something to do with general abstract base classes .The Java Object class is an example of this .I do n't know exactly what I want here - but an option to make everything derive from an abstract base would be really useful - especially if that abstract base used policies to allow you to do such things as introduce optional garbage collection .", "label": "", "metadata": {}, "score": "64.92639"}
{"text": "For people familiar with Yacc , you will know that each rule in the grammar can be followed by some embedded pseudo - C code .Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .", "label": "", "metadata": {}, "score": "65.02945"}
{"text": "For people familiar with Yacc , you will know that each rule in the grammar can be followed by some embedded pseudo - C code .Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .", "label": "", "metadata": {}, "score": "65.02945"}
{"text": "For people familiar with Yacc , you will know that each rule in the grammar can be followed by some embedded pseudo - C code .Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .", "label": "", "metadata": {}, "score": "65.02945"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "The possibilities are endless .In this article , I have used code from a previous article that I wrote entitled : Composites and Visitors - a Templatised Approach .This article provides a generic composite base class , as well as provides various schemes for visiting the entire composite tree in a particular order .", "label": "", "metadata": {}, "score": "65.06278"}
{"text": "We investigated a supervised sequence learning method to automatically recognize function tags , which achieves an F - score of 0.938 on gold - standard POS ( Part - of - Speech ) tagged Chinese text - a statistically significant improvement over existing Chinese function label assignment systems .", "label": "", "metadata": {}, "score": "65.14931"}
{"text": "4.5 Error Analysis In the ... Introduction .In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .In that article , I created the necessary code to successfully parse the input for a simple modular arithmetic calculator .", "label": "", "metadata": {}, "score": "65.25397"}
{"text": "Our approach was evaluated by comparing the candidate answer sets generated by Chinese and Japanese answer extractors with the re - ranked answer sets produced by the answer ranking framework .Empirical results from testing on NT - CIR factoid questions show a 40 % performance improvement in Chinese answer selection and a 45 % improvement in Japanese answer selection . by Teruko Mitamura , Frank Lin , Hideki Shima , Mengqiu Wang , Jeongwoo Ko , Justin Betteridge , Matthew Bilotti , Andrew Schlaikjer , Eric Nyberg - In Proceedings of the 6th NTCIR Workshop , 2007 . \" ...", "label": "", "metadata": {}, "score": "65.354294"}
{"text": "i do n't see why templates should ' bloat ' code , unless they use loop unrolling deliberately for efficiency .the compile time evaluation of templates more typically results in compact code with redundant branches eliminated by the compiler . a ) the problem language is complex .", "label": "", "metadata": {}, "score": "65.848404"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "The most important of these is a root node which sits at the root of the tree and has all other nodes underneath .The reason for writing this root node concerns a particular detail of writing parsers that convert input into composite trees .", "label": "", "metadata": {}, "score": "66.260895"}
{"text": "( i.e. if it were just between me and the compiler , I could even like STL ) .Oh , and boost contains a variety of libraries , some bloated , some good .And it 's your choice which ones to use ( which is fundamental for a library in my most arrogant opinion ) .", "label": "", "metadata": {}, "score": "66.314285"}
{"text": "i think a lot of the real benefits of templates and boost are obscure until you want ( need ) to accomplish certain things and realize how much work they would be using more ' traditional ' methods .or how about scanf ( ) , which is useful if you want to guarantee undefined behaviour .", "label": "", "metadata": {}, "score": "66.91231"}
{"text": "i think a lot of the real benefits of templates and boost are obscure until you want ( need ) to accomplish certain things and realize how much work they would be using more ' traditional ' methods .or how about scanf ( ) , which is useful if you want to guarantee undefined behaviour .", "label": "", "metadata": {}, "score": "66.91231"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "The Spirit framework uses either function pointers or functors to callback from the parser into your application .I personally recommend using functors because of the increased object orientation .The functor itself must follow a set format , of which the Spirit framework supports a number .", "label": "", "metadata": {}, "score": "67.02633"}
{"text": "question answering To my family for love and support . iv Question answering ( QA ) aims at finding exact answers to a user 's natural language question from a large collection of documents .Most QA systems combine information retrieval with extraction techniques to identify a set of likely candidates and then utilize some selection strategy to generate the final answers .", "label": "", "metadata": {}, "score": "67.32518"}
{"text": "Introduction .In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .In that article , I created the necessary code to successfully parse the input for a simple modular arithmetic calculator .", "label": "", "metadata": {}, "score": "68.66961"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "As the composite is visited from the bottom of the tree to the top , results from visiting each node are placed on a stack .The operator nodes work in a very similar way to a Forth interpreter ; whereby the plus node , for example , pops the top two elements off the stack , calculates the sum of them , and pushes on the results : . void .", "label": "", "metadata": {}, "score": "69.56608"}
{"text": "The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .After that , we must carry out semantic actions .What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .", "label": "", "metadata": {}, "score": "69.593994"}
{"text": "The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .After that , we must carry out semantic actions .What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .", "label": "", "metadata": {}, "score": "69.593994"}
{"text": "The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .After that , we must carry out semantic actions .What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .", "label": "", "metadata": {}, "score": "69.593994"}
{"text": "You ca n't help ( a ) , you can only isolate the end - user from a specific grammar ( but that works with both the Spirit and lexx / yacc approach ) .With ( b ) , you have options .", "label": "", "metadata": {}, "score": "69.69839"}
{"text": "robus2011 .Workshop on Robust Unsupervised and Semisupervised Methods in Natural Language Processing .In natural language processing ( NLP ) , supervised learning scenarios are more frequently explored than unsupervised or semi - supervised ones .Unfortunately , labeled data are often highly domain - dependent and short in supply .", "label": "", "metadata": {}, "score": "69.81751"}
{"text": "Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .Obvious examples such as XML or VRML parsers immediately spring to mind , but there are other file formats that can sensibly be parsed into a tree .", "label": "", "metadata": {}, "score": "69.818115"}
{"text": "Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .Obvious examples such as XML or VRML parsers immediately spring to mind , but there are other file formats that can sensibly be parsed into a tree .", "label": "", "metadata": {}, "score": "69.818115"}
{"text": "Modeling the Input Using a Composite .Many input formats can be parsed successfully by generating a composite tree out of the parser .Obvious examples such as XML or VRML parsers immediately spring to mind , but there are other file formats that can sensibly be parsed into a tree .", "label": "", "metadata": {}, "score": "69.818115"}
{"text": "Whether you need them every time you start to code is another matter , but they are still great tools when the time is right .General News Suggestion Question Bug Answer Joke Praise Rant Admin .Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .", "label": "", "metadata": {}, "score": "69.91726"}
{"text": "Whether you need them every time you start to code is another matter , but they are still great tools when the time is right .General News Suggestion Question Bug Answer Joke Praise Rant Admin .Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .", "label": "", "metadata": {}, "score": "69.91726"}
{"text": "I find terrible both to force everything to stay in the \" generics \" or in the classic OOP .And I 'm dreaming a language where templates can be translatable and OOP is not forced \" by definition \" to single inheritance and interfaces .", "label": "", "metadata": {}, "score": "70.45057"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "The Spirit framework is a very powerful way of creating highly object oriented parsers .The complex syntax and use of cutting edge language features are not for the fainthearted , but I think that the effort required to learn the framework will be well rewarded .", "label": "", "metadata": {}, "score": "70.45572"}
{"text": "This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .After each integer is processed , the framework will call the functor ProcessInt ( ) passing in the integer that has been processed .", "label": "", "metadata": {}, "score": "70.9942"}
{"text": "This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .After each integer is processed , the framework will call the functor ProcessInt ( ) passing in the integer that has been processed .", "label": "", "metadata": {}, "score": "70.9942"}
{"text": "This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .After each integer is processed , the framework will call the functor ProcessInt ( ) passing in the integer that has been processed .", "label": "", "metadata": {}, "score": "70.9942"}
{"text": "This lack of gold - standard data has restricted all previous efforts to parse NPs , making it impossible to perform the supervised experiments that have achieved high performance in so many Natural Language Processing ( NLP ) tasks .We comprehensively solve this problem by manually annotating NP structure for the entire Wall Street Journal section of the Penn Treebank .", "label": "", "metadata": {}, "score": "71.05305"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "The root node therefore contains a function to do this operation : . void . assert ( false ) ; .You can see that this function looks for the last two nodes under the root node , removes them from the root node , adding them to the new node , before finally adding the new node underneath the root .", "label": "", "metadata": {}, "score": "71.13943"}
{"text": "We present a new probabilistic model based on the lexical PCFG model , which can easily utilize the Chinese character information to solve the lexical information sparseness in lexical PCFG model .We discuss in particular some important features that can improve the parsing performance , and describe the strategy of modifying original label structure to reduce the label ambiguities .", "label": "", "metadata": {}, "score": "71.19983"}
{"text": "I have \" personal issues \" with what you call bloated libraries , for mere practical purposes .( i.e. if it were just between me and the compiler , I could even like STL ) .Oh , and boost contains a variety of libraries , some bloated , some good .", "label": "", "metadata": {}, "score": "71.31224"}
{"text": "I have \" personal issues \" with what you call bloated libraries , for mere practical purposes .( i.e. if it were just between me and the compiler , I could even like STL ) .Oh , and boost contains a variety of libraries , some bloated , some good .", "label": "", "metadata": {}, "score": "71.31224"}
{"text": "I have \" personal issues \" with what you call bloated libraries , for mere practical purposes .( i.e. if it were just between me and the compiler , I could even like STL ) .Oh , and boost contains a variety of libraries , some bloated , some good .", "label": "", "metadata": {}, "score": "71.31224"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "It relies on using function pointers , or in a more object oriented way , functors , to callback from the parser into the parent application .Defining the Semantic Action Functors .Functors are simply classes that implement a function call operator , operator ( ) .", "label": "", "metadata": {}, "score": "71.48399"}
{"text": "Whether you need them every time you start to code is another matter , but they are still great tools when the time is right .General News Suggestion Question Bug Answer Joke Praise Rant Admin .Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages . \" ...", "label": "", "metadata": {}, "score": "71.75708"}
{"text": "Background .There are numerous ways to parse input from files , the command line , or elsewhere .Despite this , all these techniques have to do two basic functions .The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .", "label": "", "metadata": {}, "score": "71.97786"}
{"text": "Background .There are numerous ways to parse input from files , the command line , or elsewhere .Despite this , all these techniques have to do two basic functions .The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .", "label": "", "metadata": {}, "score": "71.97786"}
{"text": "Background .There are numerous ways to parse input from files , the command line , or elsewhere .Despite this , all these techniques have to do two basic functions .The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .", "label": "", "metadata": {}, "score": "71.97786"}
{"text": "Background .There are numerous ways to parse input from files , the command line , or elsewhere .Despite this , all these techniques have to do two basic functions .The first action to be performed is understanding the structure of the input , ensuring that it meets the specification laid down for that input .", "label": "", "metadata": {}, "score": "71.97786"}
{"text": "In the Spirit framework , the addition of semantic actions is very simple .After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .", "label": "", "metadata": {}, "score": "72.832184"}
{"text": "In the Spirit framework , the addition of semantic actions is very simple .After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .", "label": "", "metadata": {}, "score": "72.832184"}
{"text": "In the Spirit framework , the addition of semantic actions is very simple .After any part of any rule in the definition of the grammar , you can add a semantic action .This semantic action will be called whenever that particular part of the rule has been successfully matched .", "label": "", "metadata": {}, "score": "72.832184"}
{"text": "( and , on a meta - level , it is philosophically interesting : mapping a meta - language using meta - language constructs ) .If my instincts do n't cheat on me , Spirit is great if you regularly work with changing / different grammars .", "label": "", "metadata": {}, "score": "72.91939"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The Spirit framework can pass them around by value quite a lot , so do n't load them down with loads of member variables unless you want to take a hit on the speed of parsing .The functor should really be seen as a point of communication between the parser and the rest of your application .", "label": "", "metadata": {}, "score": "73.10194"}
{"text": "The reason that C++ works for me as a language is quite simply that it does everything .If you need to get down and dirty in the memory you have the tools to do it .If you need to write high performance software then you have the tools to do it .", "label": "", "metadata": {}, "score": "73.480354"}
{"text": "Jun Suzuki and Hideki Isozaki .Semi - supervised sequential labeling and segmentation using giga - word scale unlabeled data .In ACL - HLT .Jun Suzuki et al .2009 .An empirical study of semi - supervised structured conditional models for dependency parsing .", "label": "", "metadata": {}, "score": "74.02193"}
{"text": "What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .In the context of a parser , semantic actions are the code that gets called each time you have successfully figured out part of the input .", "label": "", "metadata": {}, "score": "74.094765"}
{"text": "What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .In the context of a parser , semantic actions are the code that gets called each time you have successfully figured out part of the input .", "label": "", "metadata": {}, "score": "74.094765"}
{"text": "What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .In the context of a parser , semantic actions are the code that gets called each time you have successfully figured out part of the input .", "label": "", "metadata": {}, "score": "74.094765"}
{"text": "What are semantic actions ?Semantics is the science of extracting meaning from something , so it follows that semantic actions involve carrying out actions based on the meaning of something .In the context of a parser , semantic actions are the code that gets called each time you have successfully figured out part of the input .", "label": "", "metadata": {}, "score": "74.094765"}
{"text": "In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .In that article , I created the necessary code to successfully parse the input for a simple modular arithmetic calculator .", "label": "", "metadata": {}, "score": "74.19794"}
{"text": "In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .In that article , I created the necessary code to successfully parse the input for a simple modular arithmetic calculator .", "label": "", "metadata": {}, "score": "74.19794"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Other operator nodes are largely similar .Adding Semantic Actions to a Spirit Parser .The preparatory work of defining composites and visitors for the expression tree have prepared us for doing the important work of adding semantic actions to our existing calculator parser .", "label": "", "metadata": {}, "score": "74.318665"}
{"text": "Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .An example used to process a comma separated list of signed integers is : .This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .", "label": "", "metadata": {}, "score": "75.49356"}
{"text": "Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .An example used to process a comma separated list of signed integers is : .This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .", "label": "", "metadata": {}, "score": "75.49356"}
{"text": "Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .An example used to process a comma separated list of signed integers is : .This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .", "label": "", "metadata": {}, "score": "75.49356"}
{"text": "Spirit goes one step further by allowing semantic actions to be attached to any part of the rule .An example used to process a comma separated list of signed integers is : .This section of code states that the integers rule is defined as a single integer followed by zero or more additional integers , separated with commas .", "label": "", "metadata": {}, "score": "75.49356"}
{"text": "Comments and Discussions . ... and i 'm posting this message simply because i 'm tired to be in the middle of believers .Paradigms ( and patterns ) are not themself \" solutions \" .If respecting a patten makes a solution too tricky to be undertanded ... that 's the time to move to another pattern .", "label": "", "metadata": {}, "score": "76.214134"}
{"text": "I really liked the stream libraries and templates .It took the standards committee until the late 90s to actually standardise these things , and it has taken until now ( and beyond ) for compilers to actually start becoming compliant .", "label": "", "metadata": {}, "score": "76.2801"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "The code produced for this article relies on both the boost::spirit library and the Loki library .Both of these libraries should be installed and set in your include path for the code to compile .Furthermore , due to the cutting edge language features that both these libraries rely on , the code will only compile on Visual C++ 7.1 or later .", "label": "", "metadata": {}, "score": "80.86147"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "My 3 favourite reference books are : Design Patterns , Gamma et al ; The C++ Standard Library , Josuttis ; and Computer Graphics , Foley et al . .Outside computers , I am also the drummer in a band , The Unbelievers and we have just released our first album .", "label": "", "metadata": {}, "score": "81.337204"}
{"text": "General News Suggestion Question Bug Answer Joke Praise Rant Admin .Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .Noun phrases ( NPs ) are a crucial part of natural language , exhibiting in many cases an extremely complex structure .", "label": "", "metadata": {}, "score": "82.31364"}
{"text": "Comments and Discussions .Yacc , ( at least Bison , anyway ) has supported this for a very long time .Many people , however , only put them at the end .But thanks for the excellent article .It provided the impetus to give Spirit a try , since a usable OO , re - entrant Bison / Flex solution continues to evade the native Windows domain .", "label": "", "metadata": {}, "score": "83.74803"}
{"text": "In the NTCIR6 CLQA2 evaluation , our system achieved 19 % and 13 % accuracy in the Engl ... \" .In this paper , we describe the JAVELIN Cross Language Question Answering system , which includes modules for question analysis , keyword translation , document retrieval , information extraction and answer generation .", "label": "", "metadata": {}, "score": "84.96154"}
{"text": "Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .Introduction .In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .", "label": "", "metadata": {}, "score": "85.48308"}
{"text": "Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .Introduction .In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .", "label": "", "metadata": {}, "score": "85.48308"}
{"text": "Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .Introduction .In my last Code Project article , An Introduction to the Boost Spirit Parser framework , I introduced some basic concepts of the boost::spirit parser framework .", "label": "", "metadata": {}, "score": "85.48308"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "[ Private::AddParent ( self.m_parser , & COperatorMultiply::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorDivide::Create ) ] . ) term .[ Private::AddParent ( self.m_parser , & COperatorPlus::Create ) ] .[ Private::AddParent ( self.m_parser , & COperatorMinus::Create ) ] . )", "label": "", "metadata": {}, "score": "92.008026"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "License .This article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves .If in doubt please contact the author via the discussion board below .Share .About the Author .", "label": "", "metadata": {}, "score": "98.03248"}
{"text": "In SIAM Data Mining .", "label": "", "metadata": {}, "score": "100.29437"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "I went on to study Engineering and Computer Science at Oxford University , getting a first and the University Prize for the best results in Computer Science .Since then I have worked in a variety of roles , involving systems management and development management on a wide variety of platforms .", "label": "", "metadata": {}, "score": "112.61629"}
{"text": "All rights reserved .Access to this work is provided for the purposes of personal research and study .Except where permitted under the Copyright Act 1968 , this work must not be copied or communicated to others without the express permission of the copyright owner .", "label": "", "metadata": {}, "score": "163.44406"}
