{"text": "Substring Decompositions .[0044 ] .In other words , each pair of consecutive element names in a substring of p is separated by a parent - child ( \" / \" ) operator .We use Path(s ) to denote the path of nodes in the XPE - tree of p that defines the substring s. [ 0045 ] .", "label": "", "metadata": {}, "score": "26.588737"}
{"text": "The substrings of the simple decomposition of p i can be organized into a unique rooted tree , referred as the \" substring - tree \" of p i , as follows .The ordering among sibling sub - strings is based on their ordering in S i .", "label": "", "metadata": {}, "score": "28.669592"}
{"text": "[ 0064 ] .[0065 ] .Each row in ST ( corresponding to some substring s i , j ) is a 5-tuple ( ParentRow , RelLevel , Rank , NumChild , Next ) , where : . [ 0066 ] .", "label": "", "metadata": {}, "score": "31.470911"}
{"text": "0081 ] .The XTrieSEARCH algorithm ( depicted in FIG .4 ) begins by initializing the search node N to be the root node of the trie T ( line 5 ) .On the other hand , if no edge is out of a node N with the current tag t , this means that the concatenation of label(N ) and t is not a matching substring .", "label": "", "metadata": {}, "score": "31.69254"}
{"text": "FIG .84 shows an example of a sub - tree corresponding to the data in Table 1 .In this figure , to each node the start point of the corresponding substring ( in the circle ) and the code value of the substring ( below the circle ) are assigned .", "label": "", "metadata": {}, "score": "31.707859"}
{"text": "FIG .84 shows an example of a sub - tree corresponding to the data in Table 1 .In this figure , to each node the start point of the corresponding substring ( in the circle ) and the code value of the substring ( below the circle ) are assigned .", "label": "", "metadata": {}, "score": "31.707859"}
{"text": "Let Q be the set of base clusters ; .This function S(q ) may then be used in the combining of clusters outlined below .Some embodiments may include sorting the compacted trie so as to order the nodes within the trie .", "label": "", "metadata": {}, "score": "32.511955"}
{"text": "Let Q be the set of base clusters ; .This function S(q ) may then be used in the combining of clusters outlined below .Some embodiments may include sorting the compacted trie so as to order the nodes within the trie .", "label": "", "metadata": {}, "score": "32.511955"}
{"text": "The associated subquery selectivities are then multiplied based on the independence assumption as follows : .Pr . abc .Pr . ab .Pr .c .Pr . ab .Pr .c .An alternative method known in the prior art is denoted \" k - d count - suffix trees \" ( or \" KD \" ) , in which each node corresponds to substring combinations from each dimension , and each node is augmented with the substring counts .", "label": "", "metadata": {}, "score": "32.718834"}
{"text": "It is possible , but nontrivial , to design concatenation sequences that violate this .The substring operation is performed differently depending on the tree node representing the root of the rope .The operation is recursive : .For a leaf node , we either return a leaf node with the substring , or if that would be too long , we return a subscript node .", "label": "", "metadata": {}, "score": "33.424828"}
{"text": "It is possible , but nontrivial , to design concatenation sequences that violate this .The substring operation is performed differently depending on the tree node representing the root of the rope .The operation is recursive : .For a leaf node , we either return a leaf node with the substring , or if that would be too long , we return a subscript node .", "label": "", "metadata": {}, "score": "33.424828"}
{"text": "2C shows the substring - tree for the simple decomposition in FIG .2B. A substring that has no child substrings is called a leaf substring .Similarly , s i , k , is said to be an \" ancestor \" of s i , j if s i , j is a descendant of s i , k .", "label": "", "metadata": {}, "score": "34.796524"}
{"text": "Each edge is assigned a label , and each end node corresponds to each trailing string of a substring .Connecting the labels of the paths , from the root to an end node , comprises a trailing string .FIG .", "label": "", "metadata": {}, "score": "34.80589"}
{"text": "Each edge is assigned a label , and each end node corresponds to each trailing string of a substring .Connecting the labels of the paths , from the root to an end node , comprises a trailing string .FIG .", "label": "", "metadata": {}, "score": "34.80589"}
{"text": "Node Interval Identification Process !In this embodiment , it is also possible to identify an interval corresponding to a node th a t is specified .The procedure explained below identifies the position of an interval .A right interval or a left interval ( total interval ) means that the specified interval is on the right or on the left of the root interval .", "label": "", "metadata": {}, "score": "35.724026"}
{"text": "Node Interval Identification Process !In this embodiment , it is also possible to identify an interval corresponding to a node th a t is specified .The procedure explained below identifies the position of an interval .A right interval or a left interval ( total interval ) means that the specified interval is on the right or on the left of the root interval .", "label": "", "metadata": {}, "score": "35.724026"}
{"text": "[ 0072 ] .The trie T is a rooted tree constructed from the set of distinct substrings S , where each edge in T is labeled with some element name .In addition to the pointers to nodes at the next level of the trie , each node N in T has two special pointers : . [", "label": "", "metadata": {}, "score": "35.850998"}
{"text": "For each i in the range 0 .The start position may be updated as in ( g ) .( 3 ) Re - arranging index items .Note that an index item whose key - candidate substring ( leading string of a trailing string ) was updated in ( b ) of ( 2 ) and which must be re - arranged is already determined in ( 1 ) .", "label": "", "metadata": {}, "score": "36.046318"}
{"text": "If , in addition , s i , j is a leaf substring , then a matching of p i occurs ( line 9 ) .For the general case where s i , j is a non - root substring ( lines 10 - 14 ) , if a non - redundant matching of s i , j exists ( line 11 ) , then B[r , l ] is updated to 1 .", "label": "", "metadata": {}, "score": "36.418076"}
{"text": "A binary search tree is conveniently used in the binary search method .In this method , a substring at the center of a code string is used as the root node .Each node is assigned a substring range data as well as the code value of the substring .", "label": "", "metadata": {}, "score": "36.638306"}
{"text": "A binary search tree is conveniently used in the binary search method .In this method , a substring at the center of a code string is used as the root node .Each node is assigned a substring range data as well as the code value of the substring .", "label": "", "metadata": {}, "score": "36.638306"}
{"text": "A binary search tree is conveniently used in the binary search method .In this method , a substring at the center of a code string is used as the root node .Each node is assigned a substring range data as well as the code value of the substring .", "label": "", "metadata": {}, "score": "36.638306"}
{"text": "The following explains how each function is implemented .First , a \" text item \" defined by ( t1 ) is implemented as a node .A key - candidate substring is a one - character substring consisting only of a code stored in the node .", "label": "", "metadata": {}, "score": "36.80569"}
{"text": "( Partial interval length of the left child of n ) .( In the case of the floating - point format : . and if : .( In the case of the floating - point format : . then , n is a node corresponding to the interval containing the specified position .", "label": "", "metadata": {}, "score": "37.04068"}
{"text": "( Partial interval length of the left child of n ) .( In the case of the floating - point format : . and if : .( In the case of the floating - point format : . then , n is a node corresponding to the interval containing the specified position .", "label": "", "metadata": {}, "score": "37.04068"}
{"text": "This can be said regardless of the presence of the right or left child , when n is the root node .For example , in the binary tree in FIG .22 , the node corresponding to the interval containing the specified position 8 is identified by following the nodes as shown in FIGS .", "label": "", "metadata": {}, "score": "37.243156"}
{"text": "This can be said regardless of the presence of the right or left child , when n is the root node .For example , in the binary tree in FIG .22 , the node corresponding to the interval containing the specified position 8 is identified by following the nodes as shown in FIGS .", "label": "", "metadata": {}, "score": "37.243156"}
{"text": "The function finds the number of substrings ( start positions ) which match the specified pattern or which match the leading string of the specified pattern for the longest length .This retrieving means may be implemented by combining the functions ( x5 ) and ( x8 ) of the index function described above and by adding 1 to the difference between lexicographic orders of the first and the last ones .", "label": "", "metadata": {}, "score": "37.295143"}
{"text": "[ 0080 ] .To understand how B is used to detect non - redundant matchings , suppose that a matching of substring s i , j at level l has been detected , and s i , j is the n th child substring of s i , k .", "label": "", "metadata": {}, "score": "37.35378"}
{"text": "Therefore , this structure , which consists of the nodes ( text items ) arranged in the order in which start positions are arranged in LCR order , implements the structure defined by ( t2 ) .The function ( t3 ) is implemented as follows .", "label": "", "metadata": {}, "score": "37.371403"}
{"text": "the end side of each node being connected to a preceding node corresponding to an interval preceding the interval of the node or to a following node corresponding to an interval following the interval of the node , . each node being assigned a partial interval length which is a sum of the interval length of the node itself and the interval length of at least one node in the end side of the node ; and .", "label": "", "metadata": {}, "score": "37.40574"}
{"text": "the end side of each node being connected to a preceding node corresponding to an interval preceding the interval of the node or to a following node corresponding to an interval following the interval of the node , . each node being assigned a partial interval length which is a sum of the interval length of the node itself and the interval length of at least one node in the end side of the node ; and .", "label": "", "metadata": {}, "score": "37.40574"}
{"text": "[ 0050 ] .The notion of relative level that was defined for nodes in XPE - trees will now be extended to substrings .Informally , the relative level of a substring s refers to the relative difference in levels between the last elements of s and its parent substring in a matching .", "label": "", "metadata": {}, "score": "37.801746"}
{"text": "If the substring operation is applied to either a very large leaf node ( which can be built by converting a very long C string to a rope ) or to a function node representing a long string , then it produces a substring node .", "label": "", "metadata": {}, "score": "37.89244"}
{"text": "If the substring operation is applied to either a very large leaf node ( which can be built by converting a very long C string to a rope ) or to a function node representing a long string , then it produces a substring node .", "label": "", "metadata": {}, "score": "37.89244"}
{"text": "A path from the root to a leaf via the node x corresponds to a suffix of the code string s with a character string generated from the root to the node x as a prefix .A directed acyclic word graph is a graph created by merging particular paths of a suffix tree .", "label": "", "metadata": {}, "score": "38.006927"}
{"text": "A path from the root to a leaf via the node x corresponds to a suffix of the code string s with a character string generated from the root to the node x as a prefix .A directed acyclic word graph is a graph created by merging particular paths of a suffix tree .", "label": "", "metadata": {}, "score": "38.006927"}
{"text": "A path from the root to a leaf via the node x corresponds to a suffix of the code string s with a character string generated from the root to the node x as a prefix .A directed acyclic word graph is a graph created by merging particular paths of a suffix tree .", "label": "", "metadata": {}, "score": "38.006927"}
{"text": "Note that a substring is higher than any of those to the left and is lower than any of those to the right .The bottom half of the figure shows how text is represented in the tree - structured format ( text tree ) , which is similar to the format of the dictionary tree structure .", "label": "", "metadata": {}, "score": "38.061947"}
{"text": "Thus , for each component , the minimal value of the signatures of all the sets in that component are chosen .First , a value \u03b3 is determined , knowing the largest sized set A j , as follows : .", "label": "", "metadata": {}, "score": "38.07982"}
{"text": "For example , if the strings are sorted lexicographically , the substrings are not necessarily ordered .In the extreme of presuming that all substrings are explicitly represented and the frequency of individual points is approximated in the multidimensional space using standard techniques , the domain would be so large and the frequencies so small as to render the techniques impractical .", "label": "", "metadata": {}, "score": "38.13864"}
{"text": "Therefore , the code at a specific position within a code string can be identified easily by comparing the specified position with the position and the interval length of each node .Thus , the interval position of a node can be calculated by the total of the interval lengths of the preceding ( following ) nodes .", "label": "", "metadata": {}, "score": "38.171955"}
{"text": "Therefore , the code at a specific position within a code string can be identified easily by comparing the specified position with the position and the interval length of each node .Thus , the interval position of a node can be calculated by the total of the interval lengths of the preceding ( following ) nodes .", "label": "", "metadata": {}, "score": "38.171955"}
{"text": "The notions of partial and redundant matchings can now be formally defined .A partial matching is represented by its set of matchings M i .[ 0056 ] .To define redundant matching , the notion of subtree - matching should first be introduced .", "label": "", "metadata": {}, "score": "38.263985"}
{"text": "This makes it easy to identify the specified node which is now the root , because the beginning position and the ending position are identified as follows .When changing an interval length , splaying is applied to the node whose interval length is to be changed to make the node the root node .", "label": "", "metadata": {}, "score": "38.461246"}
{"text": "This makes it easy to identify the specified node which is now the root , because the beginning position and the ending position are identified as follows .When changing an interval length , splaying is applied to the node whose interval length is to be changed to make the node the root node .", "label": "", "metadata": {}, "score": "38.461246"}
{"text": "[ 0078 ] .The basic idea of the search algorithm is as follows .The trie T is used to detect the occurrence of matching substrings as the input document is parsed .For each matching substring s detected , we iterate through all the instances of s in the indexed XPEs ( by traversing the appropriate linked list of rows in the substring - table ST associated with s ) to check if the matched substring s corresponds to any non - redundant matching .", "label": "", "metadata": {}, "score": "38.48413"}
{"text": "[ 0074 ] .The Max - suffix pointer ( denoted by \u03b2(N ) ) points to some internal node in T and its purpose is to ensure the correctness of the matching algorithm .[0075 ] .The number within each trie node N represents the node 's identifier ; and the values of \u03b1(N ) and \u03b2(N ) are shown to the left and right of N , respectively .", "label": "", "metadata": {}, "score": "38.510178"}
{"text": "Then , node R immediately after node X , which is to be deleted , is moved to the root through execution of splaying .FIG .65 shows how the binary tree looks like after node R , which immediately follows node X to be deleted , has been moved to the root through execution of splaying .", "label": "", "metadata": {}, "score": "38.562027"}
{"text": "Then , node R immediately after node X , which is to be deleted , is moved to the root through execution of splaying .FIG .65 shows how the binary tree looks like after node R , which immediately follows node X to be deleted , has been moved to the root through execution of splaying .", "label": "", "metadata": {}, "score": "38.562027"}
{"text": "14 is an another example of a flowchart of a procedure for identifying an interval corresponding to the specified node .In the procedure shown in FIG .13 , the left interval that is on the left of the specified node interval is determined , and the right side of the specified node interval is calculated based on the left interval length .", "label": "", "metadata": {}, "score": "38.680695"}
{"text": "( x7 )The function assigns sequence numbers ( lexicographic order ) to index items from start to last in order of ( x2 ) .( x8 )The function returns the lexicographic order of a specified index item .Combining the functions ( x5 ) and ( x8 ) gives us the number of matching substrings , as shown in the fifth embodiment described above .", "label": "", "metadata": {}, "score": "38.765823"}
{"text": "moves the nodes immediately preceding and following the position , at which a node is to be added , to said root by means of splaying one at a time , . adds said node corresponding to an interval , which is to be added , at the position immediately following said immediately - preceding node or at the position immediately before said immediately - following node , and . adds the interval length of the added node to the partial interval length of said immediately - preceding or immediately - following node or said added node , as necessary .", "label": "", "metadata": {}, "score": "38.78814"}
{"text": "moves the nodes immediately preceding and following the position , at which a node is to be added , to said root by means of splaying one at a time , . adds said node corresponding to an interval , which is to be added , at the position immediately following said immediately - preceding node or at the position immediately before said immediately - following node , and . adds the interval length of the added node to the partial interval length of said immediately - preceding or immediately - following node or said added node , as necessary .", "label": "", "metadata": {}, "score": "38.78814"}
{"text": "A position tree , one of these data structures , is a Trie which uses substring identifiers , each starting at each sequential position of the code string s , as character strings .A substring identifier is defined as the shortest unique character string starting at each sequential position .", "label": "", "metadata": {}, "score": "38.80739"}
{"text": "A matching of s i , j at level l in D is said to occur if s i , j matches at some node at level l in D. .[0054 ] .However , since only whether or not p i matches D is of interest , and not the actual number of match occurrences , \" partial matchings \" of p i that are \" redundant \" can be ignored to improve the effectiveness of the filtering process .", "label": "", "metadata": {}, "score": "38.814236"}
{"text": "The following explains the procedure for determining the first node ( upper limit ) of the nodes ( representing index items ) containing a trailing string having a leading string that matches the pattern for the longest length , by referring to FIG .", "label": "", "metadata": {}, "score": "38.84894"}
{"text": "[ 0083 ] .Algorithm PROPAGATE - UPDATE ( depicted in FIG .6 ) is used to update B whenever a non - redundant subtree - matching of some non - root substring ( S i , j matching at level l corresponding to row r in ST ) is detected .", "label": "", "metadata": {}, "score": "38.940674"}
{"text": "In this case , an index item may be inserted either immediately before or immediately after the determined position ( node ) .Of course , when there is no duplication , an item is added according to the procedure for inserting an item whose length is not limited .", "label": "", "metadata": {}, "score": "39.162903"}
{"text": "the Algorithm PROPAGATE - UPDATE updates the B entries of all the earlier matchings of s i , j ( lines 18 to 20 ) , and returns false .[ 0084 ] .The space requirement of the XTrie index is dominated by the total number of substrings in P ; that is , the space complexity is .", "label": "", "metadata": {}, "score": "39.219673"}
{"text": "When method ( 2 ) is used to \" restore a text \" , a node in the dictionary tree needs only to contain as many characters as the item contained in the corresponding node in the text tree , as shown in FIG .", "label": "", "metadata": {}, "score": "39.33339"}
{"text": "[ 9 - 3 .Index Retrieval Function ] .An index is the whole data structure shown in FIG .42 , and an \" index item \" defined by ( x1 ) corresponds to one node .The function ( x3 ) is implemented as follows .", "label": "", "metadata": {}, "score": "39.388226"}
{"text": "[ B-4 - 1 .Changing the Interval Length ] .When the length of an interval is changed , the partial interval length of each node , from that node to the root , is changed by the changed value .", "label": "", "metadata": {}, "score": "39.43814"}
{"text": "e ) parsing a given query q on each dimension k into a plurality of subqueries available in the suffix tree ; .f ) for each combination of subqueries created in step e ) , retrieving associated hash signature ; . g ) performing an intersection of said hash signature to generate cross counts ; and .", "label": "", "metadata": {}, "score": "39.588036"}
{"text": "The interval length of the preceding ( following ) nodes can be obtained from the partial interval length of the left ( right ) child .Therefore , the code at a specific position within a code can be identified easily by comparing the specified position with the position and the interval length of each node .", "label": "", "metadata": {}, "score": "39.613182"}
{"text": "the end side of each node being connected to a preceding node corresponding to an interval preceding the interval of the node or to a following node corresponding to an interval following the interval of the node , . each node being assigned a partial interval length which is the sum of the interval length of the node itself and the interval length of at least one node on the end side of the node , and .", "label": "", "metadata": {}, "score": "39.65589"}
{"text": "the end side of each node being connected to a preceding node corresponding to an interval preceding the interval of the node or to a following node corresponding to an interval following the interval of the node , . each node being assigned a partial interval length which is the sum of the interval length of the node itself and the interval length of at least one node on the end side of the node , and .", "label": "", "metadata": {}, "score": "39.65589"}
{"text": "Rope_RopeSubstring )Substring nodes .These contain a pointer to a base rope tree node , and a starting position within that rope .They denote a substring of the base rope .These are generated only to represent substrings of ropes that are expensive to compute explicitly .", "label": "", "metadata": {}, "score": "39.752434"}
{"text": "Rope_RopeSubstring )Substring nodes .These contain a pointer to a base rope tree node , and a starting position within that rope .They denote a substring of the base rope .These are generated only to represent substrings of ropes that are expensive to compute explicitly .", "label": "", "metadata": {}, "score": "39.752434"}
{"text": "This extended key is used as the key .The key may be extended simply in the comparison procedure used to add or retrieve a key to or from the dictionary tree , without having to change the configuration of nodes .", "label": "", "metadata": {}, "score": "39.7671"}
{"text": "When this process is repeated until the last character of the trailing string is processed ( step 47 ) , a sequence of edges , consisting of all the characters of the trailing string as its labels , is created .Then , the end pointer pointing to the end of the substring is set in the current node at this time ( step 48 ) .", "label": "", "metadata": {}, "score": "39.82673"}
{"text": "When this process is repeated until the last character of the trailing string is processed ( step 47 ) , a sequence of edges , consisting of all the characters of the trailing string as its labels , is created .Then , the end pointer pointing to the end of the substring is set in the current node at this time ( step 48 ) .", "label": "", "metadata": {}, "score": "39.82673"}
{"text": "The second edge connects two trailing string nodes , one of which is longer than the other by one code .This code may be used as a label in the second edge ( FIG .16 ) .This structure allows the contents of a substring to be restored by connecting labels while going up from the end node with a pointer through the second edge .", "label": "", "metadata": {}, "score": "39.845"}
{"text": "The second edge connects two trailing string nodes , one of which is longer than the other by one code .This code may be used as a label in the second edge ( FIG .16 ) .This structure allows the contents of a substring to be restored by connecting labels while going up from the end node with a pointer through the second edge .", "label": "", "metadata": {}, "score": "39.845"}
{"text": "We start with a generalized suffix tree for sequences $ S$ and $ T$. Each internal node with suffixes of both $ S$ and $ T$ in its subtree corresponds to some common substring of the sequences .Let us call such nodes non - trivial .", "label": "", "metadata": {}, "score": "39.941193"}
{"text": "According to an invention as claimed in claims 6 and 41 , the number of second edges from an end node without a pointer to an end node with a pointer equals the difference between the positions of two trailing strings corresponding to the two nodes .", "label": "", "metadata": {}, "score": "40.16589"}
{"text": "According to an invention as claimed in claims 6 and 41 , the number of second edges from an end node without a pointer to an end node with a pointer equals the difference between the positions of two trailing strings corresponding to the two nodes .", "label": "", "metadata": {}, "score": "40.16589"}
{"text": "Note that the node b ( if node b exists ) has been reached in the binary search process before the node a is reached .The binary search method used for implementing the function ( x3 ) is not limited to the one described above .", "label": "", "metadata": {}, "score": "40.29351"}
{"text": "FIG .7 is a diagram of an example compacted suffix tree 700 .This compacted suffix tree 700 may have a number of properties .A further property of this compacted suffix tree 700 may be that the path from a leaf node to the root node , and the edges along this path , may be combined to form a string or substring .", "label": "", "metadata": {}, "score": "40.342194"}
{"text": "FIG .7 is a diagram of an example compacted suffix tree 700 .This compacted suffix tree 700 may have a number of properties .A further property of this compacted suffix tree 700 may be that the path from a leaf node to the root node , and the edges along this path , may be combined to form a string or substring .", "label": "", "metadata": {}, "score": "40.342194"}
{"text": "This is achieved by using an array Node to keep track of the location of the search node at each document level ( line 12 ) .[ 0082 ] .Algorithm MATCH - SUBSTRING ( FIG .5 ) is invoked when a substring s ( matching at level l ) is detected .", "label": "", "metadata": {}, "score": "40.360218"}
{"text": "Before taking a look at the data structure shown in FIG .2 , see Table 2 .It shows the key - candidate substrings , contained in the dictionary data 2 , which can be used in retrieving a substring of the length 3 or less .", "label": "", "metadata": {}, "score": "40.59778"}
{"text": "This removal ends when there a node having an edge or a pointer to a trailing string except that is connected to the removed node or pointer is encountered .Data may be added to the tree according to the procedure shown in FIG .", "label": "", "metadata": {}, "score": "40.613846"}
{"text": "This removal ends when there a node having an edge or a pointer to a trailing string except that is connected to the removed node or pointer is encountered .Data may be added to the tree according to the procedure shown in FIG .", "label": "", "metadata": {}, "score": "40.613846"}
{"text": "Referring to node n 11 of the tree of FIG .5 ( a ) , S 11 is illustrated as comprising the substring ab , which occurs in RIDs 1 , 2 and 4 , as defined for the above - identified data set .", "label": "", "metadata": {}, "score": "40.626686"}
{"text": "For example , when ( a node representing ) a new interval x is inserted to the left of the interval represented by node f of the tree in FIG .67 , the tree is first changed to the one shown in FIG .", "label": "", "metadata": {}, "score": "40.65261"}
{"text": "For example , when ( a node representing ) a new interval x is inserted to the left of the interval represented by node f of the tree in FIG .67 , the tree is first changed to the one shown in FIG .", "label": "", "metadata": {}, "score": "40.65261"}
{"text": "FIG .56 shows an example of a binary search tree corresponding to the data in Table 1 .In this figure , each node is assigned the start point of the corresponding substring ( in the circle ) and the code value of the substring ( below the circle ) .", "label": "", "metadata": {}, "score": "40.71872"}
{"text": "The following details the data structure in FIG .2 .The top half of the figure shows how substrings are represented in the dictionary in the tree - structured format ( dictionary tree ) .That is , lexicographically - arranged ( arranged in the lexicographic order ) key - candidate substrings shown here are equivalent to those shown in Table 2 .", "label": "", "metadata": {}, "score": "40.8395"}
{"text": "The partial interval length of the node to be added is calculated by adding the length of the new interval to the partial interval lengths of the right and left children ( claim 28 ) .For example , FIG .57 shows a part of the binary tree before an interval is added through splaying .", "label": "", "metadata": {}, "score": "40.840595"}
{"text": "The partial interval length of the node to be added is calculated by adding the length of the new interval to the partial interval lengths of the right and left children ( claim 28 ) .For example , FIG .57 shows a part of the binary tree before an interval is added through splaying .", "label": "", "metadata": {}, "score": "40.840595"}
{"text": "Advantageously , therefore , longer parses can be used , with less reliance on probabilistic estimation formulas and more accurate selectivity estimation .In particular , the methodology of the present invention first requires that an \" unpruned \" suffix tree be built for the substrings in each dimension .", "label": "", "metadata": {}, "score": "40.91624"}
{"text": "The following summarizes the text retrieval and code restoration function .( t1 )A text item consists of a key - candidate substring ( leading string of a trailing string ) and its start position .( t2 )A text consists of text items arranged in order of their start positions .", "label": "", "metadata": {}, "score": "40.939594"}
{"text": "Suppose that the variable P contains the specified position and that the variable n contains a pointer pointing to the current node ( hereafter , the current node is represented by n ) .While this process , the substantial specified position in the whole tree is not changed .", "label": "", "metadata": {}, "score": "40.959312"}
{"text": "Suppose that the variable P contains the specified position and that the variable n contains a pointer pointing to the current node ( hereafter , the current node is represented by n ) .While this process , the substantial specified position in the whole tree is not changed .", "label": "", "metadata": {}, "score": "40.959312"}
{"text": "A data processing system as claimed in claim 1 , further comprising an identifying means for identifying an interval corresponding to a specified node which is any given node in said binary tree , wherein the identifying means .moves the current node , pointed to by a pointer , from said specified node toward the parent node , which is a higher - level node , of said current node , one node level at a time , until said root is reached , .", "label": "", "metadata": {}, "score": "40.991013"}
{"text": "A data processing system as claimed in claim 1 , further comprising an identifying means for identifying an interval corresponding to a specified node which is any given node in said binary tree , wherein the identifying means .moves the current node , pointed to by a pointer , from said specified node toward the parent node , which is a higher - level node , of said current node , one node level at a time , until said root is reached , .", "label": "", "metadata": {}, "score": "40.991013"}
{"text": "[ B-3 .Interval Identification ] .In the data processing system using the interval control method , it is also possible to identify an interval corresponding to a node that is specified .A right interval or a left interval ( total interval ) means that the specified interval is on the right or on the left of the root interval .", "label": "", "metadata": {}, "score": "41.055054"}
{"text": "The right end of the specified node is obtained by adding the net interval length of the specified node to the left interval length ( step 138 ) .This end is represented by the value of the partial interval length of the root .", "label": "", "metadata": {}, "score": "41.07711"}
{"text": "This is the string that \" spells \" the path from the root of the ith suffix tree to its jth node .Each node n ij in each suffix tree is then augmented with set S ij , where S ij contains the row identifiers ( RIDs ) of each tuple containing w ij as a substring in the ith dimension .", "label": "", "metadata": {}, "score": "41.0856"}
{"text": "That is , deletion of a text item ( node ) means that the first character ( one character stored in the node ) of ( the leading string of ) the trailing string is deleted from the code string .The functions ( p1 ) and ( p2 ) are implemented by combining an index item and a text item , each containing a trailing string starting in the same position , into one node in the data structure shown in FIG .", "label": "", "metadata": {}, "score": "41.121895"}
{"text": "The following explains how difficult it is to efficiently process a substring with the use of a simple example .In this example , suppose that a code string contains characters whose values are 0 , 1 , or N and that , in most cases , the same code value occurs continuously .", "label": "", "metadata": {}, "score": "41.366844"}
{"text": "16 ! respectively , connected with node B as the root .To the end side of node B , node A corresponding to the interval 1 . . .3 ! which precedes node B and nodes D , C , and E corresponding to the intervals which follow node B are connected .", "label": "", "metadata": {}, "score": "41.460644"}
{"text": "16 ! respectively , connected with node B as the root .To the end side of node B , node A corresponding to the interval 1 . . .3 ! which precedes node B and nodes D , C , and E corresponding to the intervals which follow node B are connected .", "label": "", "metadata": {}, "score": "41.460644"}
{"text": "Any known method for adding a node may be used instead .And , to each node on the path from the parent of the new node to the root , the adding means 42 adds the length of the new interval .", "label": "", "metadata": {}, "score": "41.581543"}
{"text": "The method as defined in .claim 4 wherein in performing step a ) each suffix tree is pruned to remove nodes with counts below a predetermined threshold .The method as defined in .claim 4 wherein in performing step e ) maximal overall parsing is used .", "label": "", "metadata": {}, "score": "41.588314"}
{"text": "A node in the dictionary tree contains , not a key itself , but a pointer to the corresponding node in the text tree .Comparing the substrings before insertion ( bca-456 , abc-345 ) with those after insertion ( bba-456 , abb-345 ) indicates that the pointers remains unchanged .", "label": "", "metadata": {}, "score": "41.608364"}
{"text": "Let us assume the document d x of Cluster C i has a collection of m phrases P x1 , P x2 , . . ., P xn which are strongly present .In some embodiments , a CLE Tags approach is implemented wherein tags or phrases are extracted that represent important concepts within a cluster .", "label": "", "metadata": {}, "score": "41.63105"}
{"text": "Let us assume the document d x of Cluster C i has a collection of m phrases P x1 , P x2 , . . ., P xn which are strongly present .In some embodiments , a CLE Tags approach is implemented wherein tags or phrases are extracted that represent important concepts within a cluster .", "label": "", "metadata": {}, "score": "41.63105"}
{"text": "A data processing system as claimed in claim 5 , wherein said adding means adds said node corresponding to said interval , which is to be added , to said binary tree , . adjusts the connection sequence of said nodes , and . adjusts said partial interval length of each node .", "label": "", "metadata": {}, "score": "41.662155"}
{"text": "A data processing system as claimed in claim 5 , wherein said adding means adds said node corresponding to said interval , which is to be added , to said binary tree , . adjusts the connection sequence of said nodes , and . adjusts said partial interval length of each node .", "label": "", "metadata": {}, "score": "41.662155"}
{"text": "( b ) Update the key - candidate substring ( leading string of a trailing string ) , as in step ( a ) , for an index item whose start position is P-1 or lower .This may be done concurrently with step ( a ) by obtaining the corresponding index item with the use of the function ( p2 ) .", "label": "", "metadata": {}, "score": "41.693928"}
{"text": "In addition , the binary search method can not be used because information about a particular interval gives us only the information about the length of the interval .A linear list may be used instead . of using a consecutive area ; this makes it possible to connect non - consecutive areas through pointers ( fourth method ) .", "label": "", "metadata": {}, "score": "41.77732"}
{"text": "( k2 )The function finds the start positions of all the substrings which match the specified pattern or which match the leading string of the specified pattern for the longest length .This retrieving means may be implemented by combining the functions ( x4 ) , ( x5 ) , and ( x6 ) of the index function described above .", "label": "", "metadata": {}, "score": "41.785236"}
{"text": "On the other hand , if an adjacent node does not have a right child , that adjacent node is determined as the node immediately preceding a specified node ( that is , the node on the left adjacent side ) .", "label": "", "metadata": {}, "score": "42.045673"}
{"text": "In addition , the binary search method can not be used because information about a particular interval gives us only the information about the length of the interval .A linear list may be used instead of using a consecutive area ; this makes it possible to connect non - consecutive areas through pointers ( fourth method ) .", "label": "", "metadata": {}, "score": "42.04668"}
{"text": "In addition , the binary search method can not be used because information about a particular interval gives us only the information about the length of the interval .A linear list may be used instead of using a consecutive area ; this makes it possible to connect non - consecutive areas through pointers ( fourth method ) .", "label": "", "metadata": {}, "score": "42.04668"}
{"text": "And , the positional relation among nodes can be represented by the relation among nodes , the position of each node being calculated by the partial interval length of other nodes .This means that a change in part of an interval affects only the changed node and one or more nodes on the path from that node to the root , thus simplifying the change procedure .", "label": "", "metadata": {}, "score": "42.07325"}
{"text": "In this type of application , editing is performed as for a character string .The following explains how difficult it is to efficiently process a substring with the use of a simple example .In this example , suppose that a code string contains characters whose values are 0 , 1 , or N and that , in most cases , the same code value occurs continuously .", "label": "", "metadata": {}, "score": "42.10545"}
{"text": "In this type of application , editing is performed as for a character string .The following explains how difficult it is to efficiently process a substring with the use of a simple example .In this example , suppose that a code string contains characters whose values are 0 , 1 , or N and that , in most cases , the same code value occurs continuously .", "label": "", "metadata": {}, "score": "42.10545"}
{"text": "The right end of the specified node is obtained by adding the net interval length of the specified node to the left interval length ( step 288 ) .This end is represented by the value of the partial interval length of the root .", "label": "", "metadata": {}, "score": "42.244858"}
{"text": "The right end of the specified node is obtained by adding the net interval length of the specified node to the left interval length ( step 288 ) .This end is represented by the value of the partial interval length of the root .", "label": "", "metadata": {}, "score": "42.244858"}
{"text": "18 ! and 19 . . .19 ! , respectively , the new node is added in one of three ways shown in FIGS .36 , 37 , and 38 .And , to each node on the path from the parent of the new node to the root , the adding means 43 adds the length of the new interval .", "label": "", "metadata": {}, "score": "42.342743"}
{"text": "18 ! and 19 . . .19 ! , respectively , the new node is added in one of three ways shown in FIGS .36 , 37 , and 38 .And , to each node on the path from the parent of the new node to the root , the adding means 43 adds the length of the new interval .", "label": "", "metadata": {}, "score": "42.342743"}
{"text": "A suffix trie is a rooted directed tree ; .Each internal node has at least 2 children ; .Trie : Each edge is labeled with a non - empty substring of S. The label of a node is a concatenation of the labels of the edges on the path from the root to that node ; .", "label": "", "metadata": {}, "score": "42.361313"}
{"text": "A suffix trie is a rooted directed tree ; .Each internal node has at least 2 children ; .Trie : Each edge is labeled with a non - empty substring of S. The label of a node is a concatenation of the labels of the edges on the path from the root to that node ; .", "label": "", "metadata": {}, "score": "42.361313"}
{"text": "Therefore , as compared with a method in which dictionary data 5 and 6 is re - generated , the update time is reduced .Maintaining the Boundary Interval and Substring Length !When the length of a substring is changed ( step 72 ) , the length of the substring is adjusted before updating dictionary data ( step 73 ) .", "label": "", "metadata": {}, "score": "42.547462"}
{"text": "Therefore , as compared with a method in which dictionary data 5 and 6 is re - generated , the update time is reduced .Maintaining the Boundary Interval and Substring Length !When the length of a substring is changed ( step 72 ) , the length of the substring is adjusted before updating dictionary data ( step 73 ) .", "label": "", "metadata": {}, "score": "42.547462"}
{"text": "Although data is retrieved in the first to fifth embodiments through a match in the leading string based on the trailing string in the substring , data may also be retrieved through a match in the trailing string based on the leading string .", "label": "", "metadata": {}, "score": "42.6579"}
{"text": "Although data is retrieved in the first to fifth embodiments through a match in the leading string based on the trailing string in the substring , data may also be retrieved through a match in the trailing string based on the leading string .", "label": "", "metadata": {}, "score": "42.6579"}
{"text": "Increasing the Efficiency in Comparing Keys ( Code Strings ) at Index Retrieval Time ] in the sixth embodiment are possible .The function ( x4 ) is implemented as follows .This is done by a function , provided by the interval control method , which calculates the position of an interval representing the node in the binary search tree .", "label": "", "metadata": {}, "score": "42.830032"}
{"text": "If it is possible for a plurality of nodes to contain an address generated from the same character string , a character string to be stored in each node may be included in each address .That is , as shown in FIG .", "label": "", "metadata": {}, "score": "42.861168"}
{"text": "9 .Once received , an operation 1502 is executed that determines how to label each node of the graph using , for example , a CLE BD or , for example , a CLE Tags approach .Next , an operation 1503 is executed that extracts phrase data ( e.g. , strings or substrings ) from documents associated with nodes .", "label": "", "metadata": {}, "score": "42.86125"}
{"text": "9 .Once received , an operation 1502 is executed that determines how to label each node of the graph using , for example , a CLE BD or , for example , a CLE Tags approach .Next , an operation 1503 is executed that extracts phrase data ( e.g. , strings or substrings ) from documents associated with nodes .", "label": "", "metadata": {}, "score": "42.86125"}
{"text": "This means that first character \" a \" of the dictionary item \" ab \" is in position 6 .In method ( 2 ) , because node Y corresponds to the interval consisting only of position 5 , node Z corresponding to the next interval is retrieved in the same manner .", "label": "", "metadata": {}, "score": "42.86159"}
{"text": "This process determines the position of the specified node through the interval lengths of nodes those are right or left to the specified node .This simple procedure provided in the sixth embodiment allows the position of the specified node to be identified , making it possible to perform various types of processing ( claims 20 , 47 ) .", "label": "", "metadata": {}, "score": "43.13175"}
{"text": "This process determines the position of the specified node through the interval lengths of nodes those are right or left to the specified node .This simple procedure provided in the sixth embodiment allows the position of the specified node to be identified , making it possible to perform various types of processing ( claims 20 , 47 ) .", "label": "", "metadata": {}, "score": "43.13175"}
{"text": "On the other hand , the interval control method may be used to determine an interval which is indicated by a specified node , that is , the start position of the text item corresponding to the specified node .This capability implements the function ( t7 ) .", "label": "", "metadata": {}, "score": "43.180862"}
{"text": "Since an index binary search tree and a text binary search tree are structured in the same manner ( procedure ) , ( x6 ) is implemented in the same manner as ( t6 ) .To implement the function ( x5 ) effectively , \" ( 1 - 2 ) Unit function ( x5 ) implementation \" shown in the seventh embodiment is used .", "label": "", "metadata": {}, "score": "43.18317"}
{"text": "moves the added node to the root of said binary tree by means of splaying , and . increases the partial interval length of the node , moved to the root , by the interval length of the added interval .A data processing system as claimed in claim 5 , wherein said deleting means deletes from said binary tree said node of said interval to be deleted , . adjusts the connection among the nodes , and . adjusts said partial interval length of each node .", "label": "", "metadata": {}, "score": "43.219723"}
{"text": "moves the added node to the root of said binary tree by means of splaying , and . increases the partial interval length of the node , moved to the root , by the interval length of the added interval .A data processing system as claimed in claim 5 , wherein said deleting means deletes from said binary tree said node of said interval to be deleted , . adjusts the connection among the nodes , and . adjusts said partial interval length of each node .", "label": "", "metadata": {}, "score": "43.219723"}
{"text": "This operation changes the partial interval lengths of nodes c , b , and a , indicated by bold circles , as follows : .When splaying is executed , the binary tree is restructured by changing the pointers that link the data items contained in the nodes .", "label": "", "metadata": {}, "score": "43.288677"}
{"text": "This operation changes the partial interval lengths of nodes c , b , and a , indicated by bold circles , as follows : .When splaying is executed , the binary tree is restructured by changing the pointers that link the data items contained in the nodes .", "label": "", "metadata": {}, "score": "43.288677"}
{"text": "[0079 ] .Each B[r i , j , l ] is initialized to 0 , and is incremented to 1 after a non - redundant matching of s i , j at level l is detected .The value of B[r i , j , l ] is reset to 0 when the end - tag corresponding to the begin - tag at level l is parsed .", "label": "", "metadata": {}, "score": "43.355904"}
{"text": "This embodiment simplifies the dictionary tree 4 and the text tree 8 and thus reduces the storage area with the use of the dictionary tree generating means 5 and text tree generating means 9 shown in FIG .1 .That is , in this embodiment , only the substrings -- leading strings -- that are likely to be retrieved are registered in the dictionary ; those substrings not likely to be retrieved are not registered .", "label": "", "metadata": {}, "score": "43.400864"}
{"text": "2 shows a data structure which can be used in retrieving a substring of the length 3 or less .In this figure , the top half shows the structure of the dictionary ( dictionary tree 4 ) and the bottom half shows the structure of the text ( text tree 8) .", "label": "", "metadata": {}, "score": "43.40454"}
{"text": "Again , in this case , when the position of a substring s changed , it is necessary to change all the data following the change point .It is also possible to store pairs , each consisting of a code value and the length of a substring where that code consecutively occurs , in a consecutive storage area in the order in which substrings appear ( third method ) .", "label": "", "metadata": {}, "score": "43.413345"}
{"text": "Again , in this case , when the position of a substring s changed , it is necessary to change all the data following the change point .It is also possible to store pairs , each consisting of a code value and the length of a substring where that code consecutively occurs , in a consecutive storage area in the order in which substrings appear ( third method ) .", "label": "", "metadata": {}, "score": "43.413345"}
{"text": "Again , in this case , when the position of a substring s changed , it is necessary to change all the data following the change point .It is also possible to store pairs , each consisting of a code value and the length of a substring where that code consecutively occurs , in a consecutive storage area in the order in which substrings appear ( third method ) .", "label": "", "metadata": {}, "score": "43.413345"}
{"text": "When the leading string of the central item does not match that of the pattern , the function moves the lower - limit mark to the item , as shown in FIG .41(C ) .Performing this binary search repeatedly until the last - matching - item mark comes next to the lower - limit mark enables the last matching index item to be determined efficiently .", "label": "", "metadata": {}, "score": "43.59278"}
{"text": "When a code string is given , the retrieving means in this embodiment retrieves items from the index according to the following steps .( 1 ) Initialize the values as follows : .Upper limit.rarw.Start of the index .", "label": "", "metadata": {}, "score": "43.71699"}
{"text": "\" For example , the XPE /a / b//c selects all c element descendants of all b elements that are direct children of the root element a in the document .[ 0033 ] .Each location step can also include one or more predicates to further refine the selected set of nodes .", "label": "", "metadata": {}, "score": "43.75102"}
{"text": "The text function ( t12 ) is used to add this text item .The interval control method is used to update the start position efficiently as in ( e ) .Delete an index item whose start position is between P+k and P+n-1 from the index , and subtract n - k from the start positions of all index items whose start position is P+n or higher .", "label": "", "metadata": {}, "score": "43.75331"}
{"text": "When the current node becomes the root ( step 132 ) , the left end of the specified node is immediately left to the left interval ; that is , it is calculated by adding 1 to the left interval length ( step 137 ) .", "label": "", "metadata": {}, "score": "43.77617"}
{"text": "If the reference counts of all tree nodes on the path from a rope R 's root node to the leaf node L holding a specific character are 1 , then L occurs exactly once in R , and in no other rope .", "label": "", "metadata": {}, "score": "43.936558"}
{"text": "If the reference counts of all tree nodes on the path from a rope R 's root node to the leaf node L holding a specific character are 1 , then L occurs exactly once in R , and in no other rope .", "label": "", "metadata": {}, "score": "43.936558"}
{"text": "Thus , the following is observed for any i : .The goal of the method of the present invention is to extract intersection size ( i.e. , the response to the cross - count approximation ) using set hashing . where \u03c1 is the \" set resemblance \" between A and B , as defined above .", "label": "", "metadata": {}, "score": "43.956554"}
{"text": "The function finds the start position of a substring which matches the specified pattern or which matches the leading string of the specified pattern for the longest length ( This means is used also to determine if such a substring is present ) .", "label": "", "metadata": {}, "score": "43.991173"}
{"text": "When the position of a substring is changed , only one pointer need be changed and , so , the processing speed is higher than that of the first embodiment where as many pointers as the number of end nodes must be changed .", "label": "", "metadata": {}, "score": "44.085205"}
{"text": "When the position of a substring is changed , only one pointer need be changed and , so , the processing speed is higher than that of the first embodiment where as many pointers as the number of end nodes must be changed .", "label": "", "metadata": {}, "score": "44.085205"}
{"text": "In one embodiment , a Suffix Tree Clustering ( STC ) algorithm is implemented .Example embodiments may include an implementation of an STC algorithm building a suffix trie using the terms in documents that are to be divided into groups of clusters based upon the commonality of phrases in the documents .", "label": "", "metadata": {}, "score": "44.157112"}
{"text": "In one embodiment , a Suffix Tree Clustering ( STC ) algorithm is implemented .Example embodiments may include an implementation of an STC algorithm building a suffix trie using the terms in documents that are to be divided into groups of clusters based upon the commonality of phrases in the documents .", "label": "", "metadata": {}, "score": "44.157112"}
{"text": "Then , the j - th code from the beginning of line i begins at a position in the whole text represented by the following formula .( i-1)\u00d7n+j Formula 53 !FIG .74 is an example of a binary tree representing the above text with n being 10 .", "label": "", "metadata": {}, "score": "44.205536"}
{"text": "Then , the j - th code from the beginning of line i begins at a position in the whole text represented by the following formula .( i-1)\u00d7n+j Formula 53 !FIG .74 is an example of a binary tree representing the above text with n being 10 .", "label": "", "metadata": {}, "score": "44.205536"}
{"text": "This further reduces the space needed to store character strings .This problem may be solved by extending a key in the dictionary tree .Because the substrings in the dictionary are sorted lexicographically and because a position in the text enables the key beginning in that position to be restored ( assuming that the length is known ) , the extended key is functionally equivalent to the pointer explained above .", "label": "", "metadata": {}, "score": "44.30049"}
{"text": "Then , splaying is executed to move the added node to the root of the binary tree , and the partial interval length of the node moved to the root is increased by the net interval length of the added interval ( claim 29 ) .", "label": "", "metadata": {}, "score": "44.30707"}
{"text": "Then , splaying is executed to move the added node to the root of the binary tree , and the partial interval length of the node moved to the root is increased by the net interval length of the added interval ( claim 29 ) .", "label": "", "metadata": {}, "score": "44.30707"}
{"text": "This structure allows the contents of a substring to be restored by connecting labels while going up from the end node with a pointer to the root through the second edge .An invention according to claim 8 is a data retrieval system as claimed in claim 1 or 3 , wherein the retrieving means outputs the number of codes matching the key string for a trailing string obtained as a result of retrieval .", "label": "", "metadata": {}, "score": "44.308983"}
{"text": "This structure allows the contents of a substring to be restored by connecting labels while going up from the end node with a pointer to the root through the second edge .An invention according to claim 8 is a data retrieval system as claimed in claim 1 or 3 , wherein the retrieving means outputs the number of codes matching the key string for a trailing string obtained as a result of retrieval .", "label": "", "metadata": {}, "score": "44.308983"}
{"text": "3 , a node in the dictionary tree contains , not a key itself , but a pointer to the corresponding node in the text tree .After the character has been changed , the relation between the dictionary tree and the text tree is as shown in FIG .", "label": "", "metadata": {}, "score": "44.35771"}
{"text": "However , in this method , the retrieval time increases in proportion to the length of the character string s. .A position tree ( Majster , M. et . al . 1980 ) , suffix tree ( McCreght , E. 1976 ) , and directed acyclic word graph ( Blumer , A. et . al .", "label": "", "metadata": {}, "score": "44.4162"}
{"text": "2 shows an example of a code string which is divided into the first substrings sli ( sll to s14 ) and into the second substrings s2i ( s21 to s24 ) .Dictionary Data Generation Process !The generating means 7 generates dictionary data 5 and 6 for each substring 2 and substring 3 .", "label": "", "metadata": {}, "score": "44.42115"}
{"text": "2 shows an example of a code string which is divided into the first substrings sli ( sll to s14 ) and into the second substrings s2i ( s21 to s24 ) .Dictionary Data Generation Process !The generating means 7 generates dictionary data 5 and 6 for each substring 2 and substring 3 .", "label": "", "metadata": {}, "score": "44.42115"}
{"text": "In this case , since each sub - key string can be found unless divided by one or more boundaries , k is the maximum length of a sub - key string .This reduces k , making dictionary data compact .", "label": "", "metadata": {}, "score": "44.43074"}
{"text": "In this case , since each sub - key string can be found unless divided by one or more boundaries , k is the maximum length of a sub - key string .This reduces k , making dictionary data compact .", "label": "", "metadata": {}, "score": "44.43074"}
{"text": "While the adjacent node has a right child , step 445 and step 446 are repeated .On the other hand , in step 445 , if an adjacent node does not have a right child , that adjacent node is determined as the node immediately preceding a specified node ( that is , the node on the left adjacent side ) .", "label": "", "metadata": {}, "score": "44.526543"}
{"text": "This processing is applicable when the first boundary and the second boundary are reversed .When the length of a substring is changed , the position in the code string pointed to by the pointer , contained in dictionary data 5 and 6 ( tree ) , is changed .", "label": "", "metadata": {}, "score": "44.56702"}
{"text": "This processing is applicable when the first boundary and the second boundary are reversed .When the length of a substring is changed , the position in the code string pointed to by the pointer , contained in dictionary data 5 and 6 ( tree ) , is changed .", "label": "", "metadata": {}, "score": "44.56702"}
{"text": "[ B-1 .Generating a Binary Tree ] .First , the binary tree generating means 32 generates the binary tree 31 representing the range of each interval according to the intervals in the code string .The binary tree may also be generated , with the use of the adding means 42 , by adding a node each time an interval is entered .", "label": "", "metadata": {}, "score": "44.63623"}
{"text": "Each of these two Xtrie components will now be described in detail .[0062 ] .The Substring - Table .[ 0063 ] .The rows in ST are physically clustered in terms of the XPEs such that the substrings belonging to an XPE p are stored in consecutive rows ordered based on the simple decomposition of p. The order of the XPEs in ST is arbitrary .", "label": "", "metadata": {}, "score": "44.781998"}
{"text": "This embodiment also has the changing means 11 for changing the code string 1 and the updating means 12 for updating , based on the change , the index 21 and the text 23 of the code string associated with the change .", "label": "", "metadata": {}, "score": "44.795193"}
{"text": "The function determines the relation ( before / after ) of two specified index items .This function may be implemented by ( x8 ) , but other implementations may also be possible .The following explains , more in detail , how unit functions ( x3 ) and ( x5 ) are implemented .", "label": "", "metadata": {}, "score": "44.80073"}
{"text": "Thus , the set hashing technique is useful in three- , four- and other multidimensional situations , since only an intersection function is required .A method of preprocessing a multidimensional data set comprising a plurality of N data elements in the form of tuples to create a pruned suffix tree structure including hashing signatures to represent each node in the pruned suffix tree , the method comprising the steps of : . a ) creating a suffix tree for each dimension of data in an n - dimensional data set , forming a plurality of n suffix trees ; .", "label": "", "metadata": {}, "score": "44.81146"}
{"text": "FIG .1 contains a prior art diagram of pruned suffix trees ( PSTs ) for a four element data set on two dimensions ; .FIG .2 illustrates different known art parsing arrangements that can be used with the data of FIG .", "label": "", "metadata": {}, "score": "44.83669"}
{"text": "When this occurs , the value of this element is recorded as a component value in the signature vector S A .A predefined number of \" throws \" are used to create a signature of a desired length .This process is then repeated ( using the exact same throws ) for each dimension to generate the associated signature vector .", "label": "", "metadata": {}, "score": "44.868614"}
{"text": "Description of the Prior Art ] .Various data processing systems have been devised heretofore to find all the appearance positions of a specified key string ( pattern ) in a code string such as a character string .FIG .47 shows the pattern p which is found in the character string s. A code string retrieval technique may be applied to dictionaries and indexes ; more specifically , it is applied to the pattern matching in a text editor , text database , and voice recognition , to pattern analysis in such fields as DNA study , or to substitutional coding .", "label": "", "metadata": {}, "score": "44.899113"}
{"text": "57 .Then , node X is added with node L being the left child and immediately - following node R being the right child .FIG .59 shows how the binary tree looks like after the interval has been added through splaying .", "label": "", "metadata": {}, "score": "44.901638"}
{"text": "57 .Then , node X is added with node L being the left child and immediately - following node R being the right child .FIG .59 shows how the binary tree looks like after the interval has been added through splaying .", "label": "", "metadata": {}, "score": "44.901638"}
{"text": "c ) pruning each suffix tree to remove nodes with a row identifier count below a predetermined value ; .d ) hashing , for each node in each pruned suffix tree , the row identifiers to generate , a fixed - length signature for the associated node ; and .", "label": "", "metadata": {}, "score": "44.9375"}
{"text": "Increasing the Efficiency in Comparing Keys ( Code Strings ) at Index Retrieval Time ] may be used to compare one key - candidate substring ( leading string of a trailing string ) with another efficiently .Note that the method described in [ 6 - 2 - 2 .", "label": "", "metadata": {}, "score": "44.94053"}
{"text": "In one embodiment , threshold \" t \" is computed by taking the weighted average of the relevancy scores of all the clusters and keeps only the clusters whose relevancy score is less than the threshold \" t \" .In a further embodiment , the clusters are sorted in ascending order based on the relevancy score and the top \" N \" clusters based on the relevancy score are kept and remaining clusters are removed from consideration .", "label": "", "metadata": {}, "score": "44.95111"}
{"text": "In one embodiment , threshold \" t \" is computed by taking the weighted average of the relevancy scores of all the clusters and keeps only the clusters whose relevancy score is less than the threshold \" t \" .In a further embodiment , the clusters are sorted in ascending order based on the relevancy score and the top \" N \" clusters based on the relevancy score are kept and remaining clusters are removed from consideration .", "label": "", "metadata": {}, "score": "44.95111"}
{"text": "One exemplary prior art technique for estimating cross - counts of string data is based on a variant of suffix trees and is referred to as the \" count - suffix trees \" method , where each node in the tree is augmented with the count of occurrences of its associated substring .", "label": "", "metadata": {}, "score": "44.95246"}
{"text": "In addition , because a sequence of a plurality of the same character or a sequence of blanks are represented by a single node with the character as the label and with the interval length represented by the number of consecutive characters , processing and memory efficiency are increased .", "label": "", "metadata": {}, "score": "44.980103"}
{"text": "In addition , because a sequence of a plurality of the same character or a sequence of blanks are represented by a single node with the character as the label and with the interval length represented by the number of consecutive characters , processing and memory efficiency are increased .", "label": "", "metadata": {}, "score": "44.980103"}
{"text": "4 .Therefore , when one or more characters are added to the text , this embodiment significantly reduces the time needed to update the dictionary .Interval Control Method .[ A. Configuration ] .In addition , the data processing system has the structure adjusting means 45 for adjusting the structure of a binary tree by changing the connection sequence of the nodes .", "label": "", "metadata": {}, "score": "45.027084"}
{"text": "The predicates can be applied to the text or the attributes of the addressed elements , and may also include other path expressions .Any relative paths in a predicate expression are evaluated in the context of the element nodes addressed in the location step at which they appear .", "label": "", "metadata": {}, "score": "45.08871"}
{"text": "The net interval length of a node can be calculated by subtracting the total of the interval lengths of the preceding and following nodes from the partial interval length of the node .Therefore , the code at a specific position within a code can be identified easily by comparing the specified position with the position and the interval length of each node .", "label": "", "metadata": {}, "score": "45.159588"}
{"text": "The net interval length of a node can be calculated by subtracting the total of the interval lengths of the preceding and following nodes from the partial interval length of the node .Therefore , the code at a specific position within a code can be identified easily by comparing the specified position with the position and the interval length of each node .", "label": "", "metadata": {}, "score": "45.159588"}
{"text": "It also prevents the rope from being destructively updated while the iterator must remain valid .I am trying to use suffix trees to compare string sequences .I have found implementations / theory for the longest common sub string problem using suffix trees .", "label": "", "metadata": {}, "score": "45.187256"}
{"text": "For example , FIG .54 shows an example in which an interval of code value 1 [ 6 . . .8 ] is inserted immediately after the code value N at position 5 ( address A+4 ) .This insertion involves a sequence of operations ; that is , data at addresses A+5 to A+15 must be moved to addresses A+8 to A+18 .", "label": "", "metadata": {}, "score": "45.219505"}
{"text": "This method does not require to reference both the dictionary and the text linked together by pointers ; it combines these types of nodes two into one , thus eliminating the need for the pointers and saving storage .FIG .27 shows the dictionary in the top , and the text in the bottom .", "label": "", "metadata": {}, "score": "45.221172"}
{"text": "If the current node is the right child , the parent node of the current node is set as adjacent node ( step 437 ) .That is , the parent node of the current node is determined as the node immediately preceding a specified node ( that is , the node on the left adjacent side ) .", "label": "", "metadata": {}, "score": "45.227135"}
{"text": "End of the index .Upper - limit matching leading - string length.rarw.0 .Lower - limit matching leading - string length.rarw.0 .( 2 ) Let a trailing string smaller than the upper limit and larger than the lower limit be \" s \" .", "label": "", "metadata": {}, "score": "45.240906"}
{"text": "In the second embodiment , data about a code string is represented as follows : character sequence data is represented by the structure of the tree , character position data is represented by pointers , and those pointers are integrated .This enables character sequence data and character position data to be separate , allowing an algorithm most suitable for each data to be used .", "label": "", "metadata": {}, "score": "45.246136"}
{"text": "In the second embodiment , data about a code string is represented as follows : character sequence data is represented by the structure of the tree , character position data is represented by pointers , and those pointers are integrated .This enables character sequence data and character position data to be separate , allowing an algorithm most suitable for each data to be used .", "label": "", "metadata": {}, "score": "45.246136"}
{"text": "So , the configuration ( t1 ) allows the next function which is equal to ( x4 ) .( t7 )The function determines the start position of the leading string of the trailing string , in the given text item .", "label": "", "metadata": {}, "score": "45.30768"}
{"text": "FIG .5 .At position 604 in a hash table 600 , the substring \" Opener \" is illustrated as is the set containing documents 1 , 0 , and the set containing documents 4 , 1 .This substring opener roughly corresponds to node 16 referenced as 515 in .", "label": "", "metadata": {}, "score": "45.407143"}
{"text": "FIG .5 .At position 604 in a hash table 600 , the substring \" Opener \" is illustrated as is the set containing documents 1 , 0 , and the set containing documents 4 , 1 .This substring opener roughly corresponds to node 16 referenced as 515 in .", "label": "", "metadata": {}, "score": "45.407143"}
{"text": "Specifically , I have a problem in which i need to first find the longest common substring , then find the next longest common substring that does not include the already found lcs indices , and so on until a minimum length .", "label": "", "metadata": {}, "score": "45.42016"}
{"text": "One may , for example , compute a relevancy score for each cluster , and keep those clusters that are appropriate for the current input query .This concept of pruning may be illustrated in the following manner .For a phrase P , several demand attributes may be used for demand factor analysis .", "label": "", "metadata": {}, "score": "45.45935"}
{"text": "One may , for example , compute a relevancy score for each cluster , and keep those clusters that are appropriate for the current input query .This concept of pruning may be illustrated in the following manner .For a phrase P , several demand attributes may be used for demand factor analysis .", "label": "", "metadata": {}, "score": "45.45935"}
{"text": "Both the partial matchings of s 3 at c 9 and s 2 at b 10 are redundant .Observe that a non - redundant matching could later become redundant as more nodes in the document tree are parsed ; in particular , the non - redundant matching of s 2 at b 3 becomes redundant after d 7 is parsed .", "label": "", "metadata": {}, "score": "45.472496"}
{"text": "Pr . min .A . ) min .B . )A .B .A .B .It is to be noted that the same permutation is used for each set .Then , for any given set A , the signature vector is generated from the permutation \u03c0 1 , \u03c0 2 , . . .", "label": "", "metadata": {}, "score": "45.5197"}
{"text": "The ordering of the child nodes for each parent node is based on their order of appearance in the XPE .Such a tree representation of an XPE is referred to as an \" XPE - tree .\" [ 0035 ] .", "label": "", "metadata": {}, "score": "45.536167"}
{"text": "Data structures that have been used in data retrieval , such as a position tree , suffix tree , or directed acyclic word graph , are based on the Trie described above .A position tree , one of data structures , is a Trie which uses substring identifiers , each starting at each sequential position of the code string s , as character strings .", "label": "", "metadata": {}, "score": "45.725"}
{"text": "Data structures that have been used in data retrieval , such as a position tree , suffix tree , or directed acyclic word graph , are based on the Trie described above .A position tree , one of data structures , is a Trie which uses substring identifiers , each starting at each sequential position of the code string s , as character strings .", "label": "", "metadata": {}, "score": "45.725"}
{"text": "4 .A node in the dictionary tree contains , not a key itself , but a pointer to the corresponding node in the text tree .Comparing the substrings before deletion ( bba-456 , abb-345 ) with those after deletion ( bca-456 , abc-345 ) indicates that the pointers to the nodes in the text tree remain unchanged .", "label": "", "metadata": {}, "score": "45.755264"}
{"text": "When an intermediate character in the text is changed , comparison is performed as follows .Assume that there is a changed position and an adjustment range in the text as shown in FIG .37 and that an trailing string starting in the changed position or in the adjustment range is not registered in the index .", "label": "", "metadata": {}, "score": "45.76554"}
{"text": "The net interval length of a node can be calculated by subtracting the total of the interval lengths of the preceding and following nodes , contained in the sub - tree connected to the node , from the partial interval length of the node .", "label": "", "metadata": {}, "score": "45.777554"}
{"text": "The net interval length of a node can be calculated by subtracting the total of the interval lengths of the preceding and following nodes , contained in the sub - tree connected to the node , from the partial interval length of the node .", "label": "", "metadata": {}, "score": "45.777554"}
{"text": "An approach for multidimensional substring selectivity estimation utilizes set hashing to generate cross - counts as needed , instead of storing cross - counts for the most frequently co - occurring substrings .Set hashing is a Monte Carlo technique that is used to succinctly represent the set of tuples containing a given substring .", "label": "", "metadata": {}, "score": "45.781624"}
{"text": "A plurality of structure adjustment methods are known .Any of them may be used .Partial interval lengths should be adjusted as the tree structure is changed according to the structure adjustment method to be used .The length of a path from the root to a node is usually made proportional to the logarithm of the total number of nodes through structure adjustment .", "label": "", "metadata": {}, "score": "45.78666"}
{"text": "A plurality of structure adjustment methods are known .Any of them may be used .Partial interval lengths should be adjusted as the tree structure is changed according to the structure adjustment method to be used .The length of a path from the root to a node is usually made proportional to the logarithm of the total number of nodes through structure adjustment .", "label": "", "metadata": {}, "score": "45.78666"}
{"text": "In the above data retrieval system or data processing system , the length of a key - candidate substring , which is an entry of the index , may or may not be limited .A text used on the above data retrieval system or data processing system may be represented by the addresses of contiguous storage locations where the code string is stored .", "label": "", "metadata": {}, "score": "45.880127"}
{"text": "This is because ( x3 ) is more efficient than ( x5 ) and because ( x8 ) which gives us lexicographic order numbers is more efficient than ( x6 ) .When only one or two of the functions ( k1 ) , ( k2 ) , and ( k3 ) are required , the retrieving means should include the index functions and their procedures specific to those functions .", "label": "", "metadata": {}, "score": "45.894276"}
{"text": "In the identified node , n represents 8-(3 - 0)+1 . . .8+(4 - 0 - 3 ) !( FIG .27 ) .As described above , in the data processing system in the sixth embodiment , the interval retrieving means 33 compares the specified position with the range of the current node while moving the current node downward , one level at a time , from the root .", "label": "", "metadata": {}, "score": "45.901344"}
{"text": "In the identified node , n represents 8-(3 - 0)+1 . . .8+(4 - 0 - 3 ) !( FIG .27 ) .As described above , in the data processing system in the sixth embodiment , the interval retrieving means 33 compares the specified position with the range of the current node while moving the current node downward , one level at a time , from the root .", "label": "", "metadata": {}, "score": "45.901344"}
{"text": "This does not require a subsequent check on the subsequent portion of each substring in the text .[ 3 - 2 - 2 .Index Configuration Procedure ] .When registering a substring of any length into the index ( that is , when registering all the trailing strings that may be used for leading string retrieval ) , it is natural that the trailing strings should be registered sequentially with the shortest first .", "label": "", "metadata": {}, "score": "45.90593"}
{"text": "Similar trends can be observed for other data sets , with the conclusion that it suffices to use log N bits , where N is the total number of tuples in the data set .In general , multidimensional substring queries are increasingly common in emerging database applications that process text data .", "label": "", "metadata": {}, "score": "45.909"}
{"text": "A data processing method as claimed in claim 21 , wherein said binary tree updating process comprises : . an interval length changing process for changing said interval length ; . a deleting process for deleting said node corresponding to a deleted interval from said binary tree when said interval is deleted ; and . an adding process for adding a node corresponding to an added interval when an interval is added .", "label": "", "metadata": {}, "score": "45.913914"}
{"text": "A data processing method as claimed in claim 21 , wherein said binary tree updating process comprises : . an interval length changing process for changing said interval length ; . a deleting process for deleting said node corresponding to a deleted interval from said binary tree when said interval is deleted ; and . an adding process for adding a node corresponding to an added interval when an interval is added .", "label": "", "metadata": {}, "score": "45.913914"}
{"text": "In addition , notice that the character string \" ab \" is common to a plurality of nodes in the dictionary tree in FIG .23 .So , by storing the character string only in one node ( or fewer nodes ) as shown in FIG .", "label": "", "metadata": {}, "score": "45.93625"}
{"text": "14 shows an example of a substring in the first embodiment of this invention ; .FIG .15 shows an example of a substring in the first embodiment of this invention ; .FIG .16 shows an example of a suffix tree in the second embodiment of this invention ; .", "label": "", "metadata": {}, "score": "46.03971"}
{"text": "14 shows an example of a substring in the first embodiment of this invention ; .FIG .15 shows an example of a substring in the first embodiment of this invention ; .FIG .16 shows an example of a suffix tree in the second embodiment of this invention ; .", "label": "", "metadata": {}, "score": "46.03971"}
{"text": "The length of a path from the root to a node is usually proportional to the logarithm of the total number of nodes .For this reason , the time required for processing , such as retrieval , interval length adjustment , and structure adjustment , is approximately proportional to the logarithm of the total number of intervals .", "label": "", "metadata": {}, "score": "46.064026"}
{"text": "For example , floating - point numbers may be processed easily .Again , in this method , when the length of a substring ( interval ) or the number of substrings is changed , it is necessary to re - write all the substring data that follow the changed position .", "label": "", "metadata": {}, "score": "46.06993"}
{"text": "For example , floating - point numbers may be processed easily .Again , in this method , when the length of a substring ( interval ) or the number of substrings is changed , it is necessary to re - write all the substring data that follow the changed position .", "label": "", "metadata": {}, "score": "46.06993"}
{"text": "For example , floating - point numbers may be processed easily .Again , in this method , when the length of a substring ( interval ) or the number of substrings is changed , it is necessary to re - write all the substring data that follow the changed position .", "label": "", "metadata": {}, "score": "46.06993"}
{"text": "An index item is a part consisting of a key - candidate substring ( leading string of a trailing string ) and its start position .( x2 )An index consists of the index items arranged lexicographically by key - candidate substring ( leading string of trailing string ) .", "label": "", "metadata": {}, "score": "46.090572"}
{"text": "This makes it possible to identify the address of a particular code value by performing usual calculation ( add , subtract , multiply , and divide ) .That is , if the start address of storage where the code string is stored is A , then the address where the code value of a position is stored is calculated as follows : .", "label": "", "metadata": {}, "score": "46.107277"}
{"text": "The difference is the processing ( operation time ) involved in creating indexes from the text and in updating the index as part of the text is changed .That is , a longer key should require a longer comparison time , because the index is basically a binary tree that is formed by comparing the key - candidate substrings , as shown in FIG .", "label": "", "metadata": {}, "score": "46.109344"}
{"text": "5 .In particular , reference is made to FIG .8 which includes the PSTs for the same data set in two dimensions as discussed above with FIG .5 .In the example as illustrated in FIG .8 , the various signatures S ij for each node are also shown , where the hash function relationship as illustrated in FIGS . 7 ( a ) and 7 ( b ) may be used to generate the signatures for each node .", "label": "", "metadata": {}, "score": "46.130356"}
{"text": "[ 2 - 2 - 3 .Combining the dictionary and the text ] .As indicated by the two - head arrows in FIG .23 , there is a one - to - one correspondence between the nodes in the dictionary tree and the nodes in the text tree .", "label": "", "metadata": {}, "score": "46.15943"}
{"text": "The following method is also possible to determine an index item ( trailing string ) having the longest leading string that matches the leading string of a pattern .( a )First , the function searches , in binary search mode , the index for an index item whose first character matches the first character of the pattern .", "label": "", "metadata": {}, "score": "46.162624"}
{"text": "18 shows an example of a substring used in the fourth embodiment .In the fourth embodiment like this , any part within the length of k is never divided by the first boundary and the second boundary at the same time .", "label": "", "metadata": {}, "score": "46.18158"}
{"text": "18 shows an example of a substring used in the fourth embodiment .In the fourth embodiment like this , any part within the length of k is never divided by the first boundary and the second boundary at the same time .", "label": "", "metadata": {}, "score": "46.18158"}
{"text": "This may also be done concurrently with step ( c ) by obtaining the corresponding index item with the use of the function ( p2 ) .When n.noteq.k , processing described in ( g ) and ( h ) below is necessary .", "label": "", "metadata": {}, "score": "46.229286"}
{"text": "putting the changes into one unit of adjustment work , . wherein said step of retrieving includes the step of counting a number of substrings , each containing an identical leading string , using the sequence numbers of a first dictionary data item and a last dictionary data item .", "label": "", "metadata": {}, "score": "46.258728"}
{"text": "That is , to identify a range of consecutive codes of the same value , it is necessary to read code values , one at a time , and to count the number of code values .( 3 ) A change in the length of a substring as a result of insertion or removal causes the addresses of all the data following the insertion or removal point to be increased or decreased .", "label": "", "metadata": {}, "score": "46.27746"}
{"text": "The following explains the unit function ( x5 ) which performs the binary search to determine the last such index item .When the leading string of the central item in the range match that of the pattern , the function marks the item to indicate that the item is the last - matching - item , as shown in FIG .", "label": "", "metadata": {}, "score": "46.313057"}
{"text": "The dictionary tree and the text tree are associated with the pointers .Scanning the text tree allows the text to be restored at any start position .Therefore , if a node in the dictionary tree contains only a pointer to the corresponding node in the text tree , there is no need to store a key - candidate substring .", "label": "", "metadata": {}, "score": "46.35031"}
{"text": "When the function ( x13 ) is executed , the deletion procedure is used to delete a node , which represents an index item , from the index binary search tree .In this case , the left half of the structure ( including the code ) shown in FIG .", "label": "", "metadata": {}, "score": "46.35518"}
{"text": "7 illustrates the use of hashing functions to create signature vectors for a pair of data sets , as well as the process step used to compare the signature vectors ; .FIG .8 is a reconfiguration of the pruned suffix trees ( PSTs ) of FIG .", "label": "", "metadata": {}, "score": "46.37941"}
{"text": "The leading string of a trailing string may be specified as a code string ; preferably , it should be specified as a text item containing the leading string of the trailing string .This will be detailed later .Configuration and function of a text .", "label": "", "metadata": {}, "score": "46.39767"}
{"text": "A binary tree representing text may be configured in the data processing system in which text consisting of a plurality of lines is held .That is , the first binary tree represents the sequence of lines .This binary tree contains a plurality of nodes , each corresponding to a line , with the interval length of each node being 1 .", "label": "", "metadata": {}, "score": "46.40043"}
{"text": "A binary tree representing text may be configured in the data processing system in which text consisting of a plurality of lines is held .That is , the first binary tree represents the sequence of lines .This binary tree contains a plurality of nodes , each corresponding to a line , with the interval length of each node being 1 .", "label": "", "metadata": {}, "score": "46.40043"}
{"text": "This is a time - consuming process .For example , FIG .82 shows an example in which an interval of code value 1 6 . . .8 ! is inserted immediately after the code value N at position 5 ( address A+4 ) .", "label": "", "metadata": {}, "score": "46.40611"}
{"text": "This is a time - consuming process .For example , FIG .82 shows an example in which an interval of code value 1 6 . . .8 ! is inserted immediately after the code value N at position 5 ( address A+4 ) .", "label": "", "metadata": {}, "score": "46.40611"}
{"text": "If there is no overlap in tags , then cluster quality is 1 .If cluster themes overlap then the tags are shared .Some embodiments may include cluster quality as defined in terms of the category distribution of the items in a cluster .", "label": "", "metadata": {}, "score": "46.50227"}
{"text": "If there is no overlap in tags , then cluster quality is 1 .If cluster themes overlap then the tags are shared .Some embodiments may include cluster quality as defined in terms of the category distribution of the items in a cluster .", "label": "", "metadata": {}, "score": "46.50227"}
{"text": "This means that a change in part of an interval affects only the changed node and one or more nodes on the path from that node to the root , thus simplifying the change procedure .In particular , a binary tree in which data storage areas for the nodes are connected by pointers does not require a large consecutive area and therefore uses memory efficiently .", "label": "", "metadata": {}, "score": "46.517075"}
{"text": "This means that a change in part of an interval affects only the changed node and one or more nodes on the path from that node to the root , thus simplifying the change procedure .In particular , a binary tree in which data storage areas for the nodes are connected by pointers does not require a large consecutive area and therefore uses memory efficiently .", "label": "", "metadata": {}, "score": "46.517075"}
{"text": "For example , in node D , the sum ( 11 ) of the length ( 6 ) of the interval 10 . . .15 ! corresponding to node D and the total of the lengths ( 4 and 1 ) of the intervals 6 . . .", "label": "", "metadata": {}, "score": "46.54322"}
{"text": "For example , in node D , the sum ( 11 ) of the length ( 6 ) of the interval 10 . . .15 ! corresponding to node D and the total of the lengths ( 4 and 1 ) of the intervals 6 . . .", "label": "", "metadata": {}, "score": "46.54322"}
{"text": "This is because , once a text is restored , a key can be restored .Remember that a substring registered in the dictionary tree as a dictionary item ( key ) is a part of the text .Therefore , in a node in the dictionary tree , all the characters in the key need not to be stored ; only the characters required to restore the text need be stored .", "label": "", "metadata": {}, "score": "46.56727"}
{"text": "The referenced block of storage can either be part of a leaf in the rope representation , or it can be a small block of characters reserved inside the iterator itself .The latter is used when the iterator refers to a rope section represented by a function node .", "label": "", "metadata": {}, "score": "46.61821"}
{"text": "The referenced block of storage can either be part of a leaf in the rope representation , or it can be a small block of characters reserved inside the iterator itself .The latter is used when the iterator refers to a rope section represented by a function node .", "label": "", "metadata": {}, "score": "46.61821"}
{"text": "If n has a preceding node ( hereafter called a \" left child \" ) and if : .If P .( Hereafter , this format is called a floating - point format . ) then , the interval retrieving means 33 changes n to the left child of n. .", "label": "", "metadata": {}, "score": "46.62431"}
{"text": "If n has a preceding node ( hereafter called a \" left child \" ) and if : .If P .( Hereafter , this format is called a floating - point format . ) then , the interval retrieving means 33 changes n to the left child of n. .", "label": "", "metadata": {}, "score": "46.62431"}
{"text": "51 shows an example of a suffix tree .A suffix tree is the simplest form of a Trie .That is , a suffix tree is a tree structure in which the labels , each attached to a path from the root to a leaf ( end node ) , generate a suffix of the code string s. In a suffix tree , a leaf corresponds to the end of a suffix ( end of the code string s ) .", "label": "", "metadata": {}, "score": "46.644497"}
{"text": "A number to the left of each key is the lexicographic order of the substring .A number to the right is a pointer to the start position of the substring ; that is , this number is the start position of the substring when the characters in the code string are numbered sequentially from the leftmost position .", "label": "", "metadata": {}, "score": "46.64511"}
{"text": "Each secondary binary tree is associated with the corresponding node in the first binary tree through a pointer .FIG .73 shows a binary tree representing the following lines . xyz . st .( blank line ) .( blank line ) .", "label": "", "metadata": {}, "score": "46.70221"}
{"text": "Each secondary binary tree is associated with the corresponding node in the first binary tree through a pointer .FIG .73 shows a binary tree representing the following lines . xyz . st .( blank line ) .( blank line ) .", "label": "", "metadata": {}, "score": "46.70221"}
{"text": "In accordance with the present invention , a hash function is seeded for each signature vector component and the hash image h(a ) is generated for each element a \u03b5 A. The minimum h(a ) is then recorded in the signature .", "label": "", "metadata": {}, "score": "46.730324"}
{"text": "This keeps track of the number of rope variables , concatenation nodes , or substring nodes that reference the tree node .( We 'll see later that references from some iterators are also included . )When the reference count of a tree node becomes zero , the tree node is deallocated , and reference counts of any subtrees are correspondingly decremented .", "label": "", "metadata": {}, "score": "46.738663"}
{"text": "This keeps track of the number of rope variables , concatenation nodes , or substring nodes that reference the tree node .( We 'll see later that references from some iterators are also included . )When the reference count of a tree node becomes zero , the tree node is deallocated , and reference counts of any subtrees are correspondingly decremented .", "label": "", "metadata": {}, "score": "46.738663"}
{"text": "It is to be noted that the queries can specify any combination of exact , prefix , suffix , or proper substring matches .In order to optimize such queries , particularly multidimensional queries , it is often useful to obtain fast and accurate estimates for their result sizes .", "label": "", "metadata": {}, "score": "46.74266"}
{"text": "This means that the interval control method may be used to restore the leading string of a specified trailing string from a binary tree representing the text .In addition , the interval control method may be used to determine an interval which is indicated by a specified node , that is , the start position of the leading string of the trailing string corresponding to the specified node .", "label": "", "metadata": {}, "score": "46.77043"}
{"text": "Example of Structure Adjustment !The following shows splay tree ( splaying ) as an example of structure adjustment ( claim 34 ) , and explains how splaying changes the structure of a binary tree and how the partial interval length of each node is changed during this change .", "label": "", "metadata": {}, "score": "46.80474"}
{"text": "Example of Structure Adjustment !The following shows splay tree ( splaying ) as an example of structure adjustment ( claim 34 ) , and explains how splaying changes the structure of a binary tree and how the partial interval length of each node is changed during this change .", "label": "", "metadata": {}, "score": "46.80474"}
{"text": "In this case , the partial interval length of each node is changed as follows , as explained in \" 6 - 2 - 4 - 2 .Interval Addition Step \" : .Because added node x and its parent are both red nodes , the ranks are as follows : .", "label": "", "metadata": {}, "score": "46.859386"}
{"text": "In this case , the partial interval length of each node is changed as follows , as explained in \" 6 - 2 - 4 - 2 .Interval Addition Step \" : .Because added node x and its parent are both red nodes , the ranks are as follows : .", "label": "", "metadata": {}, "score": "46.859386"}
{"text": "5 .In this example , a set of four hash functions is shown , along with their generated values .FIG . 7 ( c ) illustrates the next step in the process , that of comparing the signatures and finding their intersection .", "label": "", "metadata": {}, "score": "46.914352"}
{"text": "These approaches share a common framework of first performing a precomputation to store the number of tuples that contain the most frequently co - occurring substrings , defined as the \" cross - counts \" .Online estimation then involves parsing the query into subqueries such that the cross - count for each subquery is available from the precomputation process .", "label": "", "metadata": {}, "score": "46.9738"}
{"text": "And , at the same time , it deletes a text item no longer necessary and adds a necessary text item .There are many procedures for it .One of them is : .This may be done , as in ( 1 ) , while listing the text items with the use of the text functions ( t4 ) and ( t6 ) .", "label": "", "metadata": {}, "score": "47.032616"}
{"text": "This means that a change in part of an interval affects only the changed node and one or more nodes on the path from that node to the root , thus simplifying the change procedure .More specifically , even when the length of an interval is changed , the required data processing time is approximately proportional to the logarithm of the number of intervals .", "label": "", "metadata": {}, "score": "47.07647"}
{"text": "This means that a change in part of an interval affects only the changed node and one or more nodes on the path from that node to the root , thus simplifying the change procedure .More specifically , even when the length of an interval is changed , the required data processing time is approximately proportional to the logarithm of the number of intervals .", "label": "", "metadata": {}, "score": "47.07647"}
{"text": "A procedure similar to that described in [ 6 - 2 - 4 .Increasing the Efficiency of Index Updating ( Addition ) ] may be used to find a position ( starting position of a trailing string ) where index re - arranging is required when the text is changed .", "label": "", "metadata": {}, "score": "47.1499"}
{"text": "That is , direct comparison of two trailing strings and comparison of the positions within the index of the trailing strings from which a matching leading string has been removed may be combined .In addition , direct character comparison and comparison of the positions in the index may be done in any order .", "label": "", "metadata": {}, "score": "47.150208"}
{"text": "According to the invention of the 15 . sup.th illustrative implementation , the dictionary tree generating means and text tree generating means integrate the nodes of the dictionary tree and text tree into one , eliminating the need for the pointers between them and saving storage space .", "label": "", "metadata": {}, "score": "47.198036"}
{"text": "And , for all these index items the function ( x4 ) lists all , but non - duplicating , start positions of the substrings within the code string which exactly match the pattern or which match the pattern for the longest length .", "label": "", "metadata": {}, "score": "47.24263"}
{"text": "In some embodiments , not only may a plurality of nodes make up a subtree , but also a singular node may make up a subtree .For example , node 19referenced as 712 is connected to the root node via an edge labeled \" Cap , \" such that documents 0 and 3 contain the substring \" Cap . \"", "label": "", "metadata": {}, "score": "47.295067"}
{"text": "In some embodiments , not only may a plurality of nodes make up a subtree , but also a singular node may make up a subtree .For example , node 19referenced as 712 is connected to the root node via an edge labeled \" Cap , \" such that documents 0 and 3 contain the substring \" Cap . \"", "label": "", "metadata": {}, "score": "47.295067"}
{"text": "However , a variable - length pattern , rather than a fixed - length pattern , is used in retrieval in most cases .Therefore , satisfying all the retrieval requests by searching a binary tree for a desired substring requires us to use a key that is equal in length to the longest pattern .", "label": "", "metadata": {}, "score": "47.50843"}
{"text": "For example , a node 20 referenced as 907 is connected to node 4 via a bidirectional edge , such that the substring \" Bottle Opener \" may be generated via the edge connecting node 4 ( e.g. , 904 ) and node 20 ( e.g. , 907 ) .", "label": "", "metadata": {}, "score": "47.52576"}
{"text": "For example , a node 20 referenced as 907 is connected to node 4 via a bidirectional edge , such that the substring \" Bottle Opener \" may be generated via the edge connecting node 4 ( e.g. , 904 ) and node 20 ( e.g. , 907 ) .", "label": "", "metadata": {}, "score": "47.52576"}
{"text": "2B is the simple decomposition of the example XPE p 200 ; note that S b simply adds the substring ab ( b is a branching node ) to the minimal decomposition S a .Also , note that , for a single - path XPE , its simple decomposition is equal to its minimal decomposition .", "label": "", "metadata": {}, "score": "47.60105"}
{"text": "In this embodiment , the substring itself is thought of as one of trailing strings .Dictionary data 5 and 6 in the first embodiment is a suffix tree ( hereafter called \" tree \" ) .A tree is a data structure from the root to end nodes with a plurality of nodes in between .", "label": "", "metadata": {}, "score": "47.601818"}
{"text": "In this embodiment , the substring itself is thought of as one of trailing strings .Dictionary data 5 and 6 in the first embodiment is a suffix tree ( hereafter called \" tree \" ) .A tree is a data structure from the root to end nodes with a plurality of nodes in between .", "label": "", "metadata": {}, "score": "47.601818"}
{"text": "12 ( b ) , the performance of the \" count - suffix tree \" method of the prior art degrades significantly as the dimensionality increases .For example , when 20 % of the space is devoted to selectivity estimation , the error of two - dimensional queries in the prior art drops to 10 % , but the error of three - dimensional and four - dimensional queries remains above 80 % .", "label": "", "metadata": {}, "score": "47.660618"}
{"text": "The function ( x8 ) is implemented , as with the function ( x4 ) , by the procedure for calculating an interval position , which represents an index item , with the use of the interval control method .The function ( x9 ) is executed , as with the function ( t3 ) , by retrieving in the binary search tree which represents the index .", "label": "", "metadata": {}, "score": "47.725338"}
{"text": "The dictionary tree generating means 5 and the text tree generating means 9 also establish pointers between nodes in the dictionary tree 4 and the text tree 8 .The data processing system in this embodiment has a retrieving means 10 which , based on the dictionary tree 4 and the text tree 8 , retrieves trailing strings having the whole or a part of a key string as the leading string .", "label": "", "metadata": {}, "score": "47.73091"}
{"text": "79 shows an example of a suffix tree .A suffix tree is the simplest form of a Trie .That is , a suffix tree is a tree structure T in which the labels , each attached to a path from the root to a leaf ( end node ) , generate a suffix of the code string s. In a suffix tree , a leaf corresponds to the end of a suffix ( end of s ) .", "label": "", "metadata": {}, "score": "47.731865"}
{"text": "79 shows an example of a suffix tree .A suffix tree is the simplest form of a Trie .That is , a suffix tree is a tree structure T in which the labels , each attached to a path from the root to a leaf ( end node ) , generate a suffix of the code string s. In a suffix tree , a leaf corresponds to the end of a suffix ( end of s ) .", "label": "", "metadata": {}, "score": "47.731865"}
{"text": "In addition , the updating means , which performs operation on both an index and a text , has some limitations on the relation between index items and text items .On the other hand , whether or not the retrieving means has to access the text depends on the embodiment .", "label": "", "metadata": {}, "score": "47.80098"}
{"text": "This is done , for example , by setting the first boundary and the second boundary alternately in the code string 1 and by setting the boundary interval ( number of characters ) between each two boundaries ( first and second ) to k or longer .", "label": "", "metadata": {}, "score": "47.809685"}
{"text": "This is done , for example , by setting the first boundary and the second boundary alternately in the code string 1 and by setting the boundary interval ( number of characters ) between each two boundaries ( first and second ) to k or longer .", "label": "", "metadata": {}, "score": "47.809685"}
{"text": "Interval Length Change Process !When the length of an interval is changed , the partial interval length of each node , from that node to the root , is changed by the changed value .FIG .31 is a flowchart showing the procedure for changing an interval length .", "label": "", "metadata": {}, "score": "47.88944"}
{"text": "Interval Length Change Process !When the length of an interval is changed , the partial interval length of each node , from that node to the root , is changed by the changed value .FIG .31 is a flowchart showing the procedure for changing an interval length .", "label": "", "metadata": {}, "score": "47.88944"}
{"text": "Referring to FIG .5 ( a ) , node n 12 is associated with substring abc and referring to FIG .5 ( b ) , node n 22 is associated with substring 123 .The selectivity ( i.e. , answer to the query ) is then found by the intersection of sets S 12 and S 22 , divided by the total number N of data elements in the set .", "label": "", "metadata": {}, "score": "47.89115"}
{"text": "[ 0057 ] .The parenthetical annotation \" ( s j ) \" besides a node d i in D 110 means that a non - redundant matching of s j at d i occurs when d i is parsed in D 110 .", "label": "", "metadata": {}, "score": "47.956253"}
{"text": "Retrieving means execution steps .From the description of the index configuration and function , the execution steps of the retrieving means which uses an index are self - explanatory .It should be remembered that , if the length of a key - candidate substring ( leading string of a trailing string ) in an index item is limited , the length of a pattern to be retrieved must not exceed the length .", "label": "", "metadata": {}, "score": "48.00981"}
{"text": "The function returns a text item at the same start position indicated by an index item .( p2 )The function returns an index item at the same start position indicated by a text item .These two functions , as shown in the above embodiments , may be implemented in many ways ; for example , index items and text items are integrated or are linked by pointers .", "label": "", "metadata": {}, "score": "48.03047"}
{"text": "The method as defined in .claim 1 wherein performing step c ) , removing nodes with a count less than two .The method as defined in .claim 1 wherein in performing step d ) , generating a signature length in the range of 10 to 100 .", "label": "", "metadata": {}, "score": "48.04624"}
{"text": "The function ( x1 ) may be implemented , as with the function ( x3 ) , by searching the index binary search tree with the leading string of a not - registered trailing string as the pattern .When the length of the leading string of a trailing string is not limited ( that is , an index item contains a trailing string ) , there should not be a trailing string duplication .", "label": "", "metadata": {}, "score": "48.128456"}
{"text": "This representation was chosen because it keeps the implementation comparatively clean , and the instance - less case reasonably efficient .The alternative of storing the allocator instance only in the rope would have added additional allocator arguments to many internal functions .", "label": "", "metadata": {}, "score": "48.184486"}
{"text": "This representation was chosen because it keeps the implementation comparatively clean , and the instance - less case reasonably efficient .The alternative of storing the allocator instance only in the rope would have added additional allocator arguments to many internal functions .", "label": "", "metadata": {}, "score": "48.184486"}
{"text": "Then , however , we explore the remaining unclustered documents and check if each of them can be added to the clusters formed by not taking the order of the words into account .Labeling Algorithm .In some embodiments , cluster labels are used to depict compact information about the type of documents present in the cluster .", "label": "", "metadata": {}, "score": "48.18753"}
{"text": "Then , however , we explore the remaining unclustered documents and check if each of them can be added to the clusters formed by not taking the order of the words into account .Labeling Algorithm .In some embodiments , cluster labels are used to depict compact information about the type of documents present in the cluster .", "label": "", "metadata": {}, "score": "48.18753"}
{"text": "It also prevents the rope from being destructively updated while the iterator must remain valid .Rope Implementation Overview .A rope is represented as a pointer to _ Rope_RopeRep structure , which represents a tree node .Every tree node corresponds to a piece of a rope .", "label": "", "metadata": {}, "score": "48.20989"}
{"text": "If the current node is the root node , it is determined that there is no left adjacent node of the specified node .On the other hand , if the current node is not root node , the parent node of the node is set as the current node ( step 439 ) and control returns to step 436 .", "label": "", "metadata": {}, "score": "48.231247"}
{"text": "In this case , those nodes having the identical high - order address bits are assumed to contain in their addresses the character string corresponding to the high - order address bits .[ 3 .Third Embodiment ] .Unlike the above embodiments , this embodiment relates to a data processing system or data retrieval system which does not limit the length of a key - candidate substring .", "label": "", "metadata": {}, "score": "48.248657"}
{"text": "We stop if we find that we need a zero length substring .Similarly , we simply return a pointer to the entire rope when that 's appropriate .For a substring node , we either return a short leaf node , or a new substring node .", "label": "", "metadata": {}, "score": "48.2492"}
{"text": "We stop if we find that we need a zero length substring .Similarly , we simply return a pointer to the entire rope when that 's appropriate .For a substring node , we either return a short leaf node , or a new substring node .", "label": "", "metadata": {}, "score": "48.2492"}
{"text": "moves said node corresponding to said interval , which is to be deleted , to the root by means of splaying , .moves the node immediately preceding or following the node , which is to be deleted , to the root by means of splaying , . decreases the partial interval length of said immediately - preceding or immediately - following node , which is the root , by the interval length of said node to be deleted , and . deletes said node to be deleted .", "label": "", "metadata": {}, "score": "48.27681"}
{"text": "moves said node corresponding to said interval , which is to be deleted , to the root by means of splaying , .moves the node immediately preceding or following the node , which is to be deleted , to the root by means of splaying , . decreases the partial interval length of said immediately - preceding or immediately - following node , which is the root , by the interval length of said node to be deleted , and . deletes said node to be deleted .", "label": "", "metadata": {}, "score": "48.27681"}
{"text": "29 is an another example of a flowchart of a procedure for identifying an interval corresponding to the specified node .In the procedure shown in FIG .28 , the left interval that is on the left of the specified node interval is determined , and the right side of the specified node interval is calculated based on the left interval length .", "label": "", "metadata": {}, "score": "48.30091"}
{"text": "29 is an another example of a flowchart of a procedure for identifying an interval corresponding to the specified node .In the procedure shown in FIG .28 , the left interval that is on the left of the specified node interval is determined , and the right side of the specified node interval is calculated based on the left interval length .", "label": "", "metadata": {}, "score": "48.30091"}
{"text": "According to the invention as claimed in claim 25 , processing is simplified because there is no need to change the partial interval lengths except that for the root .According to the invention as claimed in claim 26 , the adding means adjusts the connection sequence and interval lengths of nodes to maintain the integrity of a binary tree .", "label": "", "metadata": {}, "score": "48.301018"}
{"text": "According to the invention as claimed in claim 25 , processing is simplified because there is no need to change the partial interval lengths except that for the root .According to the invention as claimed in claim 26 , the adding means adjusts the connection sequence and interval lengths of nodes to maintain the integrity of a binary tree .", "label": "", "metadata": {}, "score": "48.301018"}
{"text": "Note that since the performance of XFilter is always much worse than XFilter - LB , we omit XFilter from subsequent graphs .[ 0111 ] .[ 0111]FIG . 8Bcompares the scalability of the algorithms as a function of the size of the XML documents ( in terms of the number of tag - pairs ) .", "label": "", "metadata": {}, "score": "48.314545"}
{"text": "That is , a bit string usually consists of a plurality of 0s and 1s that appear alternately .In a conventional method , bit data is compressed by sequentially recording the numbers of consecutive Os and ls ( run - length - encoding ) .", "label": "", "metadata": {}, "score": "48.33611"}
{"text": "That is , a bit string usually consists of a plurality of 0s and 1s that appear alternately .In a conventional method , bit data is compressed by sequentially recording the numbers of consecutive Os and ls ( run - length - encoding ) .", "label": "", "metadata": {}, "score": "48.33611"}
{"text": "FIG .3 is prior art matrix illustrating the exact cross - counts for the parsed data sets associated with FIG . 1 and FIG .2 ( a ) ; .FIG .4 contains a prior art diagram of a pruned k - d count - suffix tree for the same data set as discussed above ; .", "label": "", "metadata": {}, "score": "48.35295"}
{"text": "This sum is called a partial interval length .FIG .22 shows an example of the binary tree 31 used in the sixth embodiment , and FIG .23 explains the binary tree 31 in FIG .22 .As these figures show , the binary tree 31 in the sixth embodiment is a tree , consisting of nodes A , B , C , D , and E corresponding to the intervals 1 . . .", "label": "", "metadata": {}, "score": "48.366287"}
{"text": "This sum is called a partial interval length .FIG .22 shows an example of the binary tree 31 used in the sixth embodiment , and FIG .23 explains the binary tree 31 in FIG .22 .As these figures show , the binary tree 31 in the sixth embodiment is a tree , consisting of nodes A , B , C , D , and E corresponding to the intervals 1 . . .", "label": "", "metadata": {}, "score": "48.366287"}
{"text": "The following sections explain the procedure for adding and deleting an interval .FIG .35 is a flowchart showing the procedure for adding and deleting an interval in the sixth embodiment .Interval Addition Process !In the sixth embodiment , the adding means 43 adjusts the interval lengths to maintain the integrity of the binary tree 31 .", "label": "", "metadata": {}, "score": "48.367435"}
{"text": "The following sections explain the procedure for adding and deleting an interval .FIG .35 is a flowchart showing the procedure for adding and deleting an interval in the sixth embodiment .Interval Addition Process !In the sixth embodiment , the adding means 43 adjusts the interval lengths to maintain the integrity of the binary tree 31 .", "label": "", "metadata": {}, "score": "48.367435"}
{"text": "This is equal to the partial interval length ( f4 ) of node f after splaying , indicating that the relative position of the interval of node a is not affected by splaying .Application of Splaying !Splaying described above allows the following procedure to be used for various types of processing already described .", "label": "", "metadata": {}, "score": "48.438553"}
{"text": "This is equal to the partial interval length ( f4 ) of node f after splaying , indicating that the relative position of the interval of node a is not affected by splaying .Application of Splaying !Splaying described above allows the following procedure to be used for various types of processing already described .", "label": "", "metadata": {}, "score": "48.438553"}
{"text": "And , the dictionary data generating means 3 establishes a pointer between the start position of each leading string in the dictionary data 2 and the corresponding position in the text data 6 .The data processing system in this embodiment also has the retrieving means 10 for retrieving trailing strings each containing the whole or part of a key string as the leading string , based on the dictionary data 2 and the text data 6 .", "label": "", "metadata": {}, "score": "48.45661"}
{"text": "This process determines the position of the specified node through the interval length of a node that is right or left to the specified node .This simple procedure allows the position of the specified node to be identified , making is possible to perform various types of processing .", "label": "", "metadata": {}, "score": "48.47634"}
{"text": "This may also be done while listing the text items with the use of the text functions ( t4 ) and ( t6 ) .When n.noteq.k , processing described in ( e ) and ( f ) below is necessary .", "label": "", "metadata": {}, "score": "48.58392"}
{"text": "For the XPE retrieval problem , an XML document matches an XPE when the evaluation result is a non - empty node set .[ 0032 ] .The simplest form of XPEs specify a single - path pattern , which can be either an absolute path from the root of the document or a relative path from some known location ( i.e. , \" context node \" ) .", "label": "", "metadata": {}, "score": "48.612755"}
{"text": "There are some methods for checking whether or not there is a change in the key relation ( sequence ) in the index before and after a character is added .In another method , a check is made to see if , in the index before the character is added , an extended trailing string comes immediately after the trailing string itself ( If this is satisfied , there is no change in the relation ) .", "label": "", "metadata": {}, "score": "48.653107"}
{"text": "Thus , the interval length 5 is smaller than the specified position 8 .So , it determined that the specified position 8 belongs in the right side of node B. .Then , as shown in FIG .11 , the current node is moved to node D. As described above , in the data processing system using the interval control method , the interval retrieving means 33 compares the specified position with the range of the current node while moving the current node downward , one level at a time , from the root .", "label": "", "metadata": {}, "score": "48.664497"}
{"text": "These procedures are executed easily on an index structured as a binary search tree .( 2 ) Index update function .The following summarizes the index update function .( x11 )When the leading string of a trailing string is given , the function determines the index item immediately before or after which the index item containing the leading . string of the given trailing string is to be inserted ( also determines if the insertion point is immediately before or after the position ) .", "label": "", "metadata": {}, "score": "48.7126"}
{"text": "The reason is that , because these trailing strings are already in the index , their relation is known .In the not - registered part shown in FIG .37 , a trailing string beginning with a character other than \" .", "label": "", "metadata": {}, "score": "48.715622"}
{"text": "As shown in this figure , an interval indicated by node X is added immediately after the interval corresponding to node L. First splaying is executed to make node R the root node ; node R is the node which will come immediately after node X. Then splaying is executed to make node L the root node ; node L is the node which will come immediately before node X. FIG .", "label": "", "metadata": {}, "score": "48.7627"}
{"text": "As shown in this figure , an interval indicated by node X is added immediately after the interval corresponding to node L. First splaying is executed to make node R the root node ; node R is the node which will come immediately after node X. Then splaying is executed to make node L the root node ; node L is the node which will come immediately before node X. FIG .", "label": "", "metadata": {}, "score": "48.7627"}
{"text": "The following shows an example in which a conventional structure adjustment procedure unit is applied to the whole or an part of a path from the root to a node .Performing rotation on the binary tree 31 in FIG .43 results in the binary tree 31 shown in FIG .", "label": "", "metadata": {}, "score": "48.76729"}
{"text": "The following shows an example in which a conventional structure adjustment procedure unit is applied to the whole or an part of a path from the root to a node .Performing rotation on the binary tree 31 in FIG .43 results in the binary tree 31 shown in FIG .", "label": "", "metadata": {}, "score": "48.76729"}
{"text": "Therefore , the key - candidate substring need not be re - arranged in order to determine its new position ( sequence ) .All the trailing strings longer than the shortest such trailing string ( \" cab \" in the above example ) do not require the whole string to be compared and therefore need not be re - arranged .", "label": "", "metadata": {}, "score": "48.791"}
{"text": "And , the retrieving means retrieves a trailing string which contains the whole or part of a sub - key string as a leading string .In this case , since each sub - key string can be found unless divided by one or more boundaries , the maximum key length is the maximum length of a sub - key string .", "label": "", "metadata": {}, "score": "48.80529"}
{"text": "And , the retrieving means retrieves a trailing string which contains the whole or part of a sub - key string as a leading string .In this case , since each sub - key string can be found unless divided by one or more boundaries , the maximum key length is the maximum length of a sub - key string .", "label": "", "metadata": {}, "score": "48.80529"}
{"text": "[ B-2 .Retrieval ] .Using this data processing system , the user will be able to retrieve and so on , as described below .The interval retrieving means 33 calculates the range of the current node based on the interval lengths of the current node and the lower - level nodes ( step 92 ) , and compares the calculated range with the specified position .", "label": "", "metadata": {}, "score": "48.85293"}
{"text": "1 , the matrix of FIG .3 is also \" pruned \" , as shown by the line through the row of cross - counts associated with the substring 123 and the column of cross - counts associated with the substring abc .", "label": "", "metadata": {}, "score": "48.887943"}
{"text": "( x9 )The function determines an index item with a specified lexicographic order number .Combining the functions ( x8 ) and ( x9 ) gives us a function equivalent to the function ( x6 ) .Sometimes , the following functions are necessary .", "label": "", "metadata": {}, "score": "48.934326"}
{"text": "When one character is added to the end of the text , a key - candidate substring is added to , or re - arranged in , the index as follows .First , a one - character trailing string , consisting of the added character only , is registered to the index .", "label": "", "metadata": {}, "score": "48.941032"}
{"text": "22 , characters ( strings ) may also be stored in the node corresponding to a dictionary item .Note that , in FIG .22 , substrings beginning with \" b \" are not contained in the dictionary tree .In the text tree , the nodes with no corresponding item in the dictionary are omitted .", "label": "", "metadata": {}, "score": "48.965965"}
{"text": "That is , in retrieving a pattern , this function eliminates the need to go back to the root each time a character is added to the retrieval key ; it simply goes down through the binary search tree , making the retrieval more efficient .", "label": "", "metadata": {}, "score": "48.973015"}
{"text": "The following method may also be used to improve this point .That is , when comparing with \" . beta.xy.alpha.w \" registered in the index , only a trailing string beginning with \" .beta . \" need be compared with \" xy.alpha.w \" .", "label": "", "metadata": {}, "score": "48.98521"}
{"text": "b ) storing , for each node in each suffix tree , an exact count of a row identifiers of each data element comprising the substring associated with the node ; .c ) hashing , for each node in each suffix tree , the row identifiers to generate a fixed - length signature for the associated node ; .", "label": "", "metadata": {}, "score": "48.998543"}
{"text": "In contrast , CLE Tags and CLE BD address how to extract labels using these statistics .Some embodiments may include defining the Cluster Term Frequency ( CTF i ) of phrase p , with respect to cluster C i , as the number of documents or titles that contain the phrase p. In some embodiments , we would ignore common stop words and also duplicate occurrences of the same word or phrase in any document or title .", "label": "", "metadata": {}, "score": "49.022312"}
{"text": "In contrast , CLE Tags and CLE BD address how to extract labels using these statistics .Some embodiments may include defining the Cluster Term Frequency ( CTF i ) of phrase p , with respect to cluster C i , as the number of documents or titles that contain the phrase p. In some embodiments , we would ignore common stop words and also duplicate occurrences of the same word or phrase in any document or title .", "label": "", "metadata": {}, "score": "49.022312"}
{"text": "FIG .56 shows how the binary tree looks like after rotation has been applied to the binary tree shown in FIG .55 .This operation changes the partial interval lengths of nodes h and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "49.038902"}
{"text": "FIG .56 shows how the binary tree looks like after rotation has been applied to the binary tree shown in FIG .55 .This operation changes the partial interval lengths of nodes h and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "49.038902"}
{"text": "In this case the rope root pointer is redundant , except that it us used to detect changes in the rope , so that the cached information in the iterator can be invalidated .The rope has changed iff the rope itself no longer points to the same node as the rope root pointer in the iterator .", "label": "", "metadata": {}, "score": "49.08378"}
{"text": "In this case the rope root pointer is redundant , except that it us used to detect changes in the rope , so that the cached information in the iterator can be invalidated .The rope has changed iff the rope itself no longer points to the same node as the rope root pointer in the iterator .", "label": "", "metadata": {}, "score": "49.08378"}
{"text": "This will be detailed later .Various types of changes may be made on a code string by the following function .( u )The function replaces n characters beginning at position P with the character string s(s.sub.0 , s.sub.1 , . . .", "label": "", "metadata": {}, "score": "49.13594"}
{"text": "[0067 ] .RelLevel is the relative level of s i , j ( i.e. , relLevel(s i , j ) ) .[0068 ] .[ 0069 ] .NumChild is the total number of child substrings of s i , j .", "label": "", "metadata": {}, "score": "49.149418"}
{"text": "In the sixth embodiment , the interval length changing means , the deleting means , or the adding means updates the binary tree 31 when an interval length is changed , an interval is deleted , or an interval is added .", "label": "", "metadata": {}, "score": "49.16008"}
{"text": "In the sixth embodiment , the interval length changing means , the deleting means , or the adding means updates the binary tree 31 when an interval length is changed , an interval is deleted , or an interval is added .", "label": "", "metadata": {}, "score": "49.16008"}
{"text": "The clustered results are then sent to the labeling algorithm .The labeling algorithm uses some statistical measure to provide descriptive tags that represent the clusters on the whole , such that the clusters have meaning for the person performing the search .", "label": "", "metadata": {}, "score": "49.196037"}
{"text": "The clustered results are then sent to the labeling algorithm .The labeling algorithm uses some statistical measure to provide descriptive tags that represent the clusters on the whole , such that the clusters have meaning for the person performing the search .", "label": "", "metadata": {}, "score": "49.196037"}
{"text": "The label attached to an edge or a node in a tree or binary tree need not be one - character code .In addition , dictionary data in the data retrieval system need not be in a tree form , but may be in the form of a correspondence table containing pairs of trailing strings and positions .", "label": "", "metadata": {}, "score": "49.244797"}
{"text": "The label attached to an edge or a node in a tree or binary tree need not be one - character code .In addition , dictionary data in the data retrieval system need not be in a tree form , but may be in the form of a correspondence table containing pairs of trailing strings and positions .", "label": "", "metadata": {}, "score": "49.244797"}
{"text": "This data retrieval system retrieves trailing strings , each having the whole or a part of a key string as a leading string , based on the dictionary tree and the text tree .This data retrieval system with the configuration described above finds , within the text , the positions of all the non - duplicating appearances of a pattern to be retrieved even when the text is changed .", "label": "", "metadata": {}, "score": "49.28542"}
{"text": "In addition , the interval control method gives us the trailing string corresponding to a specified lexicographic order number .TABLE 23 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", "label": "", "metadata": {}, "score": "49.33673"}
{"text": "When the code string is changed and the position of a substring is changed , only one pointer need be changed and , so , the processing speed is higher than when as many pointers as the number of end nodes must be changed .", "label": "", "metadata": {}, "score": "49.341713"}
{"text": "When the code string is changed and the position of a substring is changed , only one pointer need be changed and , so , the processing speed is higher than when as many pointers as the number of end nodes must be changed .", "label": "", "metadata": {}, "score": "49.341713"}
{"text": "The retrieval time therefore depends on the number of appearances of the pattern .The data processing system in this embodiment arranges lexicographically the dictionary data items to be registered in the index , and assigns sequential numbers ( 1 , 2 , 3 , . . . ) to those items via the sequence assigning means 30 , as shown in Table 13 .", "label": "", "metadata": {}, "score": "49.34784"}
{"text": "The following explains one of the simplest procedures for determining the node immediately preceding a specified node ( that is , the node on the left adjacent side ) by referring to FIG .43 .Then , if this adjacent node has a right child ( step 434 ) , this right child of the adjacent node is set as the adjacent node ( step 435 ) .", "label": "", "metadata": {}, "score": "49.3518"}
{"text": "Construct a suffix tree / array from this text .It 's easy now to traverse this suffix data structure to collect all right maximal repeats .By examining the left context , filter out the non - left maximal repeats .", "label": "", "metadata": {}, "score": "49.367462"}
{"text": "16 shows an example of the second embodiment , with the dotted line indicating the second edge .The number of second edges from an end node without a pointer to an end node with a pointer equals the difference between the positions of two trailing strings corresponding to the two nodes .", "label": "", "metadata": {}, "score": "49.38395"}
{"text": "16 shows an example of the second embodiment , with the dotted line indicating the second edge .The number of second edges from an end node without a pointer to an end node with a pointer equals the difference between the positions of two trailing strings corresponding to the two nodes .", "label": "", "metadata": {}, "score": "49.38395"}
{"text": "The workload level U defined above was used and the average - absolute - relative error was recorded as a function of space .Comparing FIG .12 ( a ) to FIG .12 ( b ) , the results indicate that the accuracy of high dimensional selectivity estimation using set hashing is more favorable when compared to a high dimensional generalization of the prior art .", "label": "", "metadata": {}, "score": "49.40975"}
{"text": "FIG .4 is a flowchart showing the procedure to create a tree from substrings .In this procedure , trailing substrings are retrieved , one at at time , from the substring ( step 41 ) , and the following processing is repeated for all possible trailing strings ( step 41 ) .", "label": "", "metadata": {}, "score": "49.419544"}
{"text": "FIG .4 is a flowchart showing the procedure to create a tree from substrings .In this procedure , trailing substrings are retrieved , one at at time , from the substring ( step 41 ) , and the following processing is repeated for all possible trailing strings ( step 41 ) .", "label": "", "metadata": {}, "score": "49.419544"}
{"text": "That is , when the first differing pointer is detected ( branch point ) , the relation may be determined by checking which index item follows the pointer to the left child or to the right child .[ 9 - 4 .", "label": "", "metadata": {}, "score": "49.421974"}
{"text": "A data processing system as claimed in claim 35 , 36 , 45 , or 46 , wherein the length of a key - candidate substring constituting said index is not limited .A data processing system as claimed in claim 50 , wherein said index is represented by a binary tree .", "label": "", "metadata": {}, "score": "49.434986"}
{"text": "First , since longer substrings have a lower probability of being matched in the input XML document , the maximal - length substrings chosen in a minimal decomposition generally result in fewer index probes .Second , since fewer XPEs are associated with a longer substring , the cost of each index probe is generally lower with minimal decompositions .", "label": "", "metadata": {}, "score": "49.452255"}
{"text": "The function inserts a new index item immediately before or after a specified index item ( whichever is specified ) .( x13 )The function deletes an index item from the index .The functions ( x11 ) and ( x12 ) enable the index generating means 22 and the updating means 12 to add a new index item at a desired position within the index .", "label": "", "metadata": {}, "score": "49.477493"}
{"text": "In this case , all the trailing strings starting in the range \" u \" may have to have their index items re - arranged .This is because the index items for all the trailing strings starting in the range \" u \" are registered but , as a result of the change , their positions may have been changed .", "label": "", "metadata": {}, "score": "49.485527"}
{"text": "In addition , although the leading string of a trailing string of a code string is used in this invention to find a match during retrieval in the above embodiments , the trailing string of a leading string of a code string may be used instead .", "label": "", "metadata": {}, "score": "49.486237"}
{"text": "We want to couple the suffix array with the $ LCPs$ , the longest common prefixes .We can construct the array of $ LCPs$ in linear time as mentioned in the paper by Kasai et al .The length is of course the value in the lcp array .", "label": "", "metadata": {}, "score": "49.576916"}
{"text": "According to the invention as claimed in claim 24 , even when the length of an interval is changed , only the nodes from that node to the root need be changed .Unlike a conventional system , the data processing system eliminates the need to move all the nodes corresponding to the intervals following the changed node .", "label": "", "metadata": {}, "score": "49.58208"}
{"text": "According to the invention as claimed in claim 24 , even when the length of an interval is changed , only the nodes from that node to the root need be changed .Unlike a conventional system , the data processing system eliminates the need to move all the nodes corresponding to the intervals following the changed node .", "label": "", "metadata": {}, "score": "49.58208"}
{"text": "When the start position is contained in a text item and the index item references it with the use of ( p1 ) , the start position is already updated in step ( e ) .When the start position is contained in both a text item and an index item , the interval control method is used to update it efficiently .", "label": "", "metadata": {}, "score": "49.6539"}
{"text": "\" ; otherwise , it can be said that \" the index item need not be re - arranged \" for \" .alpha.ux . . .\" .It also means that , for a trailing string ( beginning at the left ) that is longer than \" .", "label": "", "metadata": {}, "score": "49.6606"}
{"text": "The tree in FIG .67 is used as an example of a balanced binary tree .In this tree , each node has an integer rank such as 1 or 2 , as shown in FIG .67 .The rank of node x is represented by rank ( x ) , the parent of node x is represented by p ( x ) , and the grandparent of node x is represented by p2 ( x ) .", "label": "", "metadata": {}, "score": "49.70882"}
{"text": "The tree in FIG .67 is used as an example of a balanced binary tree .In this tree , each node has an integer rank such as 1 or 2 , as shown in FIG .67 .The rank of node x is represented by rank ( x ) , the parent of node x is represented by p ( x ) , and the grandparent of node x is represented by p2 ( x ) .", "label": "", "metadata": {}, "score": "49.70882"}
{"text": "Splaying may also be used to delete a node ( interval ) .To do so , the node to be deleted is first moved to the root through execution of splaying .FIG .64 shows how the binary tree looks like after node X , which is to be deleted , has been moved to the root through execution of splaying .", "label": "", "metadata": {}, "score": "49.739044"}
{"text": "Splaying may also be used to delete a node ( interval ) .To do so , the node to be deleted is first moved to the root through execution of splaying .FIG .64 shows how the binary tree looks like after node X , which is to be deleted , has been moved to the root through execution of splaying .", "label": "", "metadata": {}, "score": "49.739044"}
{"text": "Binary Tree Generation Process !First , the binary tree generating means 32 generates the binary tree 31 representing the range of each interval according to the intervals in the code string .The binary tree may also be generated , with the use of the adding means 43 , by adding a node each time an interval is entered .", "label": "", "metadata": {}, "score": "49.785767"}
{"text": "Binary Tree Generation Process !First , the binary tree generating means 32 generates the binary tree 31 representing the range of each interval according to the intervals in the code string .The binary tree may also be generated , with the use of the adding means 43 , by adding a node each time an interval is entered .", "label": "", "metadata": {}, "score": "49.785767"}
{"text": "The first embodiment with the configuration described above operates as follows : .Code String Division Process !The code string used in the first embodiment is a character string , one character being represented by one code value .First , the dividing means 4 divides the code string 1 into the first substrings 2 , each bounded by the first boundary and each longer than the maximum key length ( hereafter called \" k \" ) .", "label": "", "metadata": {}, "score": "49.80317"}
{"text": "The first embodiment with the configuration described above operates as follows : .Code String Division Process !The code string used in the first embodiment is a character string , one character being represented by one code value .First , the dividing means 4 divides the code string 1 into the first substrings 2 , each bounded by the first boundary and each longer than the maximum key length ( hereafter called \" k \" ) .", "label": "", "metadata": {}, "score": "49.80317"}
{"text": "Conversely , when the maximum key length is set to a fixed value , it is possible to retrieve data using a key string longer than the maximum key string by making each sub - key length equal to or less than the maximum key length .", "label": "", "metadata": {}, "score": "49.885727"}
{"text": "Conversely , when the maximum key length is set to a fixed value , it is possible to retrieve data using a key string longer than the maximum key string by making each sub - key length equal to or less than the maximum key length .", "label": "", "metadata": {}, "score": "49.885727"}
{"text": "This requires the updating means 12 to have to re - arrange all the existing index items in the index , decreasing the efficiency .The above method is used to prevent this condition .On the other hand , adding a code string to the start of a code string requires only new index items to be added ; it does not require existing index items to be re - arranged .", "label": "", "metadata": {}, "score": "49.913807"}
{"text": "[0048 ] .Intuitively , to avoid such problems , the minimal decomposition of an XPE should be enriched so that it \" takes note \" of the branching nodes in the XPE - tree .The XTrie index accomplishes this through the use of simple XPE decompositions .", "label": "", "metadata": {}, "score": "49.917233"}
{"text": "Thus we do not build up nested substring nodes .Any other function node is treated roughly as a leaf .Note that this process requires time proportional to the rope depth , and does n't directly depend on the length .", "label": "", "metadata": {}, "score": "49.936127"}
{"text": "Thus we do not build up nested substring nodes .Any other function node is treated roughly as a leaf .Note that this process requires time proportional to the rope depth , and does n't directly depend on the length .", "label": "", "metadata": {}, "score": "49.936127"}
{"text": "It is apparent from Table 9 that the portion enclosed by a rectangle is included in those key - candidate substrings that are used when the key length is limited to \" 3 \" ( See Table 7 ) .It can be said that there is no difference in time to form an index by arranging those key - candidate substrings lexicographically .", "label": "", "metadata": {}, "score": "49.960045"}
{"text": "Table 2 also shows the correspondence between the integers ( 1 to 7 ) , each indicating the start position of a trailing string , and the characters ( more precisely , the storage elements holding those characters ) .A number to the left of a key - candidate substring indicates the lexicographic order of the substring , while a number to the right shows a pointer to the start position of that substring .", "label": "", "metadata": {}, "score": "49.96634"}
{"text": "Further , another problem is that , for a variable - length substring , data processing such as editing or retrieval can not be done efficiently .For example , a substring changes and variable in length when edited .So , to process a substring , it is always necessary to match a substring with a particular position within the code string .", "label": "", "metadata": {}, "score": "49.973465"}
{"text": "0070 ] .Next , which is a \" pointer \" for a singly linked list , is the row number of the next tuple in ST that belongs to the same logical block as the current row .[ 0071 ] .", "label": "", "metadata": {}, "score": "49.980145"}
{"text": "Therefore , even if a trailing string beginning with \" .beta . \" is compared with \" . beta.xy.alpha.w \" , the length to be compared is expected to be shorter than that of \" xy.alpha .When registering those trailing strings , it is more efficient to proceed from right ( end ) to left ( start ) .", "label": "", "metadata": {}, "score": "49.989143"}
{"text": "In some cases , however , the title information alone may not suffice for retrieving .Additional factors may need to be taken into consideration during the clustering process .For instance , one factor to be used could be the demand factor which , in one embodiment , is the relationship of items and categories to the query terms .", "label": "", "metadata": {}, "score": "50.00681"}
{"text": "In some cases , however , the title information alone may not suffice for retrieving .Additional factors may need to be taken into consideration during the clustering process .For instance , one factor to be used could be the demand factor which , in one embodiment , is the relationship of items and categories to the query terms .", "label": "", "metadata": {}, "score": "50.00681"}
{"text": "In the data structure shown in FIG .42 , the code in a node and the fields to the left of the code are used to implement text functions .In other words , data in Table 12 shown in [ 3 - 3 .", "label": "", "metadata": {}, "score": "50.011738"}
{"text": "48 is an example of a conventional Trie ; .FIG .49 is an example of positions and substring identifiers in a code string used in a conventional code string retrieval ; .FIG .50 is an example of a conventional position tree ; .", "label": "", "metadata": {}, "score": "50.030193"}
{"text": "Positive queries were randomly sampled from within strings of each data set .The tuples from which these substrings come were uniformly chosen .For each attribute , the start position was then uniformly chosen , and the length varied ( also uniformly ) between 2 and 7 characters .", "label": "", "metadata": {}, "score": "50.03337"}
{"text": "Some embodiments may include demand data that is utilized in an additional approach to improve the relevancy of clusters extracted and prune the irrelevant clusters or phrases for the given query Q ( e.g. , query 108 ) .In some cases , there could be some phrases in the search results that occur frequently , but might not be very relevant to the current input query from the user .", "label": "", "metadata": {}, "score": "50.05806"}
{"text": "Some embodiments may include demand data that is utilized in an additional approach to improve the relevancy of clusters extracted and prune the irrelevant clusters or phrases for the given query Q ( e.g. , query 108 ) .In some cases , there could be some phrases in the search results that occur frequently , but might not be very relevant to the current input query from the user .", "label": "", "metadata": {}, "score": "50.05806"}
{"text": "For example , the rope \" abcedefghigklmnopqrstuvwxy \" might be concatenated to \" z \" as shown in the following figure : .Handling this case specially guarantees that ropes built by repeatedly concatenating short strings onto the right will be composed of leaves of a minimum size , and thus can be stored and processed efficiently .", "label": "", "metadata": {}, "score": "50.063404"}
{"text": "For example , the rope \" abcedefghigklmnopqrstuvwxy \" might be concatenated to \" z \" as shown in the following figure : .Handling this case specially guarantees that ropes built by repeatedly concatenating short strings onto the right will be composed of leaves of a minimum size , and thus can be stored and processed efficiently .", "label": "", "metadata": {}, "score": "50.063404"}
{"text": "In this case , the key - candidate substring ( leading string of a trailing string ) is not stored in the index item .The code string is restored using the text in the corresponding text item obtained by the function ( p1 ) .", "label": "", "metadata": {}, "score": "50.142815"}
{"text": "According to the invention of the 16 . sup.th illustrative implementation , a character string stored in the dictionary tree as well as the pointers established between the dictionary tree and text tree allow the character string to be restored , eliminating the need to store the character string in the text tree and saving storage space .", "label": "", "metadata": {}, "score": "50.156822"}
{"text": "Obviously , for the exemplary data set , an exact response can be obtained .In most circumstances , however , the sheer size of the data set prohibits such a response and an estimate is sufficient .Using the technique of the present invention , query q is parsed on each dimension into a number of smaller subqueries that match nodes within each PST .", "label": "", "metadata": {}, "score": "50.204033"}
{"text": "[ 0029 ] .Indexing on a set of substrings ( rather than individual element names ) in the XPEs is an important aspect of the approach that enables both the number and the cost of the required index probes to be reduced or even minimized .", "label": "", "metadata": {}, "score": "50.2119"}
{"text": "Moreover , words with weights closer to 2 are words that are most relevant to the query , and words with weighting lower than 1 are words that are irrelevant to the query .Here , for the purpose of simplicity , the relevance weights have been normalized to range from 0 to 2 .", "label": "", "metadata": {}, "score": "50.263596"}
{"text": "Moreover , words with weights closer to 2 are words that are most relevant to the query , and words with weighting lower than 1 are words that are irrelevant to the query .Here , for the purpose of simplicity , the relevance weights have been normalized to range from 0 to 2 .", "label": "", "metadata": {}, "score": "50.263596"}
{"text": "5 contains a pair of suffix trees augmented with the row identified set information used in the method of the present invention ; .FIG .6 contains a set of three Venn diagrams illustrating the concept of set resemblance as used in the present invention ; .", "label": "", "metadata": {}, "score": "50.269028"}
{"text": "When the current node becomes the root ( step 292 ) , the interval of the specified node is identified as the interval between the left interval and the right interval ( step 298 ) .The right end of the specified node may be calculated by subtracting the right interval length from the partial interval length of the root .", "label": "", "metadata": {}, "score": "50.344837"}
{"text": "When the current node becomes the root ( step 292 ) , the interval of the specified node is identified as the interval between the left interval and the right interval ( step 298 ) .The right end of the specified node may be calculated by subtracting the right interval length from the partial interval length of the root .", "label": "", "metadata": {}, "score": "50.344837"}
{"text": "( trailing string one character shorter than current y ) and repeat the steps from ( 2 ) .This method compares in step ( 3 ) the positions ( within the index ) of a part of longest trailing strings which are generated by removing a matching leading string from the comparison trailing strings u and v and both of which are registered in the index .", "label": "", "metadata": {}, "score": "50.368816"}
{"text": "This algorithm is my own invention .I would not classify it as very clever , but it ought to work .A really simple solution : Build a suffix tree for the first string , $ S$ , and annotate all nodes with $ s$. Then insert all suffixes of the second string , $ T$. Annotate nodes you pass through or create with $ t$. The path label for any node that is annotated with both $ s$ and $ t$ is a substring of both $ S$ and $ T$. ( See , for example , these lecture notes a quick web search turned up . )", "label": "", "metadata": {}, "score": "50.373035"}
{"text": "The next section [ 6 - 2 - 2 .Increasing the Efficiency in Comparing Trailing Strings ] will explain how to increase the efficiency when retrieving trailing strings from the index with a trailing string as the key .The first code string ( leading string of a trailing string ) and the second code string ( leading string of a trailing string , or a code string ) are compared beginning with the first code position , one at a time .", "label": "", "metadata": {}, "score": "50.380543"}
{"text": "The lower limit remains at the end of the index with the lower - limit matching leading - string length still being 0 .Then , select one trailing string that is smaller than the upper limit and larger than the lower limit ( the central trailing string \" bcab \" in this example ) , and let it be \" s \" .", "label": "", "metadata": {}, "score": "50.383606"}
{"text": "According to the invention as claimed in a 18 . sup.th illustrative implementation , the pointers to the nodes in the dictionary tree required when the text is changed need not be stored .Storing a character string in one dictionary node only , instead of storing it in a plurality of nodes , significantly saves storage space .", "label": "", "metadata": {}, "score": "50.42928"}
{"text": "S .j .S . k .N .S .S .N .As stated above , and as shown in FIG .5 with nodes n 13 and n 23 , any set may be as large as N ( the total number of tuples in the database ) .", "label": "", "metadata": {}, "score": "50.435844"}
{"text": "Basically , these data structures are based on a Trie ( digital search tree ) .In this data structure , a leaf corresponds to the character string wi ( a full character string ) .In addition , a character string generated by the labels on the paths from the root to a node x is considered to be a prefix ( a leading substring ) of a character string generated by the labels from the root to a leaf .", "label": "", "metadata": {}, "score": "50.46685"}
{"text": "In the fifth embodiment , a check is made to see if the whole key string occurs in a position within the code string where a plurality of data units , each of which is retrieved by each sub - key , occur consecutively .", "label": "", "metadata": {}, "score": "50.477577"}
{"text": "In the fifth embodiment , a check is made to see if the whole key string occurs in a position within the code string where a plurality of data units , each of which is retrieved by each sub - key , occur consecutively .", "label": "", "metadata": {}, "score": "50.477577"}
{"text": "The table depicted below shows for each intermediate node , the base cluster under that node , and the phrases ( e.g. , strings ) and the documents that belong to the base cluster identified by these nodes .In some embodiments , each base cluster is assigned a score that is a function of the number of documents it contains and the words that make up its title .", "label": "", "metadata": {}, "score": "50.580162"}
{"text": "The table depicted below shows for each intermediate node , the base cluster under that node , and the phrases ( e.g. , strings ) and the documents that belong to the base cluster identified by these nodes .In some embodiments , each base cluster is assigned a score that is a function of the number of documents it contains and the words that make up its title .", "label": "", "metadata": {}, "score": "50.580162"}
{"text": "This ensures efficient code string processing .According to the invention as claimed in claim 36 , data can be represented as a single simply - structured binary tree .In addition , according to the invention as claimed in claim 36 , representing consecutive characters or blanks with a single node increases both processing efficiency and memory efficiency .", "label": "", "metadata": {}, "score": "50.58076"}
{"text": "This ensures efficient code string processing .According to the invention as claimed in claim 36 , data can be represented as a single simply - structured binary tree .In addition , according to the invention as claimed in claim 36 , representing consecutive characters or blanks with a single node increases both processing efficiency and memory efficiency .", "label": "", "metadata": {}, "score": "50.58076"}
{"text": "Because of this , various types of processing for the binary tree is performed speedily .According to the invention as claimed in claim 35 , one type of binary tree representing the sequence of lines and an other type of tree representing the content of each line are created separately .", "label": "", "metadata": {}, "score": "50.589447"}
{"text": "Because of this , various types of processing for the binary tree is performed speedily .According to the invention as claimed in claim 35 , one type of binary tree representing the sequence of lines and an other type of tree representing the content of each line are created separately .", "label": "", "metadata": {}, "score": "50.589447"}
{"text": "Normally , key comparison starts at the first ( leftmost ) character and ends when a mismatch character ( position ) is found .For example , in the example shown in Table 8 , the characters used for comparison order to form an index are those enclosed by a rectangle shown in Table 9 .", "label": "", "metadata": {}, "score": "50.62388"}
{"text": "As described above , the start position of each trailing string is determined by the partial interval lengths in the left half of the binary true .As shown in Table 24 , one record can be accessed in two different ways .", "label": "", "metadata": {}, "score": "50.668636"}
{"text": "35 is a flowchart showing a procedure for adding and deleting a node in the sixth embodiment of this invention ; .FIG .36 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .", "label": "", "metadata": {}, "score": "50.716213"}
{"text": "35 is a flowchart showing a procedure for adding and deleting a node in the sixth embodiment of this invention ; .FIG .36 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .", "label": "", "metadata": {}, "score": "50.716213"}
{"text": "Increasing the Efficiency of Index Updating ( Addition ) ] .When a trailing string is added to ( or registered in ) the index , retrieval is performed for the index , with the trailing string to be added as the key , to determine the position at which it is to be inserted .", "label": "", "metadata": {}, "score": "50.71942"}
{"text": "According to the invention as claimed in claims 2 and 38 , the first and second substrings can be determined simply by setting the first and second boundaries alternately .According to the invention as claimed in claims 3 and 39 , dictionary data can be built in a tree - structure data format called a suffix tree .", "label": "", "metadata": {}, "score": "50.725307"}
{"text": "According to the invention as claimed in claims 2 and 38 , the first and second substrings can be determined simply by setting the first and second boundaries alternately .According to the invention as claimed in claims 3 and 39 , dictionary data can be built in a tree - structure data format called a suffix tree .", "label": "", "metadata": {}, "score": "50.725307"}
{"text": "As the current node is moved , either the left interval length which is the total of the lengths of the nodes preceding the specified node or the right interval length which is the total or the lengths of the nodes following the specified node is obtained .", "label": "", "metadata": {}, "score": "50.737144"}
{"text": "Some embodiments may include the use of a relevance - weighting factor to generate a purely statistical measure to produce a list of keywords ( e.g. , corresponding to a particular query ) that may appear in search results .This factor may , for example , be applied just before the generation of the merged cluster map .", "label": "", "metadata": {}, "score": "50.759674"}
{"text": "Some embodiments may include the use of a relevance - weighting factor to generate a purely statistical measure to produce a list of keywords ( e.g. , corresponding to a particular query ) that may appear in search results .This factor may , for example , be applied just before the generation of the merged cluster map .", "label": "", "metadata": {}, "score": "50.759674"}
{"text": "In some embodiments , a mechanism is provided to measure and validate the clustering system .One measure that may be provided for evaluating the clustering system is to determine coverage and precision for the clustering system .Further , in an extreme situation , one could define a single cluster with all the result documents in it to achieve coverage of 1 .", "label": "", "metadata": {}, "score": "50.779457"}
{"text": "In some embodiments , a mechanism is provided to measure and validate the clustering system .One measure that may be provided for evaluating the clustering system is to determine coverage and precision for the clustering system .Further , in an extreme situation , one could define a single cluster with all the result documents in it to achieve coverage of 1 .", "label": "", "metadata": {}, "score": "50.779457"}
{"text": "When they match , the position of the trailing string itself is the result of retrieval .The binary search method thus compares one of the trailing strings in the range where the code string is supposed to reside with that code string , narrowing the range where the code string is supposed to reside .", "label": "", "metadata": {}, "score": "50.790764"}
{"text": "9 .Next , an operation 1408 is executed that receives the merged cluster map and applies various factors including , for example , the relevancy weighting factor , selling factor , price factor , category factor , and image factor .", "label": "", "metadata": {}, "score": "50.84381"}
{"text": "9 .Next , an operation 1408 is executed that receives the merged cluster map and applies various factors including , for example , the relevancy weighting factor , selling factor , price factor , category factor , and image factor .", "label": "", "metadata": {}, "score": "50.84381"}
{"text": "32 .After that , if an attempt is made to retrieve a node corresponding to the interval containing position 8 ( FIGS .33 and 34 ) , the result is node D , not node C. The interval represented by node D is 8-(3 - 2)+1 . . .", "label": "", "metadata": {}, "score": "50.84918"}
{"text": "32 .After that , if an attempt is made to retrieve a node corresponding to the interval containing position 8 ( FIGS .33 and 34 ) , the result is node D , not node C. The interval represented by node D is 8-(3 - 2)+1 . . .", "label": "", "metadata": {}, "score": "50.84918"}
{"text": "Another known method is to divide a code string into a plurality of substrings and , for each of them , a Trie is created individually .However , there are two problems with this method .One problem is that , if a portion of the code string corresponding to the key string is divided and if the first half belongs to one Trie and the last half to another , it is impossible to search for that portion with the key string .", "label": "", "metadata": {}, "score": "50.855583"}
{"text": "Another known method is to divide a code string into a plurality of substrings and , for each of them , a Trie is created individually .However , there are two problems with this method .One problem is that , if a portion of the code string corresponding to the key string is divided and if the first half belongs to one Trie and the last half to another , it is impossible to search for that portion with the key string .", "label": "", "metadata": {}, "score": "50.855583"}
{"text": "They represent the concatenation of the two strings represented by the left and right subtrees .Concatenation of two longer ropes usually allocates a new concatenation node which references the two ropes to be concatenated .( _Rope_RopeFunction ) Function nodes .", "label": "", "metadata": {}, "score": "50.881374"}
{"text": "They represent the concatenation of the two strings represented by the left and right subtrees .Concatenation of two longer ropes usually allocates a new concatenation node which references the two ropes to be concatenated .( _Rope_RopeFunction ) Function nodes .", "label": "", "metadata": {}, "score": "50.881374"}
{"text": "13 is a flowchart showing an example of a procedure for identifying the interval corresponding to the specified node .In this procedure , the partial interval length of the left child of the current node that is specified is first set to the left interval length ( step 131 ) .", "label": "", "metadata": {}, "score": "50.89293"}
{"text": "The interior of the substring can remain shared with the original rope .Iterators .Iterators generated by the normal begin ( ) and end ( ) operations generate const_iterators , i.e. iterators that do not permit updates to the underlying rope .", "label": "", "metadata": {}, "score": "50.928993"}
{"text": "The interior of the substring can remain shared with the original rope .Iterators .Iterators generated by the normal begin ( ) and end ( ) operations generate const_iterators , i.e. iterators that do not permit updates to the underlying rope .", "label": "", "metadata": {}, "score": "50.928993"}
{"text": "In this way , the data processing system in this embodiment gives us the number of appearances of a specific pattern by simply checking the sequences of two items in the index , making the retrieval time independent of the number of appearances .", "label": "", "metadata": {}, "score": "50.962944"}
{"text": "Then , check whether or not leading string of trailing string in current node matches longest matching pattern ( step 455 ) , if it matches , current node is set as the first node ( step 456 ) and return to step 453 .", "label": "", "metadata": {}, "score": "50.963303"}
{"text": "This order may be ascending or decending .Further , once ordering occurs , then further compaction may take place for certain nodes , and their new position may be duplicative of other nodes .Combining Clusters .Some embodiments may include strings that are common to more than one document .", "label": "", "metadata": {}, "score": "50.968525"}
{"text": "This order may be ascending or decending .Further , once ordering occurs , then further compaction may take place for certain nodes , and their new position may be duplicative of other nodes .Combining Clusters .Some embodiments may include strings that are common to more than one document .", "label": "", "metadata": {}, "score": "50.968525"}
{"text": "3 ; but , normally , the key - candidate substring changes and therefore the nodes are relocated in different positions .The nodes corresponding ( cca ) ( previously corresponding ( bca ) ) and ( cab ) have been exchanged in the dictionary tree .", "label": "", "metadata": {}, "score": "50.984154"}
{"text": "A data retrieval system comprising : . dictionary tree generating means for generating a dictionary tree , which is a binary tree , based on said dictionary data ; . text data generating means for generating text data based on said code string ; . sequence assigning means for assigning a sequence number to each of plural lexicographically registered dictionary data items ; and . retrieving means for retrieving trailing strings each containing at least part of a key string as one of the leading strings , based on said dictionary tree , . wherein said retrieving means counts a number of substrings , each containing an identical leading string using the sequence numbers of a first dictionary data item and a last dictionary data item .", "label": "", "metadata": {}, "score": "50.989853"}
{"text": "A data processing system as claimed in claim 11 , wherein said retrieving means restores a substring based on one or both of said dictionary data and text data .A data processing system comprising : . text data generating means for generating text data based on said code string ; . retrieving means for retrieving trailing strings each containing at least part of a key string as one of the leading strings , based on said dictionary data and text data ; . changing means for changing said code string ; . sequence assigning means for assigning a sequence number to each of plural lexicographically registered dictionary data items ; and .", "label": "", "metadata": {}, "score": "51.031456"}
{"text": "According to the invention as claimed in claims 23 and 49 , the interval length changing means , the deleting means , or the adding means updates a binary tree when an interval length is changed , an interval is deleted , or an interval is added .", "label": "", "metadata": {}, "score": "51.032467"}
{"text": "According to the invention as claimed in claims 23 and 49 , the interval length changing means , the deleting means , or the adding means updates a binary tree when an interval length is changed , an interval is deleted , or an interval is added .", "label": "", "metadata": {}, "score": "51.032467"}
{"text": "[ 4 - 2 . Operation And Effects of the Fourth Embodiment ] .The fourth embodiment having the configuration described above operates as follows .When a plurality of text changes are applied to a plurality of locations which are adjacent to each other , a trailing string beginning in the same position must sometimes be registered each time a change is made .", "label": "", "metadata": {}, "score": "51.042618"}
{"text": "This procedure eliminates the need to change the partial interval length of a non - root node , making the processing simpler .When adding a node and adjusting the associated partial interval lengths , splaying is applied to the nodes immediately before and after the node to be added to make them the root node one at a time .", "label": "", "metadata": {}, "score": "51.07353"}
{"text": "This procedure eliminates the need to change the partial interval length of a non - root node , making the processing simpler .When adding a node and adjusting the associated partial interval lengths , splaying is applied to the nodes immediately before and after the node to be added to make them the root node one at a time .", "label": "", "metadata": {}, "score": "51.07353"}
{"text": "A data processing system as claimed in claim 35 , 36 , 45 , or 46 , wherein the length of a key - candidate substring constituting said index is limited .A data processing system as claimed in claim 47 , wherein said index is represented by a binary tree .", "label": "", "metadata": {}, "score": "51.07354"}
{"text": "The method as recited in .claim 12 wherein said probing comprises probing said substring table only for matching substrings that appear as a leaf substring in one of said XPath expressions .A selective data dissemination system , comprising : . a document receiver for receiving XML documents from a plurality of publishers ; . a subscription receiver for receiving words of interest from a plurality of subscribers , said words being encapsulable in XPath expressions ; . a tree builder that builds a document data tree for said XML document and an XPath expression tree based on substrings in said XPath expressions ; . a tree prober that employs said XPath expression tree to probe said document data tree and obtain matches with said substrings ; and .", "label": "", "metadata": {}, "score": "51.102585"}
{"text": "FIG .55 shows how the binary tree looks like after double rotation ( zig - zag ) has been applied to the binary tree shown in FIG .54 .This operation changes the partial interval lengths of nodes g , f , and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "51.11342"}
{"text": "FIG .55 shows how the binary tree looks like after double rotation ( zig - zag ) has been applied to the binary tree shown in FIG .54 .This operation changes the partial interval lengths of nodes g , f , and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "51.11342"}
{"text": "SECOND EMBODIMENT .In the first embodiment , pointers are set in all the end nodes .However , a pointer pointing to the end of a substring need be set only for the end node of the trailing string which is the substring .", "label": "", "metadata": {}, "score": "51.115463"}
{"text": "SECOND EMBODIMENT .In the first embodiment , pointers are set in all the end nodes .However , a pointer pointing to the end of a substring need be set only for the end node of the trailing string which is the substring .", "label": "", "metadata": {}, "score": "51.115463"}
{"text": "The configuration ( x1 ) allows the function to determine the start position of a specified index item .The basic function of an index is as described above .The following function is available to list such key - candidate substrings ( leading string of a trailing string ) or their start positions .", "label": "", "metadata": {}, "score": "51.143856"}
{"text": "However because a trailing string containing all or part of the key string as the lending string ( preceding part ) is retrieved in the first embodiment , this tree serves as dictionary data indicating the correspondence between the following substrings and their positions .", "label": "", "metadata": {}, "score": "51.14675"}
{"text": "However because a trailing string containing all or part of the key string as the lending string ( preceding part ) is retrieved in the first embodiment , this tree serves as dictionary data indicating the correspondence between the following substrings and their positions .", "label": "", "metadata": {}, "score": "51.14675"}
{"text": "The position of each result string can be calculated using the length of the substring and the number of characters of each result string .The removing means 9 removes the duplicate positions ( step 64 ) and outputs the positions ( step 65 ) .", "label": "", "metadata": {}, "score": "51.15084"}
{"text": "The position of each result string can be calculated using the length of the substring and the number of characters of each result string .The removing means 9 removes the duplicate positions ( step 64 ) and outputs the positions ( step 65 ) .", "label": "", "metadata": {}, "score": "51.15084"}
{"text": "This enables the user to determine in which tree , text or dictionary , the characters are to be stored .For example , in the example shown in FIG .2 of embodiment 1 , the characters are stored in the text tree .", "label": "", "metadata": {}, "score": "51.1631"}
{"text": "As shown , the values of only the second hash function match , thus providing a set resemblance \u03c1 of \u00bc. More formally , .^ .i .i . min .i .A . ) min .i .", "label": "", "metadata": {}, "score": "51.173523"}
{"text": "In doing so , these methods then only maintain cross - counts for combinations of short substrings - as dimensions increase , these substrings get significantly shorter .As a result , the probability of locating any given subquery is small and queries wind up being parsed into many small subqueries .", "label": "", "metadata": {}, "score": "51.255447"}
{"text": "beta . \" , which are immediately before u and v respectively , are compared .If . alpha . beta . , then it can be said that , for the trailing string \" .alpha.ux . . .\" , the index item may have to be re - arranged .", "label": "", "metadata": {}, "score": "51.2668"}
{"text": "According to the invention of the 17 . sup.th illustrative implementation , storing in the dictionary tree the minimum character strings required to restore the text significantly saves storage space for storing a character string in each node in the dictionary tree .", "label": "", "metadata": {}, "score": "51.303932"}
{"text": "The process of traversing a label corresponding to a character is repeated in this manner , and the current node when the procedure ends in step 53 or 54 is determined to be the longest match node .At this time , the counter contains the number of codes that match the key string .", "label": "", "metadata": {}, "score": "51.337643"}
{"text": "The process of traversing a label corresponding to a character is repeated in this manner , and the current node when the procedure ends in step 53 or 54 is determined to be the longest match node .At this time , the counter contains the number of codes that match the key string .", "label": "", "metadata": {}, "score": "51.337643"}
{"text": "updating , based on the contents of said change , the dictionary data , text data , and lexicographic order of said code string associated with the change .A data processing method as claimed in claim 57 , wherein said retrieving step has counting step for counting the number of substrings , each containing an identical leading string , using the sequence numbers of the first dictionary data item and the last dictionary data item .", "label": "", "metadata": {}, "score": "51.34223"}
{"text": "Shufen Kuo and George R. Gross , \" A Two - Step String - Matching Procedure \" , Pattern Recognition , vol .24 , No . 7 , pp .711 - 716 , 1991 .John A. Dundas III , \" Implementing Dynamic Minimal - prefix Tries \" , Software - Practice And Experience , vol .", "label": "", "metadata": {}, "score": "51.35289"}
{"text": "Thus , even when the code string is changed , there is no need to change the whole data ; only the dictionary data of a substring associated with the change need be updated .This reduces the update time .This update time is proportional to the length of a substring affected by the change , not to the length of the whole code string .", "label": "", "metadata": {}, "score": "51.354935"}
{"text": "Thus , even when the code string is changed , there is no need to change the whole data ; only the dictionary data of a substring associated with the change need be updated .This reduces the update time .This update time is proportional to the length of a substring affected by the change , not to the length of the whole code string .", "label": "", "metadata": {}, "score": "51.354935"}
{"text": "updating , based on a contents of change , the dictionary data , the dictionary tree , the text data , the text tree , and a lexicographic order of said code string associated with the change , . wherein said step of retrieving includes the step of counting a number of substrings , each containing an identical leading string , using the sequence numbers of a first dictionary data item and a last dictionary data item .", "label": "", "metadata": {}, "score": "51.36228"}
{"text": "A data retrieval system as claimed in claim 18 , wherein the length of a key - candidate substring constituting said dictionary data is not limited .A data retrieval system comprising : . text data generating means for generating text data based on said code string ; . sequence assigning means for assigning a sequence number to each of plural lexicographically registered dictionary data items ; and . retrieving means for retrieving trailing strings each containing at least part of a key string as and of the leading strings , based on said dictionary data , . wherein said retrieving means counts a number of substrings , each containing an identical leading string , using the sequence numbers of a first dictionary data item and a last dictionary data item .", "label": "", "metadata": {}, "score": "51.42225"}
{"text": "We chose not to pursue that route , since the tag field can be much smaller than a vtable pointer , and the tag based code is probably also faster in this case .The 4 subclasses of _ Rope_RopeRep are : .", "label": "", "metadata": {}, "score": "51.426872"}
{"text": "We chose not to pursue that route , since the tag field can be much smaller than a vtable pointer , and the tag based code is probably also faster in this case .The 4 subclasses of _ Rope_RopeRep are : .", "label": "", "metadata": {}, "score": "51.426872"}
{"text": "Increasing the Efficiency of Index Updating ( B ) ] may be used together .When retrieving an item from the index to determine , with the use of the index function ( x11 ) , the position at which a new item is to be added , the methods described in [ 6 - 2 - 2 .", "label": "", "metadata": {}, "score": "51.482224"}
{"text": "updating , based on a determination result of said comparing and determining steps , the dictionary data of said code string associated with the change .A data processing method as claimed in claim 61 , wherein , when registering the leading string of the trailing string . alpha.w in a table arranged lexicographically with the leading string of the trailing string as the key , said registering step registers the leading string of . alpha.w immediately after the leading string of .", "label": "", "metadata": {}, "score": "51.486214"}
{"text": "So , the changing means 11 , which simply informs the updating means 12 of the change , may be included in the updating means 12 .On the other hand , an independent index generating means and the text generating means are significant only in the following cases .", "label": "", "metadata": {}, "score": "51.4924"}
{"text": "The computer system of .claim 12 , further comprising : . a receiver to receive a search query , the search query relating to item data ; and .an extractor to extract the item data from the merged cluster as a search result , the search result extracted based upon a similarity between the search query and the item data .", "label": "", "metadata": {}, "score": "51.496525"}
{"text": "The computer system of .claim 12 , further comprising : . a receiver to receive a search query , the search query relating to item data ; and .an extractor to extract the item data from the merged cluster as a search result , the search result extracted based upon a similarity between the search query and the item data .", "label": "", "metadata": {}, "score": "51.496525"}
{"text": "81 shows how the code string in Table 1 is represented in the first method .In the first method , the position of each code value is proportional to the difference between the address of storage at which the code value is stored and the start address of storage where the code string is stored .", "label": "", "metadata": {}, "score": "51.51454"}
{"text": "81 shows how the code string in Table 1 is represented in the first method .In the first method , the position of each code value is proportional to the difference between the address of storage at which the code value is stored and the start address of storage where the code string is stored .", "label": "", "metadata": {}, "score": "51.51454"}
{"text": "When the current node becomes the root ( step 142 ) , the interval of the specified node is identified as the interval between the left interval and the right interval ( step 148 ) .The right end of the specified node may be calculated by subtracting the right interval length from the partial interval length of the root .", "label": "", "metadata": {}, "score": "51.52966"}
{"text": "Variation of the Fifth Embodiment ] .Because the dictionary data , to which the sequence assigning means 30 assigns lexicographic order numbers , corresponds to the text data on a one - to - one basis , their relation can be represented without using pointers as follows .", "label": "", "metadata": {}, "score": "51.635014"}
{"text": "Next , an operation 1202 is executed that generates a base cluster score using documents and phrases in a document for a particular cluster .Once the base cluster score is generated , an operation 1203 is executed that merges the base cluster scores to create a merged base cluster score .", "label": "", "metadata": {}, "score": "51.671722"}
{"text": "Next , an operation 1202 is executed that generates a base cluster score using documents and phrases in a document for a particular cluster .Once the base cluster score is generated , an operation 1203 is executed that merges the base cluster scores to create a merged base cluster score .", "label": "", "metadata": {}, "score": "51.671722"}
{"text": "6 shows the procedure for retrieving data .First , a key string , k or shorter in length , is determined ( step 61 ) .The length of the key string is limited to k or shorter in this case .", "label": "", "metadata": {}, "score": "51.70057"}
{"text": "6 shows the procedure for retrieving data .First , a key string , k or shorter in length , is determined ( step 61 ) .The length of the key string is limited to k or shorter in this case .", "label": "", "metadata": {}, "score": "51.70057"}
{"text": "The retrieving means 8 finds the longest match node of the key string from the dictionary data 5 and 6 according to the procedure shown in FIG .5 ( step 62 ) .The number of trailing strings obtained as the result of retrieval ( hereafter called result strings ) equals the number of pointers set up on the end nodes ( sub - trees ) of the longest match node that was found .", "label": "", "metadata": {}, "score": "51.736687"}
{"text": "The retrieving means 8 finds the longest match node of the key string from the dictionary data 5 and 6 according to the procedure shown in FIG .5 ( step 62 ) .The number of trailing strings obtained as the result of retrieval ( hereafter called result strings ) equals the number of pointers set up on the end nodes ( sub - trees ) of the longest match node that was found .", "label": "", "metadata": {}, "score": "51.736687"}
{"text": "The configuration ( x2 ) allows the function to identify an index item which matches the leading string of the trailing string or an index item which does not exactly match but matches the leading string of the pattern for the longest length .", "label": "", "metadata": {}, "score": "51.811493"}
{"text": "3 , the items to be changed are determined by following the pointers to positions 4 , 3 , and 2 in the text tree , in the backward direction .In the above example , the start position of the substring \" abc \" is 3 .", "label": "", "metadata": {}, "score": "51.887283"}
{"text": "A pointer to the root node of the rope with which the iterator is associated .This pointer is not included in the reference count , Const_iterators become invalid if the underlying rope is modified or destroyed .( In the garbage collected case they remain valid and continue to refer to the original pre - modification rope . )", "label": "", "metadata": {}, "score": "51.916145"}
{"text": "A pointer to the root node of the rope with which the iterator is associated .This pointer is not included in the reference count , Const_iterators become invalid if the underlying rope is modified or destroyed .( In the garbage collected case they remain valid and continue to refer to the original pre - modification rope . )", "label": "", "metadata": {}, "score": "51.916145"}
{"text": "In some embodiments , hash clustering may be used as an alternative to the suffix tree as a data structure into which various substrings may be inserted .This hash table data structure may use standard hash clustering or may use bucket hashing depending upon the performance needs of a particular user or developer .", "label": "", "metadata": {}, "score": "51.91641"}
{"text": "In some embodiments , hash clustering may be used as an alternative to the suffix tree as a data structure into which various substrings may be inserted .This hash table data structure may use standard hash clustering or may use bucket hashing depending upon the performance needs of a particular user or developer .", "label": "", "metadata": {}, "score": "51.91641"}
{"text": "This method may be used when a trailing string is used instead of a code string ( as the key ) and , in that case , the procedure described in [ 6 - 2 - 2 .Increasing the efficiency of Trailing String Comparison ] may be used .", "label": "", "metadata": {}, "score": "51.948154"}
{"text": "12 is an example of a binary tree in a data processing system using the \" interval control method \" ( retrieval ) ; .FIG .13 is a flowchart showing the procedure for identifying an interval in a data processing system using the \" interval control method \" ; .", "label": "", "metadata": {}, "score": "52.02076"}
{"text": "For example , a subtree 507 contains a variety of nodes 508 - 514 .More to the point , a node 13 , referenced as 508 , is connected to a node 14 , referenced as 510 , via an edge labeled \" Bottle . \"", "label": "", "metadata": {}, "score": "52.029133"}
{"text": "For example , a subtree 507 contains a variety of nodes 508 - 514 .More to the point , a node 13 , referenced as 508 , is connected to a node 14 , referenced as 510 , via an edge labeled \" Bottle . \"", "label": "", "metadata": {}, "score": "52.029133"}
{"text": "51 is an example of a conventional suffix tree ; .FIG .52 is an example of a conventional directed acyclic word graph ; .FIG .53 is an example of data used in the conventional first method ; .", "label": "", "metadata": {}, "score": "52.0711"}
{"text": "According to the invention as claimed in claims 5 and 40 , the retrieving means traverses a path until the longest match path , which is the longest path matching the key string in the tree , is reached .This means that the retrieving means retrieves not only the position of a trailing string including the whole key string but also the position of a trailing string including part of the key string .", "label": "", "metadata": {}, "score": "52.095825"}
{"text": "According to the invention as claimed in claims 5 and 40 , the retrieving means traverses a path until the longest match path , which is the longest path matching the key string in the tree , is reached .This means that the retrieving means retrieves not only the position of a trailing string including the whole key string but also the position of a trailing string including part of the key string .", "label": "", "metadata": {}, "score": "52.095825"}
{"text": "At the same time , limiting the length of a key - candidate substring eliminates the need for redundant comparison .An invention according to a 60 . sup.th illustrative implementation is a data retrieval system of the 43 . sup.rd or 49 . sup.th illustrative implementations wherein the length of a key - candidate substring constituting the index is not limited .", "label": "", "metadata": {}, "score": "52.109474"}
{"text": "All those nodes may be changed into the nodes in the unique format which do not contain character strings explicitly ( that is , the spaces containing character strings are removed ) as shown in FIG .26 .In other words , as shown in FIG .", "label": "", "metadata": {}, "score": "52.145256"}
{"text": "The count c 13 is therefore \" 4 \" , as illustrated within node n 13 .With this simplified arrangement of a two - dimensional data set of four elements , it is possible to compute the selectivity of any substring query without error simply by intersecting the sets corresponding to each dimension .", "label": "", "metadata": {}, "score": "52.177864"}
{"text": "The parameter p b controls how \" bushy \" the XPE - trees of the XPEs are ( ranging from 0 to 0.1 ) ; a value of 0 generates only single - path XPEs , while a higher value increases the number of branches in the XPE - trees .", "label": "", "metadata": {}, "score": "52.17919"}
{"text": "45 is a flowchart showing the procedure for determining the first node ; .FIG .46 is a diagram illustrating the operation of the ninth embodiment of this invention ; .FIG .47 is an example of a pattern appearing in a character string in a conventional code string retrieval ; .", "label": "", "metadata": {}, "score": "52.267246"}
{"text": "To process this data on a computer , the straightforward method is to store code values sequentially at consecutive addresses in storage ( first method ) .FIG .53 shows how the code string in Table 1 is represented in the first method .", "label": "", "metadata": {}, "score": "52.296547"}
{"text": "The invention of claim 19 an d 46 can be symmetrically applied by calculates the range of the current node based on the length of the following node .This process determines the position of the specified node through the interval lengths of the nodes that are right or left to the specified node in L - C - R order .", "label": "", "metadata": {}, "score": "52.307503"}
{"text": "The invention of claim 19 an d 46 can be symmetrically applied by calculates the range of the current node based on the length of the following node .This process determines the position of the specified node through the interval lengths of the nodes that are right or left to the specified node in L - C - R order .", "label": "", "metadata": {}, "score": "52.307503"}
{"text": "54 shows how the binary tree looks like after double rotation ( zig - zag ) has been applied to the binary tree shown in FIG .52 .This operation changes the partial interval lengths of nodes e , d , and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "52.332863"}
{"text": "54 shows how the binary tree looks like after double rotation ( zig - zag ) has been applied to the binary tree shown in FIG .52 .This operation changes the partial interval lengths of nodes e , d , and a , indicated by bold circles , as follows : .", "label": "", "metadata": {}, "score": "52.332863"}
{"text": "7 is a diagram illustrating a compacted suffix tree , according to an example embodiment .FIG .8 is a diagram illustrating a hash table used to store base clusters of documents in the strings contained therein , according to an example embodiment .", "label": "", "metadata": {}, "score": "52.335365"}
{"text": "7 is a diagram illustrating a compacted suffix tree , according to an example embodiment .FIG .8 is a diagram illustrating a hash table used to store base clusters of documents in the strings contained therein , according to an example embodiment .", "label": "", "metadata": {}, "score": "52.335365"}
{"text": "Configuration of the Fifth Embodiment ] .In this embodiment , the sequence assigning means 30 is provided after the dictionary data generating means 3 , as shown in FIG .35 .It assigns sequential numbers ( 1 , 2 , 3 , . . . ) to dictionary data items , beginning with the first item .", "label": "", "metadata": {}, "score": "52.34867"}
{"text": "Another method is to store pairs , each consisting of a code value and a range of a substring where that code consecutively occurs , in a consecutive storage area in the order in which the substrings appear ( second method ) .", "label": "", "metadata": {}, "score": "52.401516"}
{"text": "Another method is to store pairs , each consisting of a code value and a range of a substring where that code consecutively occurs , in a consecutive storage area in the order in which the substrings appear ( second method ) .", "label": "", "metadata": {}, "score": "52.401516"}
{"text": "In this case , the retrieving means 8 outputs a message indicating that a whole string match as well as , or instead of , the number of matching codes ( step 67 ) .Code String Change Process and Dictionary Data !", "label": "", "metadata": {}, "score": "52.406578"}
{"text": "In this case , the retrieving means 8 outputs a message indicating that a whole string match as well as , or instead of , the number of matching codes ( step 67 ) .Code String Change Process and Dictionary Data !", "label": "", "metadata": {}, "score": "52.406578"}
{"text": "Consider again the XPE - tree in FIG .1A for p. Note that hybrid matchings of XPEs , which involve both unordered as well as ordered matchings , are also possible .Due to space constraints , the present discussion shall focus on only ordered matchings of XPEs that do not contain any attributes in the rest of this paper .", "label": "", "metadata": {}, "score": "52.40746"}
{"text": "51 is a conceptual diagram showing how data items in the nodes , which are part of the binary tree shown in FIG .49 , are connected via pointers .When the partial interval length al is updated , a new subscript follows the symbol a , such as a2 or a3 .", "label": "", "metadata": {}, "score": "52.4265"}
{"text": "51 is a conceptual diagram showing how data items in the nodes , which are part of the binary tree shown in FIG .49 , are connected via pointers .When the partial interval length al is updated , a new subscript follows the symbol a , such as a2 or a3 .", "label": "", "metadata": {}, "score": "52.4265"}
{"text": "In some embodiments , once the item data is retrieved by the operation 202 and the classification of the query 108 is determined , an uncompacted trie is built .Using these five retrieved titles , an uncompacted trie may be built .", "label": "", "metadata": {}, "score": "52.490685"}
{"text": "In some embodiments , once the item data is retrieved by the operation 202 and the classification of the query 108 is determined , an uncompacted trie is built .Using these five retrieved titles , an uncompacted trie may be built .", "label": "", "metadata": {}, "score": "52.490685"}
{"text": "[ 0112 ] .[ 0112]FIG .8C shows that increasing the probability of descendant operators in the XPEs ( i.e. , p d ) increases the filtering time of all the algorithms .For the XFilter - LB algorithm , having more descendant operators in the XPEs translates to more instances of partially matched expressions thereby resulting in more processing overhead .", "label": "", "metadata": {}, "score": "52.49116"}
{"text": "The method of .claim 1 , further comprising : . receiving a search query , the search query relating to item data ; and .extracting the item data from the merged cluster as a search result , the search result extracted based upon a similarity between the search query and the item data .", "label": "", "metadata": {}, "score": "52.506958"}
{"text": "The method of .claim 1 , further comprising : . receiving a search query , the search query relating to item data ; and .extracting the item data from the merged cluster as a search result , the search result extracted based upon a similarity between the search query and the item data .", "label": "", "metadata": {}, "score": "52.506958"}
{"text": "17 shows an example of a suffix tree in the third embodiment of this invention ; .FIG .18 shows an example of a substring in the fourth embodiment of this invention ; .FIG .19 shows an example of a substring in the fourth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "52.508133"}
{"text": "17 shows an example of a suffix tree in the third embodiment of this invention ; .FIG .18 shows an example of a substring in the fourth embodiment of this invention ; .FIG .19 shows an example of a substring in the fourth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "52.508133"}
{"text": "In this case , the updating means 12 updates the index as if it generated the index .The same is true of the text generating means .In this case , note that the changing means 11 is significant only when the code string 1 is stored separately from a text ( and index ) .", "label": "", "metadata": {}, "score": "52.51084"}
{"text": "FIG .5 shows the procedure for finding the longest match node in step 43 .In this procedure , the current node is set to the root , and the counter is reset ( step 51 ) .Characters are obtained from the key string , beginning at the start of the key string and one character at a time ( step 52 ) , until the key string ends ( step 53 ) .", "label": "", "metadata": {}, "score": "52.549362"}
{"text": "FIG .5 shows the procedure for finding the longest match node in step 43 .In this procedure , the current node is set to the root , and the counter is reset ( step 51 ) .Characters are obtained from the key string , beginning at the start of the key string and one character at a time ( step 52 ) , until the key string ends ( step 53 ) .", "label": "", "metadata": {}, "score": "52.549362"}
{"text": "3 shows an suffix tree in the first embodiment of this invention ; .FIG .4 is a flowchart showing the procedure for generating a suffix tree in the first embodiment of this invention ; .FIG .5 is a flowchart showing the procedure for finding a longest match node in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "52.550266"}
{"text": "3 shows an suffix tree in the first embodiment of this invention ; .FIG .4 is a flowchart showing the procedure for generating a suffix tree in the first embodiment of this invention ; .FIG .5 is a flowchart showing the procedure for finding a longest match node in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "52.550266"}
{"text": "58 .In this state , the nodes on the path from the parent of node X to the root are node L and node R. This means that , when the partial interval lengths are changed ( increased ) , those of only these two nodes need be changed , making the procedure simpler ( claim 28 ) .", "label": "", "metadata": {}, "score": "52.613335"}
{"text": "58 .In this state , the nodes on the path from the parent of node X to the root are node L and node R. This means that , when the partial interval lengths are changed ( increased ) , those of only these two nodes need be changed , making the procedure simpler ( claim 28 ) .", "label": "", "metadata": {}, "score": "52.613335"}
{"text": "In some embodiments , this data structure may be , for example , a trie , a hash table , or some other data structure that provides for constant time ( e.g. , O(1 ) ) or near constant time performance for insertion and searching .", "label": "", "metadata": {}, "score": "52.65287"}
{"text": "In some embodiments , this data structure may be , for example , a trie , a hash table , or some other data structure that provides for constant time ( e.g. , O(1 ) ) or near constant time performance for insertion and searching .", "label": "", "metadata": {}, "score": "52.65287"}
{"text": "( t6 )The function identifies the item immediately before or after a specified text item .Of course , th is function may be implemented not only by ( t3 ) or ( t5 ) or by ( t7 ) but by some other functions .", "label": "", "metadata": {}, "score": "52.686977"}
{"text": "25 illustrates the items in the dictionary .The method described above may be further improved as follows .In this method , the dictionary tree consists of two types of nodes : those containing character strings and those not containing character strings , as shown in FIG .", "label": "", "metadata": {}, "score": "52.699406"}
{"text": "Multidimensional selectivity estimation has been an active area of research for many years .Most work in this area , however , has focused on numerical attributes and has assumed the existence of a mapping from multidimensional categorical data to fully ordered domains .", "label": "", "metadata": {}, "score": "52.74756"}
{"text": "A data processing system as claimed in claim 25 , wherein , when registering the leading string of the trailing string . alpha.w in a table arranged lexicographically with the leading string of the trailing string as the key , said registering means registers the leading string of . alpha.w immediately after the leading string of .", "label": "", "metadata": {}, "score": "52.84835"}
{"text": "48 .Suppose that , for each node n , the partial interval length before change is S(n ) and the partial interval length after change is SS(n ) .SS(n ) to be set in each node after execution of an operation unit is calculated as follows , based on the partial interval length S(n ) before the operation unit is executed .", "label": "", "metadata": {}, "score": "52.868607"}
{"text": "48 .Suppose that , for each node n , the partial interval length before change is S(n ) and the partial interval length after change is SS(n ) .SS(n ) to be set in each node after execution of an operation unit is calculated as follows , based on the partial interval length S(n ) before the operation unit is executed .", "label": "", "metadata": {}, "score": "52.868607"}
{"text": "On the other hand , if . alpha . noteq . beta . , a check is made to see if \" x \" is involved in the comparison ( that is , one of leading strings is \" .alpha.u \" ) by comparing the trailing string immediately before and after \" .", "label": "", "metadata": {}, "score": "52.888153"}
{"text": "The dictionary tree generator generates a dictionary tree based on the dictionary data .The text data generator generates text data based on the code string .The text tree generator generates a text tree based on the text data .The retrieving unit retrieves a trailing string whose leading string contains part of or the whole key string , based on the dictionary tree 4 and the text tree .", "label": "", "metadata": {}, "score": "52.959564"}
{"text": "In some embodiments , this operation 305 acts to receive the relevancy weighting score for various items related to the query 108 .Once received , an operation 306 is executed that transmits the relevancy weighting scores to the STC algorithm as reflected in operation 204 .", "label": "", "metadata": {}, "score": "52.97673"}
{"text": "In some embodiments , this operation 305 acts to receive the relevancy weighting score for various items related to the query 108 .Once received , an operation 306 is executed that transmits the relevancy weighting scores to the STC algorithm as reflected in operation 204 .", "label": "", "metadata": {}, "score": "52.97673"}
{"text": "A data processing system comprising ; . text data generating means for generating text data based on said code string ; . retrieving means for retrieving trailing strings each containing at least part of a key string as one of the leading strings , based on said dictionary data and text data ; . changing means for changing said code string ; . sequence assigning means for assigning a sequence number to each of plural lexicographically registered dictionary data items ; . updating means for updating , based on a contents of the change , the dictionary data , the text data , and a lexicographic order of said code string associated with the change ; and . adjustment range setting means for putting changes into one unit of adjustment work , . wherein said retrieving means counts a number of substrings , each containing an identical leading string , using the sequence numbers of a first dictionary data item and a last dictionary data item .", "label": "", "metadata": {}, "score": "53.031914"}
{"text": "In this way , it prevents the data processing time from being increased just because the associated path is too long , thereby making various types of data processing , such as retrieval or update , more efficient .According to the invention as claimed in claim 33 , the structure adjustment is performed according to the status of the binary tree , because a plurality of processing types are combined to change the structure of a specified range of the binary tree .", "label": "", "metadata": {}, "score": "53.033764"}
{"text": "In this way , it prevents the data processing time from being increased just because the associated path is too long , thereby making various types of data processing , such as retrieval or update , more efficient .According to the invention as claimed in claim 33 , the structure adjustment is performed according to the status of the binary tree , because a plurality of processing types are combined to change the structure of a specified range of the binary tree .", "label": "", "metadata": {}, "score": "53.033764"}
{"text": "Restoring the Text ] .The data processing system in this embodiment uses the text tree and the dictionary tree alternately to restore a text beginning with a specific position .The retrieving means 10 shown in FIG .1 is used to restore a text .", "label": "", "metadata": {}, "score": "53.086456"}
{"text": "( In the case of the floating - point format : . then , the interval retrieving means 33 changes P to : .P-(partial interval length of n - partial interval length of the right child of n ) Formula 6 ! and changes n to the right child of n. .", "label": "", "metadata": {}, "score": "53.104164"}
{"text": "( In the case of the floating - point format : . then , the interval retrieving means 33 changes P to : .P-(partial interval length of n - partial interval length of the right child of n ) Formula 6 ! and changes n to the right child of n. .", "label": "", "metadata": {}, "score": "53.104164"}
{"text": "Variations of the Third Embodiment ] .This embodiment applies not only to the block diagram shown in FIG .30 but also to the dictionary tree and the text tree which have the tree structure shown in FIG .1 .", "label": "", "metadata": {}, "score": "53.105705"}
{"text": "42 is a binary tree representing an index .The right half of FIG .42 , if processed by the code string restoration function described above , is functionally equivalent to Table 23 containing lexicographically - arranged key - candidate substrings ( leading string of a trailing string ) each having an lexicographic order number .", "label": "", "metadata": {}, "score": "53.11145"}
{"text": "If node $ v$ is non - trivial , we store the largest string - depth of a non - trivial node in its subtree as $ lcs(v)$.If $ r$ is the root , then $ lcs(r)$ is the length of the longest common substring of $ S$ and $ T$. Updating the tree after deleting a substring from one of the sequences should not be too hard .", "label": "", "metadata": {}, "score": "53.13"}
{"text": "Thus , the update time can be reduced .The update time depends on the lengths of the affected substring , not on the length of the original code string .This makes it possible to provide a data retrieval system that can be used even when updating is performed frequently .", "label": "", "metadata": {}, "score": "53.15018"}
{"text": "Thus , the update time can be reduced .The update time depends on the lengths of the affected substring , not on the length of the original code string .This makes it possible to provide a data retrieval system that can be used even when updating is performed frequently .", "label": "", "metadata": {}, "score": "53.15018"}
{"text": "50 is an example of a position tree representing the dictionary for the code string \" abbabb$ \" .A suffix tree is a Trie which uses a suffix ( a trailing substring ) of the code string s as the character string wi .", "label": "", "metadata": {}, "score": "53.185913"}
{"text": "claim 4 wherein the data sets are relatively uncorrelated and a signature length of approximately 50 is used .The method as defined in .claim 4 wherein in performing step d ) , maintaining a storage space of log N size for the hashing signatures , where N is the number of tuples in the data set .", "label": "", "metadata": {}, "score": "53.240097"}
{"text": "In this way , it prevents the data processing time from being increased just because the associated path is too long , thereby making various types of data processing , such as retrieval or update , more efficient .Another structure adjustment method eliminates variations in processing times of retrieval , addition , and deletion for a binary tree .", "label": "", "metadata": {}, "score": "53.274437"}
{"text": "In this way , it prevents the data processing time from being increased just because the associated path is too long , thereby making various types of data processing , such as retrieval or update , more efficient .Another structure adjustment method eliminates variations in processing times of retrieval , addition , and deletion for a binary tree .", "label": "", "metadata": {}, "score": "53.274437"}
{"text": "This is used to quickly increment or decrement the iterator across node boundaries .We do not cache the entire path , since that would make rope iterators unpleasantly large .This implementation differs significantly from that used in the C \" cord \" package .", "label": "", "metadata": {}, "score": "53.28586"}
{"text": "This is used to quickly increment or decrement the iterator across node boundaries .We do not cache the entire path , since that would make rope iterators unpleasantly large .This implementation differs significantly from that used in the C \" cord \" package .", "label": "", "metadata": {}, "score": "53.28586"}
{"text": "S . q .S . q .In the investigation , it was found that the inventive method based on set hashing was substantially more accurate than the various prior art estimation methods discussed above .For example , in the case of positive queries , the accuracy was better by up to an order of magnitude .", "label": "", "metadata": {}, "score": "53.35131"}
{"text": "To execute this retrieval , the present invention uses a method different from that used in the prior system ; that is , it follows a path from the root to the specified node .The present invention is superior to the prior system in that it can add or delete a node ( interval ) to or from any position .", "label": "", "metadata": {}, "score": "53.352203"}
{"text": "To execute this retrieval , the present invention uses a method different from that used in the prior system ; that is , it follows a path from the root to the specified node .The present invention is superior to the prior system in that it can add or delete a node ( interval ) to or from any position .", "label": "", "metadata": {}, "score": "53.352203"}
{"text": "In addition , the data retrieval system in the first embodiment has the changing means 10 which changes the code string , and the updating means 11 which updates dictionary data associated with changed data .The data retrieval system in the first embodiment also has the first maintaining means 12 which maintains the boundary interval at the maximum key length or longer and the second maintaining means 13 which maintains the boundary interval at a specified length or less .", "label": "", "metadata": {}, "score": "53.377815"}
{"text": "In addition , the data retrieval system in the first embodiment has the changing means 10 which changes the code string , and the updating means 11 which updates dictionary data associated with changed data .The data retrieval system in the first embodiment also has the first maintaining means 12 which maintains the boundary interval at the maximum key length or longer and the second maintaining means 13 which maintains the boundary interval at a specified length or less .", "label": "", "metadata": {}, "score": "53.377815"}
{"text": "An invention according to a 77 . sup.th illustrative implementation is a data processing method of the 34 . beta.x and .gamma.y which are immediately before and after the shortest trailing string . alpha.w which is longer than said trailing string w in said table , the leading string of the longest trailing string x which is shorter than .", "label": "", "metadata": {}, "score": "53.394264"}
{"text": "[ 0031 ] . XPathExpressions ( XPEs ) and XPE - trees .An XML document comprises a hierarchically nested structure of elements , starting with a root element ; sub - elements of an element can themselves be elements and can also contain character data ( i.e. , text ) and attributes .", "label": "", "metadata": {}, "score": "53.456284"}
{"text": "Specifically , for each cluster we extract all the strongly present phrases in the cluster in which a TD score is less than a threshold term density score ( Th TD ) .Th TD may be defined as the NumOfClusters/4 ( e.g. , we pick all the strongly present phrases in the cluster C i which are not present in more than Th TD of the clusters globally ) .", "label": "", "metadata": {}, "score": "53.46508"}
{"text": "Specifically , for each cluster we extract all the strongly present phrases in the cluster in which a TD score is less than a threshold term density score ( Th TD ) .Th TD may be defined as the NumOfClusters/4 ( e.g. , we pick all the strongly present phrases in the cluster C i which are not present in more than Th TD of the clusters globally ) .", "label": "", "metadata": {}, "score": "53.46508"}
{"text": "These cross - counts can then be combined using conditional probabilities of the subqueries based on the inclusion - exclusion principle from set theory .In particular , .Pr . abc .Pr .Pr .Pr .Pr .I .", "label": "", "metadata": {}, "score": "53.467632"}
{"text": "4 .In the KD method , a query q is parsed using the maximal overlap ( MO ) principle , where in a greedy fashion the query q is broken into a plurality of subqueries overlapping in multiple dimensions .Each subquery is defined as the match in the tree that most overlaps the prior subquery .", "label": "", "metadata": {}, "score": "53.489136"}
{"text": "The text functions ( t3 ) and ( t6 ) described above are used to find a text item to be deleted .The text function ( t13 ) is used to delete a text item efficiently .To update a start position , the interval control method is used to update the start positions of text items .", "label": "", "metadata": {}, "score": "53.491333"}
{"text": "The methodology of the present invention is set - oriented , where pruned suffix tress ( PSTs ) are first constructed on each dimension .A set is created for each node in each tree , the set containing the row identifiers ( RIDs ) of each tuple containing that node in its substring .", "label": "", "metadata": {}, "score": "53.5199"}
{"text": "The removing means 9 removes this duplicate entries as described above , preventing confusion .In the first embodiment , the retrieval time depends , not on the code string length , but approximately on the number of occurrences .This means that retrieving a key string from a long code string does not take long .", "label": "", "metadata": {}, "score": "53.61317"}
{"text": "The removing means 9 removes this duplicate entries as described above , preventing confusion .In the first embodiment , the retrieval time depends , not on the code string length , but approximately on the number of occurrences .This means that retrieving a key string from a long code string does not take long .", "label": "", "metadata": {}, "score": "53.61317"}
{"text": "According to the invention as claimed in claim 31 , processing is performed speedily because only the node of the root need be adjusted during deletion .An invention according to claim 32 is a data processing system as claimed in claim 22 , further comprising structure adjusting means for adjusting the structure of the binary tree by changing the connection sequence of the nodes .", "label": "", "metadata": {}, "score": "53.624237"}
{"text": "According to the invention as claimed in claim 31 , processing is performed speedily because only the node of the root need be adjusted during deletion .An invention according to claim 32 is a data processing system as claimed in claim 22 , further comprising structure adjusting means for adjusting the structure of the binary tree by changing the connection sequence of the nodes .", "label": "", "metadata": {}, "score": "53.624237"}
{"text": "In the eighth embodiment described above , the function ( t5 ) is equivalent to the function ( t3 ) in a special case .However , it should be remembered that the retrieval function of the interval control method performs the same function even if there is an interval whose length is not 1 .", "label": "", "metadata": {}, "score": "53.642662"}
{"text": "There are two important parameters than can affect multidimensional selectivity estimates based on set hashing : the signature length and the hash space size .With respect to signature length , it was previously shown that the accuracy of set hashing intersection estimates improve with increasing signature length .", "label": "", "metadata": {}, "score": "53.66736"}
{"text": "Furthermore , while XTrie ignores partial matchings of tree patterns that are redundant , XFilter keeps tracks of all instances of partially matched tree patterns , which results in more processing overhead .[ 0091 ] .Turning now to FIG .", "label": "", "metadata": {}, "score": "53.67261"}
{"text": "The simplest code string retrieval method is to match a key string against a code string sequentially from the beginning to the end .However , in this method , the retrieval time increases as the character string s becomes longer .", "label": "", "metadata": {}, "score": "53.68923"}
{"text": "The simplest code string retrieval method is to match a key string against a code string sequentially from the beginning to the end .However , in this method , the retrieval time increases as the character string s becomes longer .", "label": "", "metadata": {}, "score": "53.68923"}
{"text": "FIG .3 contains a matrix of each of the cross - counts between the parsed substrings .For example , the cross - count between ab and 2 is \" 3 \" , meaning that there are three different substrings that include the combination of ab with 2 .", "label": "", "metadata": {}, "score": "53.75696"}
{"text": "According to this invention , the retrieving means 8 can retrieve data by finding a trailing string containing all or some sub - keys p 's which are created by dividing the key string into a plurality of sub - keys ( FIG .", "label": "", "metadata": {}, "score": "53.775055"}
{"text": "According to this invention , the retrieving means 8 can retrieve data by finding a trailing string containing all or some sub - keys p 's which are created by dividing the key string into a plurality of sub - keys ( FIG .", "label": "", "metadata": {}, "score": "53.775055"}
{"text": "\" in the index with \" .alpha.ux . . . \" .And , if \" x \" is involved in the comparison , it can be said that \" the index may have to be re - arranged \" for \" .", "label": "", "metadata": {}, "score": "53.789875"}
{"text": "Moreover , the distribution of errors was found to be considerably more favorable for the inventive set hashing method in the instances where certain queries yielded poor estimates .In particular , for the set hashing method , the number of cross - counts that can be generated increases quadratically , bringing about a rapid drop in the error .", "label": "", "metadata": {}, "score": "53.790993"}
{"text": "In accordance with the present invention , therefore , it is recognized that a hash function may be used to store the sets associated with each node .Thus , in accordance with the present invention , hash functions are used that allow for some approximation in estimating the intersection sizes .", "label": "", "metadata": {}, "score": "53.795097"}
{"text": "According to the invention as claimed in claim 28 , processing is simplified because partial interval lengths need be changed ( increased ) only for a small number of nodes including the root node .According to the invention as claimed in claim 29 , processing is performed speedily because the partial interval length of a node need be increased only once using the desired addition algorithm .", "label": "", "metadata": {}, "score": "53.827393"}
{"text": "According to the invention as claimed in claim 28 , processing is simplified because partial interval lengths need be changed ( increased ) only for a small number of nodes including the root node .According to the invention as claimed in claim 29 , processing is performed speedily because the partial interval length of a node need be increased only once using the desired addition algorithm .", "label": "", "metadata": {}, "score": "53.827393"}
{"text": "Although concatenation is efficient independent of the shape of the tree , some other operations such as retrieving the i th character , are more efficient if the tree representing the rope is approximately balanced .Ropes can be rebalanced either via an explicit call to the balance member function , or implicitly as the result of a concatenation .", "label": "", "metadata": {}, "score": "53.842636"}
{"text": "Although concatenation is efficient independent of the shape of the tree , some other operations such as retrieving the i th character , are more efficient if the tree representing the rope is approximately balanced .Ropes can be rebalanced either via an explicit call to the balance member function , or implicitly as the result of a concatenation .", "label": "", "metadata": {}, "score": "53.842636"}
{"text": "The rope implementation can use either standard - conforming allocators ( compiler permitting ) or SGI - style simplified allocators .In the former case and if there are distinct allocator instances of a given allocator type , the allocator instance is stored in each rope tree node , as well as in the rope itself .", "label": "", "metadata": {}, "score": "53.89539"}
{"text": "The rope implementation can use either standard - conforming allocators ( compiler permitting ) or SGI - style simplified allocators .In the former case and if there are distinct allocator instances of a given allocator type , the allocator instance is stored in each rope tree node , as well as in the rope itself .", "label": "", "metadata": {}, "score": "53.89539"}
{"text": "( 2 ) Because data is stored by plural codes , it takes long to determine a range of the consecutive codes of the same value .That is , to identify a range of consecutive codes of the same value , it is necessary to read code values , one at a time , and to count the number of code values .", "label": "", "metadata": {}, "score": "53.92477"}
{"text": "( 2 ) Because data is stored by plural codes , it takes long to determine a range of the consecutive codes of the same value .That is , to identify a range of consecutive codes of the same value , it is necessary to read code values , one at a time , and to count the number of code values .", "label": "", "metadata": {}, "score": "53.92477"}
{"text": "Increasing the efficiency of Trailing String Comparison ] .When a trailing string is registered in the index , it is necessary to compare it with another trailing string already registered in the index .In this case , comparing two trailing strings , each having the identical long leading string , takes long time .", "label": "", "metadata": {}, "score": "53.93271"}
{"text": "86 shows an example of data used in a conventional fourth method .13 : Second maintaining means .31 : Binary tree .32 : Binary tree generating means .33 : Interval retrieving means .34 : Binary tree updating means .", "label": "", "metadata": {}, "score": "53.933178"}
{"text": "86 shows an example of data used in a conventional fourth method .13 : Second maintaining means .31 : Binary tree .32 : Binary tree generating means .33 : Interval retrieving means .34 : Binary tree updating means .", "label": "", "metadata": {}, "score": "53.933178"}
{"text": "When one or more index items are found in ( x3 ) , the function determines the first and the last item .( x6 )The function determines an item immediately before or after a specific index item .That is , for any of the items from the first to the last determined in ( x5 ) , the function ( x6 ) determines an item immediately before or after a specific index item .", "label": "", "metadata": {}, "score": "53.937714"}
{"text": "\" , \" the index item need not be re - arranged \" .[ 7 .Seventh Embodiment ] .In this embodiment , \" dictionary data \" and a \" dictionary tree \" used in the above embodiments are treated as a higher - level concept \" index \" , and \" text data \" and a \" text tree \" as a higher - level concept \" text \" .", "label": "", "metadata": {}, "score": "53.963875"}
{"text": "In this case , if the leaves in question are sufficiently short , we may either allocate a new leaf holding the combined contents of the two leaves or , under the right circumstances , even update the left operand in place .", "label": "", "metadata": {}, "score": "53.987736"}
{"text": "In this case , if the leaves in question are sufficiently short , we may either allocate a new leaf holding the combined contents of the two leaves or , under the right circumstances , even update the left operand in place .", "label": "", "metadata": {}, "score": "53.987736"}
{"text": "A data processing system as claimed in claim 1 , wherein a character string is stored in said dictionary tree and the character string is not stored in said text tree .A data processing system as claimed in claim 8 , wherein the length of a character string stored in said dictionary tree is equal to the length represented by the corresponding node in the text tree .", "label": "", "metadata": {}, "score": "54.02517"}
{"text": "If there is a mismatch , return to step 457 , check whether or not current node has right child .In that case , once a mismatching node is found , the check may be suspended because it is apparent that any node on the path from that node to the root does not match the leading string of the pattern .", "label": "", "metadata": {}, "score": "54.043922"}
{"text": "This logical operation removes superfluous or redundant strings or substrings from the data .Next , an operation 1106 is executed that transmits the remaining query data ( e.g. demand data ) to the STC algorithm for clustering .FIG .12 is a flowchart illustrating an example execution of a method used to implement operation 205 .", "label": "", "metadata": {}, "score": "54.07276"}
{"text": "This logical operation removes superfluous or redundant strings or substrings from the data .Next , an operation 1106 is executed that transmits the remaining query data ( e.g. demand data ) to the STC algorithm for clustering .FIG .12 is a flowchart illustrating an example execution of a method used to implement operation 205 .", "label": "", "metadata": {}, "score": "54.07276"}
{"text": "Then , the following steps are repeated until the current node becomes the root ( step 132 ) .That is , the current node is moved to the parent with the old current node as the child node ( step 133 ) .", "label": "", "metadata": {}, "score": "54.085617"}
{"text": "For example , when node D is deleted from the binary tree 31 in FIG .19 , the structure after deletion may be the one shown in FIG .20 or the one shown in FIG .21 .[ B-4 - 4 .", "label": "", "metadata": {}, "score": "54.17663"}
{"text": "The procedure for comparing trailing strings whose trailing strings may already be registered in the index .The trailing strings to be compared are u and v. .( 1 ) x.rarw.u , y.rarw.v .( 2 ) Compare the first character of x with the first character of y. If they do not match , the comparison result is the comparison result of u and v. .", "label": "", "metadata": {}, "score": "54.246723"}
{"text": "The ability to use a precision most suitable for each interval allows the user to use any type of interval data such as floating - point data .In this data processing system , the position of the interval of a node can be calculated , during retrieval or some other processing , based on the interval length of the preceding node .", "label": "", "metadata": {}, "score": "54.284355"}
{"text": "In some embodiments , bidirectional edges are used to connect the various nodes that make up this merged cluster map .In addition to a bare overlap value , additional factors such as a relevancy weighting factor , a seller factor , a price factor , a category factor , an image factor or some other suitable factor may be used as a basis for merging clusters .", "label": "", "metadata": {}, "score": "54.2985"}
{"text": "In some embodiments , bidirectional edges are used to connect the various nodes that make up this merged cluster map .In addition to a bare overlap value , additional factors such as a relevancy weighting factor , a seller factor , a price factor , a category factor , an image factor or some other suitable factor may be used as a basis for merging clusters .", "label": "", "metadata": {}, "score": "54.2985"}
{"text": "The third embodiment having the configuration described above performs operation as follows .[ 3 - 2 - 1 .Dictionary Data Generation ] .First , the following explains how data in this embodiment is structured .In this embodiment , the dictionary data consists , not of individual key - candidate substrings , but of pointers to text data each corresponding to the start position of each substring within the code string .", "label": "", "metadata": {}, "score": "54.338005"}
{"text": "42 is functionally equivalent to Table 22 containing pairs each consisting of a key - candidate substring ( leading string of a trailing string ) and its start position , arranged in order of start positions .From this binary tree , the system can retrieve a part of a specified position and the corresponding key - candidate substring ( leading string of a trailing string ) .", "label": "", "metadata": {}, "score": "54.35524"}
{"text": "Another structure adjustment method eliminates variations in processing times of retrieval , addition , and deletion for a binary tree .Structure adjustment is necessary for node deletion , addition , or reference .A plurality of structure adjustment methods are known .", "label": "", "metadata": {}, "score": "54.358925"}
{"text": "However , as the dimensionality increases , the number of signature intersections needed to generate a cross - count also increases , which will in turn lead to increased error in approximating each cross - count .To assess the accuracy of set hashing with increasing dimensionality , an experiment was conducted using two- , three- , and four - dimensional data sets , extracted from a large warehouse of public data .", "label": "", "metadata": {}, "score": "54.391018"}
{"text": "[ 1 - 2 - 1 - 3 .Inserting a Character String into a Text ] .When a character string is inserted into a text , the updating means 12 re - arranges the affected dictionary items as with the change of a character in the text and , at the same time , adds new items .", "label": "", "metadata": {}, "score": "54.408325"}
{"text": "When the current node becomes the root ( step 282 ) , the left end of the specified node is immediately left to the left interval ; that is , it is calculated by adding 1 to the left interval length ( step 287 ) .", "label": "", "metadata": {}, "score": "54.412636"}
{"text": "When the current node becomes the root ( step 282 ) , the left end of the specified node is immediately left to the left interval ; that is , it is calculated by adding 1 to the left interval length ( step 287 ) .", "label": "", "metadata": {}, "score": "54.412636"}
{"text": "When the text is changed , the dictionary data is changed and , as a result , the lexicographic order is changed ; in this case , the updating means 12 updates the lexicographic order of the dictionary data items via the sequence assigning means 30 .", "label": "", "metadata": {}, "score": "54.418114"}
{"text": "When one of trailing strings in the range is compared with the code string in the binary search method , the result of comparison in which the common leading string is bypassed is the same as the result of comparison in which comparison starts at the first code .", "label": "", "metadata": {}, "score": "54.420197"}
{"text": "77 is a table showing the correspondence between code strings and positions in a conventional code string retrieval method ; .FIG .78 shows an example of a conventional position tree ; .FIG .79 shows an example of conventional suffix tree ; .", "label": "", "metadata": {}, "score": "54.460175"}
{"text": "77 is a table showing the correspondence between code strings and positions in a conventional code string retrieval method ; .FIG .78 shows an example of a conventional position tree ; .FIG .79 shows an example of conventional suffix tree ; .", "label": "", "metadata": {}, "score": "54.460175"}
{"text": "A data processing system as claimed in claim 1 , or 2 , further comprising a binary tree updating means for updating said binary tree , when said interval is changed , according to the contents of the change .A data processing system as claimed in claim 4 , wherein said binary tree updating means comprising : . an interval length changing means for changing said interval length ; . a deleting means for deleting said node corresponding to a deleted interval from said binary tree when said interval is deleted ; and . an adding means for adding a node corresponding to an added interval when an interval is added .", "label": "", "metadata": {}, "score": "54.466564"}
{"text": "A data processing system as claimed in claim 1 , or 2 , further comprising a binary tree updating means for updating said binary tree , when said interval is changed , according to the contents of the change .A data processing system as claimed in claim 4 , wherein said binary tree updating means comprising : . an interval length changing means for changing said interval length ; . a deleting means for deleting said node corresponding to a deleted interval from said binary tree when said interval is deleted ; and . an adding means for adding a node corresponding to an added interval when an interval is added .", "label": "", "metadata": {}, "score": "54.466564"}
{"text": "For example , in FIG .22 , when an interval 10 . . .12 ! with the length of 3 is added before the interval 10 . . .15 !with the intervals 10 . . .15 ! and 16 . . .", "label": "", "metadata": {}, "score": "54.599762"}
{"text": "For example , in FIG .22 , when an interval 10 . . .12 ! with the length of 3 is added before the interval 10 . . .15 !with the intervals 10 . . .15 ! and 16 . . .", "label": "", "metadata": {}, "score": "54.599762"}
{"text": "If n has no left child and if : .( In the case of the floating - point format : . or , if n has no right child and if : .( In the case of the floating - point format : . then , the interval containing the specified position is not yet stored .", "label": "", "metadata": {}, "score": "54.602524"}
{"text": "If n has no left child and if : .( In the case of the floating - point format : . or , if n has no right child and if : .( In the case of the floating - point format : . then , the interval containing the specified position is not yet stored .", "label": "", "metadata": {}, "score": "54.602524"}
{"text": "Depth fields are guaranteed to fit into a byte , since we impose a static maximum on rope depth .Reference Counting and Synchronization .The rope implementation can be compiled in two different ways .Normally _ _ GC will not be defined .", "label": "", "metadata": {}, "score": "54.621567"}
{"text": "Depth fields are guaranteed to fit into a byte , since we impose a static maximum on rope depth .Reference Counting and Synchronization .The rope implementation can be compiled in two different ways .Normally _ _ GC will not be defined .", "label": "", "metadata": {}, "score": "54.621567"}
{"text": "When the search is terminated , the result of ( x11 ) is the index item representing the last - reached node and the child to which control is to be moved ( inserted immediately before for the left child , or inserted immediately after for the right child ) .", "label": "", "metadata": {}, "score": "54.63112"}
{"text": "The time required to restore the substring does not depend on the length of the original code string .A substring may also be restored by traversing the edge to the end node in the backward direction to the root to reverse the label order .", "label": "", "metadata": {}, "score": "54.65113"}
{"text": "The time required to restore the substring does not depend on the length of the original code string .A substring may also be restored by traversing the edge to the end node in the backward direction to the root to reverse the label order .", "label": "", "metadata": {}, "score": "54.65113"}
{"text": "A data retrieval method comprising the steps of : . generating text data based on said code string ; and . retrieving trailing strings each containing the whole or part of a key string as the leading string , based on said dictionary data .", "label": "", "metadata": {}, "score": "54.665833"}
{"text": "A data processing system as claimed in claim 11 , wherein the length of a key - candidate substring constituting said dictionary data is not limited .A data processing system as claimed in claim 11 , wherein at least one of said dictionary data generating means and text data generating means establishes pointers between said dictionary data and text data .", "label": "", "metadata": {}, "score": "54.698727"}
{"text": "In one embodiment , the cluster label acts as the label of the base cluster that contains the highest number of documents .In another embodiment , the labeling of the cluster is performed using the most frequent phrases in the cluster .", "label": "", "metadata": {}, "score": "54.70521"}
{"text": "In one embodiment , the cluster label acts as the label of the base cluster that contains the highest number of documents .In another embodiment , the labeling of the cluster is performed using the most frequent phrases in the cluster .", "label": "", "metadata": {}, "score": "54.70521"}
{"text": "In this case , the alpha data dimension is parsed into ab , b , and c , and the numeric data dimension is parsed into 12 , 2 and 3 .This parsing is a form of \" greedy parsing \" ( i.e. , includes overlap ) , and is illustrated diagrammatically in FIG .", "label": "", "metadata": {}, "score": "54.71254"}
{"text": "It may be any type of code , such as a voice pattern code or DNA base layout code .In addition , a substring in a code string may be processed indirectly , for example , by marking a boundary through a pointer .", "label": "", "metadata": {}, "score": "54.759403"}
{"text": "It may be any type of code , such as a voice pattern code or DNA base layout code .In addition , a substring in a code string may be processed indirectly , for example , by marking a boundary through a pointer .", "label": "", "metadata": {}, "score": "54.759403"}
{"text": "Repeat this operation until the restored code string equals the specified length .When the text items for all the trailing strings are not generated , the following ( extended or inclusive ) function ( t5 ) is used instead of the above function ( t3 ) .", "label": "", "metadata": {}, "score": "54.79173"}
{"text": "1 updates the dictionary data 2 as described above .That is , the start position of a substring which contains the character that is in the forth position in the text and whose length is 3 is 4 , 3 , or 2 .", "label": "", "metadata": {}, "score": "54.84094"}
{"text": "Further illustrated is a position 808 that roughly corresponds to node 18 referenced as 711 containing the string \" Opener \" and also documents containing the substring \" Bottle Opener \" ( e.g. , 1234 ) .Additionally , a position 809 is illustrated containing the substring \" Cap \" wherein the substring \" Cap \" contains documents 0 and 3 .", "label": "", "metadata": {}, "score": "54.843384"}
{"text": "Further illustrated is a position 808 that roughly corresponds to node 18 referenced as 711 containing the string \" Opener \" and also documents containing the substring \" Bottle Opener \" ( e.g. , 1234 ) .Additionally , a position 809 is illustrated containing the substring \" Cap \" wherein the substring \" Cap \" contains documents 0 and 3 .", "label": "", "metadata": {}, "score": "54.843384"}
{"text": "To perform retrieval , the control section C accesses pointers to reference each node , and the operation section A accesses the partial interval length of each node to calculate interval lengths .The pointer or the storage address of the current node is stored in the current register CR .", "label": "", "metadata": {}, "score": "54.86328"}
{"text": "To perform retrieval , the control section C accesses pointers to reference each node , and the operation section A accesses the partial interval length of each node to calculate interval lengths .The pointer or the storage address of the current node is stored in the current register CR .", "label": "", "metadata": {}, "score": "54.86328"}
{"text": "It should be pointed out that , since multiple matches of the same XPE are usually not of interest , unnecessary processing and checking in MATCH - SUBSTRING for XPEs that have already been matched can advantageously be eliminated .This can be achieved by using a bit - mask ( consisting of one bit per XPE ) ; details of this additional filtering have been omitted from FIG .", "label": "", "metadata": {}, "score": "54.885235"}
{"text": "FIGS . 8A- 8 D together illustrate experimental pertaining to one embodiment of a system constructed according to the principles of the present invention .DETAILED DESCRIPTION .[ 0026 ] .The key technique for expediting XPE retrieval is to construct an appropriate index structure on the given collection of XPE subscriptions .", "label": "", "metadata": {}, "score": "54.924088"}
{"text": "gamma.y , preceded by the leading string of x in said table , and if . alpha . beta . or .alpha . gamma .According to the inventions of the 76 . sup.th and 77 .An invention according to a 78 . sup.th illustrative implementation is a data processing method of the 34 .", "label": "", "metadata": {}, "score": "54.9318"}
{"text": "When a character is changed , inserted or deleted , the change positions described above refers to the respective positions shown in FIG .32 .[ 3 - 3 .Combining with the text ] .In this embodiment , the size of the storage area may be reduced by combining the index ( dictionary ) with the text , as in the second embodiments .", "label": "", "metadata": {}, "score": "54.95152"}
{"text": "( x14 )The function checks the index to see if a specified index item is registered in it .The three procedures described above may be grouped in any way and may be executed in any order .Step ( 1 ) and ( b ) of ( 2 ) may be executed at the same time .", "label": "", "metadata": {}, "score": "54.99511"}
{"text": "Of course , it is possible to proceed from left to right or in any other order .The procedure described in [ 6.2.4 Increasing the Efficiency of Index Updating ( A ) ( B ) ] may be used together in registering these index items .", "label": "", "metadata": {}, "score": "55.025253"}
{"text": "A change to the code string may affect the key - candidate substring ( leading string of a trailing string ) of some index items .This procedure identifies which index item will move to another position in the index .Whether or not the index item should be temporarily deleted from the index depends on the embodiment .", "label": "", "metadata": {}, "score": "55.03781"}
{"text": "This means that the first character \" c \" of the dictionary item \" cab \" is in position 5 .The character in position 6 is retrieved as follows .In method ( 1 ) described above , because position 5 corresponds to the end of the dictionary item , the \" interval control method \" is used again to retrieve the node in the text tree corresponding to position 6 to get node Z. The first character of the character string in the interval [ 6 , 7 ] represented by the node is in character 6 .", "label": "", "metadata": {}, "score": "55.072067"}
{"text": "5 will require O ( 10 ) space , which is linear in the size of the PSTs .Summarizing the methodology of the present invention , PSTs are first created on each dimension and sets associated with each node are created and then transformed into a hashed value .", "label": "", "metadata": {}, "score": "55.139618"}
{"text": "For example , a substring changes and variable in length when edited .So , to process a substring , it is always necessary to match a substring with a particular position within the code string .A substring is difficult to process not only in data retrieval but also in many other data processing fields such as data compression or character string editing .", "label": "", "metadata": {}, "score": "55.144135"}
{"text": "For example , a substring changes and variable in length when edited .So , to process a substring , it is always necessary to match a substring with a particular position within the code string .A substring is difficult to process not only in data retrieval but also in many other data processing fields such as data compression or character string editing .", "label": "", "metadata": {}, "score": "55.144135"}
{"text": "1 is a diagram of a system for using search clustering , according to an example embodiment .FIG .2 is a flowchart illustrating a method used to implement a system for search clustering , according to an example embodiment .", "label": "", "metadata": {}, "score": "55.209312"}
{"text": "1 is a diagram of a system for using search clustering , according to an example embodiment .FIG .2 is a flowchart illustrating a method used to implement a system for search clustering , according to an example embodiment .", "label": "", "metadata": {}, "score": "55.209312"}
{"text": "Let the shorter of the upper - limit matching leading - string length and the lower - limit matching leading - string length be \" k \" ( Now , both are \" 0 \" ) .[ TABLE 16 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a b a b a b c a b a b c a b Upper limit 1 . fwdarw .", "label": "", "metadata": {}, "score": "55.25388"}
{"text": "Furthermore , simplistic approaches ( e.g. , building an index based solely on the element names contained in the XPEs ) can result in very ineffective retrieval schemes that incur a lot of unnecessary checking of ( irrelevant ) XPE subscriptions .", "label": "", "metadata": {}, "score": "55.28424"}
{"text": "If the relation has been changed , the trailing string is re - arranged .This operation continues as far as the key relation in the index changes after the character has been added .Once a trailing string is found where there is no change in the relation , the re - arrange operation stops and no check is made on the longer trailing strings .", "label": "", "metadata": {}, "score": "55.284523"}
{"text": "If a trailing string whose leading string matches the whole pattern is found , the index item is one of the index items to be searched for .If there is no trailing string whose leading string matches the whole pattern , processing is performed as follows .", "label": "", "metadata": {}, "score": "55.291027"}
{"text": "If current node has no right child , first node is the upper limit .On the other hand , if current node has right child , this right child of current node is set as the current node ( step 458 ) and check whether or not leading string of trailing string in current node matches longest matching pattern ( step 459 ) .", "label": "", "metadata": {}, "score": "55.30919"}
{"text": "When adding or deleting an interval , the structure adjusting means 45 changes the connection sequence of nodes to maintain the balance of the number of nodes in the binary tree 31 .This structure adjustment method prevents only a particular part of the binary tree 31 from being increased , making a plurality of paths , each from the root to a node , approximately equal in length .", "label": "", "metadata": {}, "score": "55.32682"}
{"text": "[ 10 .Tenth Embodiment ] .This embodiment uses an index and a text , such as those shown in Table 24 , to realize a procedure described in [ 6 - 2 - 5 .Increasing the Efficiency of the Procedure for Determining a Range Where Index Item Re - arranging Is Required to the Left of a Changed Position].", "label": "", "metadata": {}, "score": "55.33535"}
{"text": "[ 2 - 2 . Operation And Effects of the Second Embodiment ] .The second embodiment having the configuration described above performs operation as follows .[ 2 - 2 - 1 .Storing the Text in the Dictionary ] .", "label": "", "metadata": {}, "score": "55.399864"}
{"text": "Thus , when a character string is inserted or deleted , the data structure is adjusted for use in retrieval within the time calculated by the following formula : .In addition , the high - speed update of data for retrieval makes data processing more speedily and the processing procedure simpler .", "label": "", "metadata": {}, "score": "55.42683"}
{"text": "The interval length register LR is used as necessary to calculate partial interval lengths .Hardware having this configuration may be used in various types of processing described below .Binary Tree Update Process !When an interval is changed , the binary tree updating means 34 updates the binary tree 31 according to the contents of the change .", "label": "", "metadata": {}, "score": "55.436687"}
{"text": "The interval length register LR is used as necessary to calculate partial interval lengths .Hardware having this configuration may be used in various types of processing described below .Binary Tree Update Process !When an interval is changed , the binary tree updating means 34 updates the binary tree 31 according to the contents of the change .", "label": "", "metadata": {}, "score": "55.436687"}
{"text": "Then we start processing the suffixes preceding the deleted substring .Let $ v$ be the lowest non - trivial ancestor of the current leaf .If $ k \\ge lcs(v)$ , we are done , as we are not interested in subtrees with trivial roots .", "label": "", "metadata": {}, "score": "55.44088"}
{"text": "FIG .4 is a diagram showing the data structure when a character is inserted into or deleted from the first embodiment of this invention ; .FIG .5 is a functional block diagram showing the structure of a data processing system using an \" interval control method \" ; .", "label": "", "metadata": {}, "score": "55.54492"}
{"text": "2 is a flowchart illustrating an example method 200 showing the operational flow of the previously illustrated clustering system .Shown is a query 108 that is received by , for example , the application server 111 .Once received , an operation 201 is executed that sends an HTTP call to a relevancy weighting system .", "label": "", "metadata": {}, "score": "55.54725"}
{"text": "2 is a flowchart illustrating an example method 200 showing the operational flow of the previously illustrated clustering system .Shown is a query 108 that is received by , for example , the application server 111 .Once received , an operation 201 is executed that sends an HTTP call to a relevancy weighting system .", "label": "", "metadata": {}, "score": "55.54725"}
{"text": "updating , based on a change to said code string , an index of said code string associated with the change , .A data retrieval method comprising the steps of : . generating said index ; and . generating said text , .", "label": "", "metadata": {}, "score": "55.56537"}
{"text": "This is because a key - candidate trailing string is not determined until the end of the text is read .An attempt to register a key - candidate trailing string into the index before it is determined may require the string to be re - arranged later , decreasing efficiency .", "label": "", "metadata": {}, "score": "55.586494"}
{"text": "As shown in FIG .45 , one of nodes described above nearest to the root is set as the first node ( step 451 ) and this first node is set as the current node ( step 452 ) .Then , check whether or not current node has left child ( step 453 ) , if current node has no left child , current node is determined as first node and first node is the upper limit .", "label": "", "metadata": {}, "score": "55.62362"}
{"text": "And an invention according to a 22 .According to the data processing system of the 21 .sup.st illustrative implementation and the data processing method of the 22 . sup.nd illustrative implementation , the number of appearances of a pattern may be obtained by simply checking the positions of two items in the dictionary data .", "label": "", "metadata": {}, "score": "55.670822"}
{"text": "Then , select one trailing string that is smaller than the upper limit and larger than the lower limit ( the central trailing string \" babcab \" in this example ) , and let it be \" s \" .TABLE 18 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a b a b a b c a b a b c a b b Upper limit 2 . fwdarw .", "label": "", "metadata": {}, "score": "55.681366"}
{"text": "Repeats occuring only in S or only in T should olso be eliminated at this point .Repeats that have n't been eliminated are then put on a priority queue , with priority defined by length .After the traversal , as recorded repeats are removed from the priority , the final filtering ( for substring containment ) can be carried out .", "label": "", "metadata": {}, "score": "55.770504"}
{"text": "14 , the lengths of both the right interval and the left interval are obtained , and the interval of the specified node is determined as an interval between these two intervals .Then , the following steps are repeated until the current node becomes the root node ( step 142 ) .", "label": "", "metadata": {}, "score": "55.82696"}
{"text": "Since the total number of substrings is very large , this approach would be very close in accuracy to one that makes the uniformity assumption , which is known to be highly inaccurate .Moreover , the need to retain all substrings with high counts becomes aggravated as the dimensionality increases .", "label": "", "metadata": {}, "score": "55.83046"}
{"text": "Therefore , when one or more characters are deleted from the text , this embodiment significantly reduces the time needed to update the dictionary .[ 1 - 3 .Effects of the First Embodiment ] .In the first embodiment , the time needed to retrieve items from the dictionary or to add or delete one item to or from the dictionary is proportional to the logarithm of the total number of items in the dictionary .", "label": "", "metadata": {}, "score": "55.845016"}
{"text": "9 .The dashed boxes in FIG .9 indicate the approximate counts associated with each parsing , where it is to be remembered that the cross - count for overlap region III is also computed .In the look - up step , the cross - counts for ( ab , 123 ) , ( bc , 123 ) and ( b , 123 ) are generated via set hashing , where these generated cross - counts may have the values of 0.27 , 0.44 and 0.63 , respectively .", "label": "", "metadata": {}, "score": "55.86721"}
{"text": "In this case , there is no one - to - one correspondence .It should be kept in mind that , for those substrings registered in the dictionary , there is a one - to - one correspondence .If this is the case , it is possible to combine the dictionary and the text as shown in FIG .", "label": "", "metadata": {}, "score": "55.89351"}
{"text": "Some embodiments may include a separating engine 1005 to filter item data from noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .Also , the suffix ordering may be stored in a data structure that includes at least one of a trie , a hash table , a binary search tree , a red - black tree , and a heap .", "label": "", "metadata": {}, "score": "55.91233"}
{"text": "Some embodiments may include a separating engine 1005 to filter item data from noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .Also , the suffix ordering may be stored in a data structure that includes at least one of a trie , a hash table , a binary search tree , a red - black tree , and a heap .", "label": "", "metadata": {}, "score": "55.91233"}
{"text": "Therefore , the number of required trees is less than that required when an independent tree is created for each dictionary data unit and therefore less memory is required .This is effective especially for a code string containing a plurality of identical or similar components .", "label": "", "metadata": {}, "score": "55.92504"}
{"text": "Therefore , the number of required trees is less than that required when an independent tree is created for each dictionary data unit and therefore less memory is required .This is effective especially for a code string containing a plurality of identical or similar components .", "label": "", "metadata": {}, "score": "55.92504"}
{"text": "When an interval is added to the code string , the adding means 42 adds the node corresponding to the added interval to the binary tree 31 .As described above , the interval length changing means , the deleting means , or the adding means updates the binary tree 31 when an interval length is changed , an interval is deleted , or an interval is added .", "label": "", "metadata": {}, "score": "55.949516"}
{"text": "I know it can be solved by repeatedly constructing a GST after every iteration of finding and removing the LCS .But , I am wondering if i am missing a neat trick where in the GST is constructed only once .", "label": "", "metadata": {}, "score": "55.962708"}
{"text": "A CLE BD approach may be implemented , in some embodiments , where one would like to have the single best concept within the cluster rather than multiple tags that could occur within the cluster .The single best concept could be extracted by selecting the best document that best represents the majority of the other documents within the cluster .", "label": "", "metadata": {}, "score": "56.03275"}
{"text": "A CLE BD approach may be implemented , in some embodiments , where one would like to have the single best concept within the cluster rather than multiple tags that could occur within the cluster .The single best concept could be extracted by selecting the best document that best represents the majority of the other documents within the cluster .", "label": "", "metadata": {}, "score": "56.03275"}
{"text": "74 shows a binary tree in the eighth embodiment of this invention ; .FIG .75 shows an example of a pattern in a character string used in a conventional code string retrieval method ; .FIG .76 shows an example of a conventional Trie ; .", "label": "", "metadata": {}, "score": "56.032913"}
{"text": "74 shows a binary tree in the eighth embodiment of this invention ; .FIG .75 shows an example of a pattern in a character string used in a conventional code string retrieval method ; .FIG .76 shows an example of a conventional Trie ; .", "label": "", "metadata": {}, "score": "56.032913"}
{"text": "In some embodiments , the demand factor and the relationship of items and categories to the query terms may be represented using one or more Artificial Intelligence ( AI ) based structures and algorithms .The nodes of the network may then be traversed based upon the weighted values expressed in the edges .", "label": "", "metadata": {}, "score": "56.03847"}
{"text": "In some embodiments , the demand factor and the relationship of items and categories to the query terms may be represented using one or more Artificial Intelligence ( AI ) based structures and algorithms .The nodes of the network may then be traversed based upon the weighted values expressed in the edges .", "label": "", "metadata": {}, "score": "56.03847"}
{"text": "For example , when node D is deleted from the binary tree 31 in FIG .39 , the structure after deletion may be the one shown in FIG .40 or the one shown in FIG .41 .The following discussion focuses on the case that the only nodes whose parent nodes are changed after deletion are the child nodes of the deleted node .", "label": "", "metadata": {}, "score": "56.064354"}
{"text": "For example , when node D is deleted from the binary tree 31 in FIG .39 , the structure after deletion may be the one shown in FIG .40 or the one shown in FIG .41 .The following discussion focuses on the case that the only nodes whose parent nodes are changed after deletion are the child nodes of the deleted node .", "label": "", "metadata": {}, "score": "56.064354"}
{"text": "Further , a second tier may be a logic tier that performs application processing in the form of logical / mathematical manipulations of data inputted through the interface level , and communicates the results of these logical / mathematical manipulations to the interface tier , and/or to a backend or storage tier .", "label": "", "metadata": {}, "score": "56.070568"}
{"text": "Further , a second tier may be a logic tier that performs application processing in the form of logical / mathematical manipulations of data inputted through the interface level , and communicates the results of these logical / mathematical manipulations to the interface tier , and/or to a backend or storage tier .", "label": "", "metadata": {}, "score": "56.070568"}
{"text": "Conversely , limiting the length of a key to the minimum length that is common to all the patterns and searching the binary index tree for a desired substring with the use of that key gives us the text positions of too many leading strings .", "label": "", "metadata": {}, "score": "56.08839"}
{"text": "FIG .29 is another example of flowchart showing a procedure for identifying an interval corresponding to a specified node in the sixth embodiment of this invention ; .FIG .30 is a functional block diagram showing an example of hardware configuration suitable for retrieval in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "56.131474"}
{"text": "FIG .29 is another example of flowchart showing a procedure for identifying an interval corresponding to a specified node in the sixth embodiment of this invention ; .FIG .30 is a functional block diagram showing an example of hardware configuration suitable for retrieval in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "56.131474"}
{"text": "[0010 ] .In one embodiment of the present invention , the matches are ordered matches .The matches can alternatively be unordered .[ 0011 ] .In one embodiment of the present invention , the tree builder comprises an event - based parsing interface .", "label": "", "metadata": {}, "score": "56.13848"}
{"text": "The configuration ( t2 ) allows the function to identify a text item whose start position corresponds to a specified position within the code string .( t4 )The configuration ( t1 ) allows the function to return the key - candidate substring ( leading string of a trailing string ) starting at the position specified in the given text item .", "label": "", "metadata": {}, "score": "56.15635"}
{"text": "Increasing the Efficiency of the Procedure for Determining a Range Where Index Item Re - arranging Is Required to the Left of a Changed Position ] , may also be used .( 2 ) Updating the text .The updating means updates text items and the text as the code string is changed .", "label": "", "metadata": {}, "score": "56.166786"}
{"text": "29 , the lengths of both the right interval and the left interval are obtained , and the interval of the specified node is determined as an interval between these two intervals .Then , the following steps are repeated until the current node becomes the root node ( step 292 ) .", "label": "", "metadata": {}, "score": "56.169968"}
{"text": "29 , the lengths of both the right interval and the left interval are obtained , and the interval of the specified node is determined as an interval between these two intervals .Then , the following steps are repeated until the current node becomes the root node ( step 292 ) .", "label": "", "metadata": {}, "score": "56.169968"}
{"text": "What is claimed is : .A data processing system comprising : . dictionary tree generating means for generating a dictionary tree , which is a binary tree , based on said dictionary data ; . text data generating means for generating text data based on said code string ; . text tree generating means for generating a text tree , which is a binary tree , based on said text data ; . retrieving means for retrieving trailing strings each containing at least part of a key string as one of the leading strings , based on said dictionary tree and text tree ; . changing means for changing said code string ; . sequence assigning means for assigning a sequence number to each of plural lexicographically registered dictionary data items ; and .", "label": "", "metadata": {}, "score": "56.19377"}
{"text": "Configuration of the Fourth Embodiment ] .In this embodiment , the adjustment range setting means 20 , which puts a plurality of changes into one unit , is provided , as shown in FIG .33 , before the updating means 12 which updates dictionary data 2 .", "label": "", "metadata": {}, "score": "56.19513"}
{"text": "[ 0087 ] .Related Work .[ 0088 ] .In contrast , the XTrie scheme of the present invention focuses on filtering XML documents based on tree patterns ( based on XPath expressions ) , which demands far more sophisticated indexing techniques , since tree patterns consist of both data contents as well as structure .", "label": "", "metadata": {}, "score": "56.254963"}
{"text": "1985 ) are known as a structure specifically - structured for data retrieval .Basically , these data structures are based on a Trie ( digital search tree ) .In this data structure , a leaf corresponds to the character string wi ( a full character string ) .", "label": "", "metadata": {}, "score": "56.271072"}
{"text": "1985 ) are known as a structure specifically - structured for data retrieval .Basically , these data structures are based on a Trie ( digital search tree ) .In this data structure , a leaf corresponds to the character string wi ( a full character string ) .", "label": "", "metadata": {}, "score": "56.271072"}
{"text": "Configuration of the First Embodiment ] .FIG .1 is a functional block diagram showing the configuration of the first embodiment .The data processing system in this embodiment orders lexicographically the leading strings which are used in retrieving trailing strings of a code string 1 from which one or more strings containing a key string are to be retrieved .", "label": "", "metadata": {}, "score": "56.28458"}
{"text": "Second Embodiment ] .It is an object of the second embodiment to provide a data processing system which stores less character strings in the dictionary and text and , therefore , requires a smaller storage area .[ 2 - 1 .", "label": "", "metadata": {}, "score": "56.296627"}
{"text": "Category Factor .Example embodiments may also include a category factor , wherein the association between items in a category in a database is taken into account when generating clusters .This factor may , for example , be applied just before the generation of the merged cluster map .", "label": "", "metadata": {}, "score": "56.431858"}
{"text": "Category Factor .Example embodiments may also include a category factor , wherein the association between items in a category in a database is taken into account when generating clusters .This factor may , for example , be applied just before the generation of the merged cluster map .", "label": "", "metadata": {}, "score": "56.431858"}
{"text": "Cached information used to speed up access to sections of the rope close to the current position .We maintain two kinds of cache information in the iterator : .The limits of a contiguous block of storage holding the characters surrounding the current character position , and the current offset within that block .", "label": "", "metadata": {}, "score": "56.432922"}
{"text": "Cached information used to speed up access to sections of the rope close to the current position .We maintain two kinds of cache information in the iterator : .The limits of a contiguous block of storage holding the characters surrounding the current character position , and the current offset within that block .", "label": "", "metadata": {}, "score": "56.432922"}
{"text": "59 is calculated by adding the length of the new interval to the partial interval length of node L ( the root node ) in FIG .58 where the binary tree after splaying is shown .The partial interval length of node L in FIG .", "label": "", "metadata": {}, "score": "56.43466"}
{"text": "59 is calculated by adding the length of the new interval to the partial interval length of node L ( the root node ) in FIG .58 where the binary tree after splaying is shown .The partial interval length of node L in FIG .", "label": "", "metadata": {}, "score": "56.43466"}
{"text": "It is another object of the sixth embodiment to provide a data processing system and a data processing method which use memory more efficiently .In addition , the data processing system in the sixth embodiment has the structure adjusting means 45 for adjusting the structure of a binary tree by changing the connection sequence of the nodes .", "label": "", "metadata": {}, "score": "56.447166"}
{"text": "It is another object of the sixth embodiment to provide a data processing system and a data processing method which use memory more efficiently .In addition , the data processing system in the sixth embodiment has the structure adjusting means 45 for adjusting the structure of a binary tree by changing the connection sequence of the nodes .", "label": "", "metadata": {}, "score": "56.447166"}
{"text": "A prior art is known which allows the sequence of a node to be obtained from the node in the binary tree ( U.S. Pat .This prior art ( hereafter called a \" prior system \" ) is common to the present invention in that sequenced nodes are processed .", "label": "", "metadata": {}, "score": "56.48623"}
{"text": "A prior art is known which allows the sequence of a node to be obtained from the node in the binary tree ( U.S. Pat .This prior art ( hereafter called a \" prior system \" ) is common to the present invention in that sequenced nodes are processed .", "label": "", "metadata": {}, "score": "56.48623"}
{"text": "To generate a plurality of nodes containing the same character string in their addresses , a character string is stored in the low - order bits of each address with the high - order bits containing a different bit configuration .In this case , those nodes having the identical low - order address bits are assumed to contain in their addresses the character string corresponding to the low - order address bits .", "label": "", "metadata": {}, "score": "56.557564"}
{"text": "As described above , the index and the text are the same in that they are composed of pairs each consisting of a code and its position ; they are different only in the arrangement of codes .This means that only one sequence of codes need be stored .", "label": "", "metadata": {}, "score": "56.567196"}
{"text": "Probabilistic estimation formulae are then used , as before , to obtain the overall selectivity .In general , \" set hashing \" is a Monte Carlo technique for sets that can be used as an unbiased estimator for the cardinality of the \" set resemblance \" ( denoted as \u03c1 ) between k different sets .", "label": "", "metadata": {}, "score": "56.57012"}
{"text": "updating means for updating , based on a change to said code string , the index of said code string associated with the change , .A data retrieval system comprising : . index generating means for generating said index ; and . text generating means for generating said text , .", "label": "", "metadata": {}, "score": "56.57424"}
{"text": "That is , when . alpha . beta . , \" . beta.xy.alpha.w \" becomes \" . alpha.xy.alpha.w \" .Because its leftmost character \" . alpha . \" matches the leftmost character \" . alpha . \" of \" . alpha.w \" , comparison is required also for the trailing strings after \" w \" .", "label": "", "metadata": {}, "score": "56.575287"}
{"text": "[ 0023]FIG .6 illustrates an exemplary PROPAGATE - UPDATE software algorithm to update B whenever a non - redundant subtree - matching of a non - root substring is detected ; .[ 0024 ] .[ 0024]FIG . 7 illustrates an exemplary selective data dissemination system constructed according to the principles of the present invention ; and .", "label": "", "metadata": {}, "score": "56.608437"}
{"text": "An invention according to a 38 . sup.th illustrative implementation is a data processing system of the 33 . beta.x and .gamma.y which are immediately before and after the shortest trailing string . alpha.w which is longer than said trailing string w in said table , the leading string of the longest trailing string x which is shorter than .", "label": "", "metadata": {}, "score": "56.61384"}
{"text": "A data retrieval system as claimed in claim 22 , wherein the length of a key - candidate substring constituting said dictionary data is not limited .A data processing system comprising : . retrieving means for retrieving trailing strings each containing at least part of a key string as one of the leading strings , based on said dictionary data ; . comparing means for comparing two code strings ; . registering means for determining a position of a trailing string within an index and registering the trailing string in the index based on the comparison with another trailing string already registered in the dictionary data and composed of identical characters except one ; . changing means for changing said code string ; . rearrangement determining means for determining if , when part of said code string is changed , the leading string of the trailing string including the changed position of the code string must be re - arranged ; and .", "label": "", "metadata": {}, "score": "56.61791"}
{"text": "According to the invention of the twelfth illustrative implementation , the retrieving means references both dictionary data and text data via the pointers , storing a character string efficiently .An invention according to a 13 . sup.th illustrative implementation is a data processing system of the first illustrative implementation wherein the retrieving means restores a substring based on the dictionary tree and/or the text tree .", "label": "", "metadata": {}, "score": "56.65146"}
{"text": "Terms are eliminated as follows : .a1-F1-E1 Formula 42 !Note that this formula is equivalent to formula 21 that gives the net interval length before splaying .Conversely , in FIG .49 where the binary tree before splaying is shown , the sum of the lengths of the intervals to the left of node a is as follows : . E1+(b1-a1)+(c1-b1)+(d1-c1)+(f1-e1 ) Formula 43 !", "label": "", "metadata": {}, "score": "56.664986"}
{"text": "Terms are eliminated as follows : .a1-F1-E1 Formula 42 !Note that this formula is equivalent to formula 21 that gives the net interval length before splaying .Conversely , in FIG .49 where the binary tree before splaying is shown , the sum of the lengths of the intervals to the left of node a is as follows : . E1+(b1-a1)+(c1-b1)+(d1-c1)+(f1-e1 ) Formula 43 !", "label": "", "metadata": {}, "score": "56.664986"}
{"text": "This also prevents the update time from being increased even when the size of dictionary data 5 and 6 is increased as a result of a change in the code string .The following shows an example of how the length of an interval is maintained .", "label": "", "metadata": {}, "score": "56.70302"}
{"text": "This also prevents the update time from being increased even when the size of dictionary data 5 and 6 is increased as a result of a change in the code string .The following shows an example of how the length of an interval is maintained .", "label": "", "metadata": {}, "score": "56.70302"}
{"text": "22 , the method explained in the \" interval control method \" is used to retrieve the node in the text tree including position 4 to get node X. In this case , position 4 is the second position of the interval [ 3 , 4 ] represented by node X. Notice that the pointer in node X points to the node in the dictionary tree containing \" abc \" .", "label": "", "metadata": {}, "score": "56.714973"}
{"text": "The parameter P controls the cardinality of the set of indexed XPEs ( ranging from 10,000 to 500,000 ) .[ 0102 ] .The parameter L controls the \" depth \" of the XPEs in terms of the maximum number of levels ( ranging from 10 to 30 ) .", "label": "", "metadata": {}, "score": "56.743664"}
{"text": "So , even if the whole key string is not found , the retrieving means 8 returns result strings closely related with the key string .It also outputs result strings and the number of codes that match the key string , making it possible to determine how the result string is close to the key string .", "label": "", "metadata": {}, "score": "56.80021"}
{"text": "So , even if the whole key string is not found , the retrieving means 8 returns result strings closely related with the key string .It also outputs result strings and the number of codes that match the key string , making it possible to determine how the result string is close to the key string .", "label": "", "metadata": {}, "score": "56.80021"}
{"text": "Rotation , double rotation ( zig - zig ) , or double rotation ( zig - zag ) , which maintains the node sequence and the structure of a specified range of the binary tree 31 , is used in the structure adjustment procedure as an operation unit .", "label": "", "metadata": {}, "score": "56.802128"}
{"text": "Rotation , double rotation ( zig - zig ) , or double rotation ( zig - zag ) , which maintains the node sequence and the structure of a specified range of the binary tree 31 , is used in the structure adjustment procedure as an operation unit .", "label": "", "metadata": {}, "score": "56.802128"}
{"text": "Description of the Prior Art .Data retrieval systems and data retrieval methods have been devised heretofore to find all the occurrence positions of a specified key string ( pattern ) in a code string such as a character string .FIG .", "label": "", "metadata": {}, "score": "56.802223"}
{"text": "Description of the Prior Art .Data retrieval systems and data retrieval methods have been devised heretofore to find all the occurrence positions of a specified key string ( pattern ) in a code string such as a character string .FIG .", "label": "", "metadata": {}, "score": "56.802223"}
{"text": "In some embodiments , a method is illustrated as implemented in a distributed or non - distributed software application designed under a three - tier architecture paradigm , whereby the various components of computer code that implement this method may be categorized as belonging to one or more of these three tiers .", "label": "", "metadata": {}, "score": "56.8218"}
{"text": "In some embodiments , a method is illustrated as implemented in a distributed or non - distributed software application designed under a three - tier architecture paradigm , whereby the various components of computer code that implement this method may be categorized as belonging to one or more of these three tiers .", "label": "", "metadata": {}, "score": "56.8218"}
{"text": "2 is changed to \" bba \" , the pointer need not be changed because it remains unchanged .In the dictionary tree , the nodes representing \" bac \" and \" aca \" , which are added to the dictionary table , are added , with the pointers pointing to positions 5 and 6 in the text tree , respectively .", "label": "", "metadata": {}, "score": "56.836082"}
{"text": "[ 7 - 3 .Variations of Seventh Embodiment ] .This embodiment is not restricted to those described above .One type of embodiment may be executed by the index generating means , index , and retrieving means only ( The text is not generated , nor is the updating means used ) .", "label": "", "metadata": {}, "score": "56.877213"}
{"text": "The present invention proposes a unique approach to multidimensional substring selectivity estimation in which cross - counts are not explicitly stored .Rather , the cross - counts are generated as needed using set hashing .Thus , using only linear storage , an exponential number of cross - counts can be generated as needed .", "label": "", "metadata": {}, "score": "56.880592"}
{"text": "gamma.y , preceded by the leading string of x in said table , and if . alpha . beta . or .alpha . gamma .According to the inventions of the 37 . sup.th and 38 .An invention according to a 39 . sup.th illustrative implementation is a data processing system of the 33 .", "label": "", "metadata": {}, "score": "56.908463"}
{"text": "This trie may be a suffix trie , or even a prefix trie .Further , as discussed above , other types of data structures may be used in lieu of a trie for the purpose of organizing item listing data for searching .", "label": "", "metadata": {}, "score": "56.9231"}
{"text": "This trie may be a suffix trie , or even a prefix trie .Further , as discussed above , other types of data structures may be used in lieu of a trie for the purpose of organizing item listing data for searching .", "label": "", "metadata": {}, "score": "56.9231"}
{"text": "FIG .55 shows the code string in Table 1 stored in the second method .In the second method , the amount of memory depends on the number of consecutive code value intervals .That is , it depends , not on the number of positions , but on the number of intervals , increasing the memory efficiency .", "label": "", "metadata": {}, "score": "56.982773"}
{"text": "Increasing the Efficiency in Comparing Keys ( Code Strings ) at Index Retrieval Time ] , if used in comparing a key - candidate substring ( leading string of a trailing string ) with a pattern , improves comparison efficiency .Updating means execution steps .", "label": "", "metadata": {}, "score": "56.99466"}
{"text": "Considering the efforts needed for text updating , it would be more useful that the text items remain the same before and after update .It is also possible to delete all the n text ( index ) items , to create k text ( index ) items , and then to register them back .", "label": "", "metadata": {}, "score": "56.998787"}
{"text": "9 is an example merger cluster map that may result from the combining of clusters based upon a \u03bc value set to be 0.5 .Illustrated is a merged cluster map 900 where nodes or , in some cases , data contained in hash table positions , are merged together based upon some type of predefined overlap value .", "label": "", "metadata": {}, "score": "57.009888"}
{"text": "9 is an example merger cluster map that may result from the combining of clusters based upon a \u03bc value set to be 0.5 .Illustrated is a merged cluster map 900 where nodes or , in some cases , data contained in hash table positions , are merged together based upon some type of predefined overlap value .", "label": "", "metadata": {}, "score": "57.009888"}
{"text": "In some embodiments , items have images attached to them .Image similarity can be used as a factor for clustering .This factor may , for example , be applied just before the generation of the merged cluster map , assuming , for example , that comparing similar items visually could also be a useful factor .", "label": "", "metadata": {}, "score": "57.014378"}
{"text": "In some embodiments , items have images attached to them .Image similarity can be used as a factor for clustering .This factor may , for example , be applied just before the generation of the merged cluster map , assuming , for example , that comparing similar items visually could also be a useful factor .", "label": "", "metadata": {}, "score": "57.014378"}
{"text": "Comparison is performed differently , as described above , depending upon whether the second code string is the leading string of a trailing string or it is simply a code string .One of the problems with the retrieval of an item from the index with a code string specified is that the index contains many items whose leading strings are the same ( that is , they have the common leading string ) .", "label": "", "metadata": {}, "score": "57.042686"}
{"text": "[ 0117 ] .Although the present invention has been described in detail , those skilled in the art should understand that they can make various changes , substitutions and alterations herein without departing from the spirit and scope of the invention in its broadest form . calculating a demand factor based on relationships of items and categories to query terms of search queries , the relationships established from user actions resulting from the search queries ; . calculating a relevance score using the demand factor , the relevance score calculated , in part , based on a comparison of a similarity of a demand category histogram and a supply category histogram ; . identifying noise data using the demand factor ; . retrieving , from a plurality of listings , item data filtered from the noise data ; . constructing , using a processor , at least one base cluster having at least one document with common item data stored in a suffix ordering ; . compacting the at least one base cluster to create a compacted cluster representation having a reduced duplicate suffix ordering amongst the clusters ; and .", "label": "", "metadata": {}, "score": "57.04678"}
{"text": "In some embodiments , item listing data may be retrieved via the execution of the operation 202 from the item listing database 112 for the purpose of identifying and building a trie of possible search results based upon a particular search query , such as query 108 .", "label": "", "metadata": {}, "score": "57.07984"}
{"text": "In some embodiments , item listing data may be retrieved via the execution of the operation 202 from the item listing database 112 for the purpose of identifying and building a trie of possible search results based upon a particular search query , such as query 108 .", "label": "", "metadata": {}, "score": "57.07984"}
{"text": "If the rope implementation is compiled with _ _ GC defined , it will assume that there is an underlying garbage collector and inaccessible tree nodes will be automatically reclaimed .In this case rope must be instantiated with a suitable garbage - collecting allocator , and no reference count is maintained .", "label": "", "metadata": {}, "score": "57.133156"}
{"text": "If the rope implementation is compiled with _ _ GC defined , it will assume that there is an underlying garbage collector and inaccessible tree nodes will be automatically reclaimed .In this case rope must be instantiated with a suitable garbage - collecting allocator , and no reference count is maintained .", "label": "", "metadata": {}, "score": "57.133156"}
{"text": "These weighted links may represent probability values for determining whether a word or combination of words appearing in a item listing are noise or key words .Some embodiments may include the populating of an item listing database 112 for the purpose of providing data upon which to conduct a search .", "label": "", "metadata": {}, "score": "57.137634"}
{"text": "These weighted links may represent probability values for determining whether a word or combination of words appearing in a item listing are noise or key words .Some embodiments may include the populating of an item listing database 112 for the purpose of providing data upon which to conduct a search .", "label": "", "metadata": {}, "score": "57.137634"}
{"text": "This procedure is used to detect a condition under which such an insertion point is determined .When this condition is satisfied , the insertion point is also determined .( A )Registering \" . alpha.w \" when the trailing string \" w \" is already registered in the index .", "label": "", "metadata": {}, "score": "57.153923"}
{"text": "It is also necessary to change a particular code and to insert or remove one or a plurality of characters before or after the corresponding character .In addition , lines must be able to be added or removed .The data processing system in the seventh embodiment is suitable for this type of processing .", "label": "", "metadata": {}, "score": "57.16326"}
{"text": "It is also necessary to change a particular code and to insert or remove one or a plurality of characters before or after the corresponding character .In addition , lines must be able to be added or removed .The data processing system in the seventh embodiment is suitable for this type of processing .", "label": "", "metadata": {}, "score": "57.16326"}
{"text": "An invention according to a 74 . sup.th illustrative implementation is a data processing method of the 34 . sup.th illustrative implementation wherein the retrieving step determines , based on the position of a character on which comparison was performed last , the character position where comparison is to start next , when performing binary search on an lexicographically arranged table with a code string as the key .", "label": "", "metadata": {}, "score": "57.164665"}
{"text": "The relevancy score of a cluster may be computed to determine how relevant the cluster is with respect to a given input query .Several factors may be utilized to compute the relevancy score of a cluster including demand attributes and category histogram match score .", "label": "", "metadata": {}, "score": "57.217735"}
{"text": "The relevancy score of a cluster may be computed to determine how relevant the cluster is with respect to a given input query .Several factors may be utilized to compute the relevancy score of a cluster including demand attributes and category histogram match score .", "label": "", "metadata": {}, "score": "57.217735"}
{"text": "Configuration of the Third Embodiment ] .FIG .30 shows a functional block diagram showing the structure of the third embodiment .In this embodiment , the length a key contained in the dictionary data 2 is not limited .In addition , the data processing system used in this embodiment has the text data generating means 7 for generating the text data 6 based on the code string 1 on which retrieval is made with the use of a key string .", "label": "", "metadata": {}, "score": "57.220554"}
{"text": "A code string may be restored by combining the functions ( t3 ) and ( t4 ) as follows .First , specify the start position of a code string to be restored .Then , ( t3 ) determines the text item , and ( t4 ) returns the leading string of the trailing string starting at that position .", "label": "", "metadata": {}, "score": "57.223682"}
{"text": "The binary tree 31 is a tree - like data structure consisting of nodes , each corresponding to an interval , connected from the root to the ends .On the end side of each node , the preceding node , which corresponds to the preceding interval of the node and/or the following node , which corresponds to the following interval of the node , is connected .", "label": "", "metadata": {}, "score": "57.23884"}
{"text": "The binary tree 31 is a tree - like data structure consisting of nodes , each corresponding to an interval , connected from the root to the ends .On the end side of each node , the preceding node , which corresponds to the preceding interval of the node and/or the following node , which corresponds to the following interval of the node , is connected .", "label": "", "metadata": {}, "score": "57.23884"}
{"text": "The binary tree 31 is a tree - like data structure consisting of nodes , each corresponding to an interval , connected from the root to the ends .On the end side of each node , the preceding node , which corresponds to the preceding interval of the node and/or the following node , which corresponds to the following interval of the node , is connected .", "label": "", "metadata": {}, "score": "57.23884"}
{"text": "That is , if the start address of storage where the code string is stored is A , then the address of the code value is calculated as follows : .However , this method has the following problems : .( 1 ) Data occupies as many locations as there are code values , degrading the memory efficiency .", "label": "", "metadata": {}, "score": "57.25836"}
{"text": "That is , if the start address of storage where the code string is stored is A , then the address of the code value is calculated as follows : .However , this method has the following problems : .( 1 ) Data occupies as many locations as there are code values , degrading the memory efficiency .", "label": "", "metadata": {}, "score": "57.25836"}
{"text": "53 - 56 ) \" in Data Structures and Network Algorithms ) .As shown in FIG .44 , a specified node is moved to the root position by using \" splaying \" ( step 441 ) .Then , the specified node is set as the current node ( step 442 ) , and if the current node has a left child ( step 443 ) , the left child of the current node is set as the adjacent node ( step 444 ) .", "label": "", "metadata": {}, "score": "57.292557"}
{"text": "In one embodiment of the present invention , the tree prober probes the substring table only for matching substrings that appear as a leaf substring in one of the XPath expressions .However , the tree prober may be more \" eager \" than this .", "label": "", "metadata": {}, "score": "57.316048"}
{"text": "The overall reasoning is that , if cross - counts can be approximated using small space , then for a given budget of space , information can be stored about more combinations of substrings than is possible with prior art arrangements .", "label": "", "metadata": {}, "score": "57.456688"}
{"text": "While XFilter ( Altinel , et al . , supra ) is designed for filtering XML documents with XPath expressions , the XTrie index is based on decomposing tree patterns into collections of substrings ( i.e. , sequences of element names ) and indexing them using a trie .", "label": "", "metadata": {}, "score": "57.519287"}
{"text": "FIG .11 is a flowchart illustrating an example method used to implement operation 203 .Illustrated is parsed query data 1101 that is received through the execution of an operation 1102 , wherein operation 1102 is initiated through receiving a call from an operation implementing the STC algorithm .", "label": "", "metadata": {}, "score": "57.543404"}
{"text": "FIG .11 is a flowchart illustrating an example method used to implement operation 203 .Illustrated is parsed query data 1101 that is received through the execution of an operation 1102 , wherein operation 1102 is initiated through receiving a call from an operation implementing the STC algorithm .", "label": "", "metadata": {}, "score": "57.543404"}
{"text": "updating , based on a change to said code string , the index and the text of said code string associated with the change , .A data processing method comprising the steps of : . retrieving the leading string of a trailing string residing in the trailing part of said code string , . restoring the whole or part of a code string beginning in the specified position , based on a text arranged in order of positions within said code string ; . generating said index ; . generating said text ; . changing said code string ; and .", "label": "", "metadata": {}, "score": "57.58963"}
{"text": "A data processing system as claimed in claim 1 , wherein said retrieving means retrieves data by referencing both said dictionary tree and said text tree .A data processing system as claimed in claim 1 , wherein said retrieving means restores a substring based on one or both of said dictionary tree and said text tree .", "label": "", "metadata": {}, "score": "57.599922"}
{"text": "68 shows the format of information on a node in the balanced binary tree example .The nodes in this tree are linked by pointers , as in FIG .53 .In the following discussion , the partial interval length of each node ( a , b , c ) is represented by the same symbol immediately followed by a numerical subscript ( a1 , b1 , c1 ) .", "label": "", "metadata": {}, "score": "57.63376"}
{"text": "68 shows the format of information on a node in the balanced binary tree example .The nodes in this tree are linked by pointers , as in FIG .53 .In the following discussion , the partial interval length of each node ( a , b , c ) is represented by the same symbol immediately followed by a numerical subscript ( a1 , b1 , c1 ) .", "label": "", "metadata": {}, "score": "57.63376"}
{"text": "beta . \" , in those trailing strings starting in the not - registered range shown in FIG .37 are registered first .Then , a trailing string beginning with \" .beta . \" is registered .The leading string of a trailing string beginning with \" .", "label": "", "metadata": {}, "score": "57.64045"}
{"text": "An invention according to an 84 . sup.th illustrative implementation is a data processing method of the 48 . sup.th or 54 .According to the invention of the 84 . sup.th illustrative implementation , a data processing method , which can easily find the number of substrings satisfying the retrieval condition even when the code string has been changed , may be built .", "label": "", "metadata": {}, "score": "57.68811"}
{"text": "5 is a diagram illustrating an uncompacted tree that may be generated through the execution of a suffix tree clustering algorithm , according to an example embodiment .FIG .6 is a diagram illustrating a hash table that may be generated through the execution of a suffix tree clustering algorithm , according to an example embodiment .", "label": "", "metadata": {}, "score": "57.688828"}
{"text": "5 is a diagram illustrating an uncompacted tree that may be generated through the execution of a suffix tree clustering algorithm , according to an example embodiment .FIG .6 is a diagram illustrating a hash table that may be generated through the execution of a suffix tree clustering algorithm , according to an example embodiment .", "label": "", "metadata": {}, "score": "57.688828"}
{"text": "For example , when the interval with the length of 4 ( 6 . . .9 ! ) is changed to an interval with the length of 2 ( 6 . . .7 ! ) in the example shown in FIG .", "label": "", "metadata": {}, "score": "57.69332"}
{"text": "For example , when the interval with the length of 4 ( 6 . . .9 ! ) is changed to an interval with the length of 2 ( 6 . . .7 ! ) in the example shown in FIG .", "label": "", "metadata": {}, "score": "57.69332"}
{"text": "The comparing means in this embodiment , if used according to the procedure for comparing two trailing strings , makes the comparison more efficient even if they have an identical long leading string .In the following discussion , it is assumed that the comparing means has a means for determining which of the two trailing strings comes before the other ( is smaller ) in the index .", "label": "", "metadata": {}, "score": "57.6997"}
{"text": "This may be achieved through an API call made to a search back end .Subsequently , a HTTP based method call is made to obtain relevance weighting for that particular query from a Relevance - Weighting System .In some embodiments , different queries return relevance weightings specific to that query .", "label": "", "metadata": {}, "score": "57.722084"}
{"text": "This may be achieved through an API call made to a search back end .Subsequently , a HTTP based method call is made to obtain relevance weighting for that particular query from a Relevance - Weighting System .In some embodiments , different queries return relevance weightings specific to that query .", "label": "", "metadata": {}, "score": "57.722084"}
{"text": "When updating them , the updating means 11 adds one or more trailing strings , generated as a result of updating , to the tree and then removes trailing strings containing part of all of a substring to be changed .Updating data in this order allows part of the tree structure , which is not affected by the change , to be used unchanged , reducing the update time .", "label": "", "metadata": {}, "score": "57.760246"}
{"text": "When updating them , the updating means 11 adds one or more trailing strings , generated as a result of updating , to the tree and then removes trailing strings containing part of all of a substring to be changed .Updating data in this order allows part of the tree structure , which is not affected by the change , to be used unchanged , reducing the update time .", "label": "", "metadata": {}, "score": "57.760246"}
{"text": "When retrieval ends , this method gives us the maximum number of leading characters of the code string which match those of a trailing string in the index as well as the corresponding trailing string ( one of trailing strings ) .", "label": "", "metadata": {}, "score": "57.76407"}
{"text": "An invention according to a 73 . sup.rd illustrative implementation is data processing method of the 22 . sup.nd illustrative implementation wherein the retrieving step has counting step for counting the number of substrings , each containing an identical leading string , using the sequence numbers of the first dictionary data item and the last dictionary data item .", "label": "", "metadata": {}, "score": "57.766396"}
{"text": "49 shows an example of a binary tree .In this figure , a circle indicates a node , and a triangle indicates a sub - tree whose root is indicated by a circle .Binary tree data like this is structured in a list format by connecting the data items in the nodes via pointers .", "label": "", "metadata": {}, "score": "57.79529"}
{"text": "49 shows an example of a binary tree .In this figure , a circle indicates a node , and a triangle indicates a sub - tree whose root is indicated by a circle .Binary tree data like this is structured in a list format by connecting the data items in the nodes via pointers .", "label": "", "metadata": {}, "score": "57.79529"}
{"text": "claim 12 , wherein the suffix ordering is stored in a data structure that includes at least one of a trie , a hash table , a binary search tree , a red - black tree , or a heap .The computer system of .", "label": "", "metadata": {}, "score": "57.81617"}
{"text": "claim 12 , wherein the suffix ordering is stored in a data structure that includes at least one of a trie , a hash table , a binary search tree , a red - black tree , or a heap .The computer system of .", "label": "", "metadata": {}, "score": "57.81617"}
{"text": "The method of .claim 1 , further comprising merging the compact cluster representation based upon one or more of a relevance - weight factor , a seller factor , a price factor , a category factor , or an image factor .", "label": "", "metadata": {}, "score": "57.820984"}
{"text": "The method of .claim 1 , further comprising merging the compact cluster representation based upon one or more of a relevance - weight factor , a seller factor , a price factor , a category factor , or an image factor .", "label": "", "metadata": {}, "score": "57.820984"}
{"text": "Therefore , the changing means 11 need only to inform the updating means 12 of the contents of a change .In this case , if the whole or a part of the code string must be restored , the code string restoring means ( not shown in the figure ) should be added .", "label": "", "metadata": {}, "score": "57.823486"}
{"text": "Additionally , this query 108 is also sent to an operation 202 which , when executed , makes an API based call to a search back end , such as the previously illustrated item listing database 112 .Once operations 201 and 202 are executed , a further operation 204 is executed wherein an STC algorithm is executed via an execution of operation 204 .", "label": "", "metadata": {}, "score": "57.85522"}
{"text": "Additionally , this query 108 is also sent to an operation 202 which , when executed , makes an API based call to a search back end , such as the previously illustrated item listing database 112 .Once operations 201 and 202 are executed , a further operation 204 is executed wherein an STC algorithm is executed via an execution of operation 204 .", "label": "", "metadata": {}, "score": "57.85522"}
{"text": "In this example , it Is thought that a code string is divided into a sequence of code strings of the same value , that is , into intervals .To process this data on a computer , the straightforward method is to store code values sequentially at consecutive addresses in storage ( first method ) .", "label": "", "metadata": {}, "score": "57.86681"}
{"text": "In this example , it Is thought that a code string is divided into a sequence of code strings of the same value , that is , into intervals .To process this data on a computer , the straightforward method is to store code values sequentially at consecutive addresses in storage ( first method ) .", "label": "", "metadata": {}, "score": "57.86681"}
{"text": "FIGS . 10 ( a ) and 10 ( b ) contain graphs comparing average error of the inventive set hashing method with respect to various prior art techniques , associated with posing positive queries to different large data sets ; .", "label": "", "metadata": {}, "score": "57.909866"}
{"text": "Because the range becomes null , retrieval ends .The first two characters of the retrieval string \" bac \" match those of the upper limit \" babcab \" , and the string comes immediately after that position .When binary search is performed for the lexicographically - sorted trailing strings using a retrieval code - string as the key , the shorter of the matching leading string of the previously - compared trailing string can be used for the upper or lower limit .", "label": "", "metadata": {}, "score": "57.96174"}
{"text": "[ 9 - 2 .Text Update Function ] .( This restoration function performs its function equivalently even after the node is inserted ) .Insertion of a node containing one character means that one character is inserted into the code string .", "label": "", "metadata": {}, "score": "57.96438"}
{"text": "During processing , characters are obtained from the end of a key string .The leading ( preceding ) node and the trailing ( following ) node in the sixth embodiment should also be exchanged .Thus , this invention provides a data retrieval system which reduces the update time of data for retrieval .", "label": "", "metadata": {}, "score": "57.976723"}
{"text": "During processing , characters are obtained from the end of a key string .The leading ( preceding ) node and the trailing ( following ) node in the sixth embodiment should also be exchanged .Thus , this invention provides a data retrieval system which reduces the update time of data for retrieval .", "label": "", "metadata": {}, "score": "57.976723"}
{"text": "[ 0060 ] .The Index Structure .[ 0061 ] .An Xtrie index consists of two key components : ( 1 ) a Trie ( D. Knuth , \" The Art of Computer Programming : Sorting and Searching , \" volume 3 , chapter 6.3 .", "label": "", "metadata": {}, "score": "57.988792"}
{"text": "Short ropes are usually represented as a single such node .In the case of the standard character type , the actual array of characters is NULL -terminated to allow fast generation of an equivalent C string .( _Rope_RopeConcatenation ) Concatenation nodes .", "label": "", "metadata": {}, "score": "58.00032"}
{"text": "Short ropes are usually represented as a single such node .In the case of the standard character type , the actual array of characters is NULL -terminated to allow fast generation of an equivalent C string .( _Rope_RopeConcatenation ) Concatenation nodes .", "label": "", "metadata": {}, "score": "58.00032"}
{"text": "Two identical records in Table 24 , one in the index part and the other in the text part , correspond to one node .Thus , this data structure enables the retrieving means and updating means , which use these functions , to be created .", "label": "", "metadata": {}, "score": "58.007744"}
{"text": "In one embodiment of the present invention , the tree builder builds a substring table for the XPath expression tree .The structure and function of one embodiment of the substring table will be set forth in detail in the Detailed Description that follows .", "label": "", "metadata": {}, "score": "58.011658"}
{"text": "If they match and if both x and y are in the index , the relation in the index between x and y is the comparison result of u and v. .( 4 )If they match but if at least one of x and y is not in the index , x.rarw .", "label": "", "metadata": {}, "score": "58.097782"}
{"text": "80 shows an example of a conventional directed acyclic word graph ; .FIG .81 shows an example of data used in a conventional first method ; .FIG .82 shows an example of data used in a conventional first method ( insert ) ; .", "label": "", "metadata": {}, "score": "58.104065"}
{"text": "80 shows an example of a conventional directed acyclic word graph ; .FIG .81 shows an example of data used in a conventional first method ; .FIG .82 shows an example of data used in a conventional first method ( insert ) ; .", "label": "", "metadata": {}, "score": "58.104065"}
{"text": "sup.st , or 53 . sup.rd illustrative implementations wherein the length of a key - candidate substring constituting the index is not limited .According to the inventions of the 60 . sup.th and 61 . sup.st illustrative implementations , not limiting the length of a key - candidate substring eliminates the need for a subsequent check on the subsequent portion of each substring in the text .", "label": "", "metadata": {}, "score": "58.20926"}
{"text": "Before describing the two modes of matching XPEs , some new definitions and notation should be introduced .[ 0037 ] .[ 0038 ] .A node t i in T \" matches \" at a node d in D if the element name of t i is equal to that of d. [ 0039 ] .", "label": "", "metadata": {}, "score": "58.209312"}
{"text": "A data processing system as claimed in claim 46 , wherein the pairs in said index and the pairs in said text are integrated .A data processing system as claimed in claim 25 , 35 , 36 , 45 , or 46 , wherein said updating means combines updates for a plurality of changes to said code string into one unit of work .", "label": "", "metadata": {}, "score": "58.219734"}
{"text": "[0097 ] .XML Documents .[ 0098 ] .The NITF DTD ( version 2.5 ) contains 123 elements with 513 attributes .Three sets of 250 XML documents with similar characteristics were generated .These sets correspond to different sizes of document : small , medium and large , with an average of 20 , 100 , and 1000 pairs of tags , respectively .", "label": "", "metadata": {}, "score": "58.289948"}
{"text": "This check can be used effectively , for example , by determining whether or not the least - frequent sub - key is preceded or followed by a sequence of more frequent sub - keys that occur consecutively .SIXTH EMBODIMENT .", "label": "", "metadata": {}, "score": "58.298824"}
{"text": "This check can be used effectively , for example , by determining whether or not the least - frequent sub - key is preceded or followed by a sequence of more frequent sub - keys that occur consecutively .SIXTH EMBODIMENT .", "label": "", "metadata": {}, "score": "58.298824"}
{"text": "In the third embodiment , the number of required trees is less than that required when an independent tree is created for each dictionary data unit and therefore less memory is required .The third embodiment is effective especially for a code string containing a plurality of identical or similar components .", "label": "", "metadata": {}, "score": "58.330517"}
{"text": "In the third embodiment , the number of required trees is less than that required when an independent tree is created for each dictionary data unit and therefore less memory is required .The third embodiment is effective especially for a code string containing a plurality of identical or similar components .", "label": "", "metadata": {}, "score": "58.330517"}
{"text": "And an invention according to a 34 .According to the data processing system of the 33 . sup.rd illustrative implementation and the data processing method of the 34 . sup.th illustrative implementation , the data processing system having the comparing means and the re - arrange determining means efficiently compares code strings required when retrieving a specified code string from the index or when registering a trailing string into the index .", "label": "", "metadata": {}, "score": "58.383842"}
{"text": "However , at fixed space , increasing the length of the signatures will also limit the number of suffix tree nodes that can be kept , yielding a higher error rate .FIG .13 illustrates the absolute error measurements for performing set hashing with maximal overlap ( MO ) parsing , as used with the EVENT data set , for signature lengths ranging between 10 and 100 .", "label": "", "metadata": {}, "score": "58.387035"}
{"text": "For example , a code string used in this invention is not limited to a character string ; the code string may be any type of code such as a voice pattern code or DNA base array code .A substring in a code string need not be processed explicitly ; for example , it need not be transferred from one storage location to another .", "label": "", "metadata": {}, "score": "58.394073"}
{"text": "For the text \" ababcab \" , the dictionary data used to retrieve a substring that is three characters or less in length consists of data shown in Table 7 , as explained in the above embodiments .It should be remembered here that a dictionary ( index ) refers to data with the key - candidate substrings arranged lexicographically , each key - candidate substring being assigned its start position .", "label": "", "metadata": {}, "score": "58.39465"}
{"text": "FIG .28 is a flowchart showing an example of a procedure for identifying the interval corresponding to the specified node .In this procedure , the partial interval length of the left child of the current node that is specified is first set to the left interval length ( step 281 ) .", "label": "", "metadata": {}, "score": "58.403214"}
{"text": "FIG .28 is a flowchart showing an example of a procedure for identifying the interval corresponding to the specified node .In this procedure , the partial interval length of the left child of the current node that is specified is first set to the left interval length ( step 281 ) .", "label": "", "metadata": {}, "score": "58.403214"}
{"text": "If each code unit is allowed to represent the maximum amount of information , a huge amount of storage is required .This results in less positions and more coarse position increments ( less precise ) .Conversely , smaller position increments increase the number of positions , requiring a huge amount of storage .", "label": "", "metadata": {}, "score": "58.424576"}
{"text": "If each code unit is allowed to represent the maximum amount of information , a huge amount of storage is required .This results in less positions and more coarse position increments ( less precise ) .Conversely , smaller position increments increase the number of positions , requiring a huge amount of storage .", "label": "", "metadata": {}, "score": "58.424576"}
{"text": "While the STC algorithm allows for overlapping clusters , its also may facilitate the creation of clusters that are fairly unique in their theme .We can say that the cluster independence measure is high when we can separate out clusters through their distinction from others .", "label": "", "metadata": {}, "score": "58.497963"}
{"text": "While the STC algorithm allows for overlapping clusters , its also may facilitate the creation of clusters that are fairly unique in their theme .We can say that the cluster independence measure is high when we can separate out clusters through their distinction from others .", "label": "", "metadata": {}, "score": "58.497963"}
{"text": "In FIG .72 , contradictions to conditions 1 , 2 , and 3 are resolved , and structure adjustment ( re - balancing ) is completed .In the above structure adjustment , the net interval lengths of nodes e and b are as follows in FIG .", "label": "", "metadata": {}, "score": "58.49942"}
{"text": "In FIG .72 , contradictions to conditions 1 , 2 , and 3 are resolved , and structure adjustment ( re - balancing ) is completed .In the above structure adjustment , the net interval lengths of nodes e and b are as follows in FIG .", "label": "", "metadata": {}, "score": "58.49942"}
{"text": "13 contains a graph of absolute error measurement as a function of signature length for a relatively uncorrelated data set ; .FIG .14 contains a graph of absolute error measurement as a function of signature length for a highly correlated data set ; and .", "label": "", "metadata": {}, "score": "58.520317"}
{"text": "[ 5 - 2 . Operation And Effects of the Fifth Embodiment ] .The fifth embodiment having the configuration described above performs operation as follows .However , there are times when we want to know the number of appearances of a specific pattern within the text , not the position of each pattern .", "label": "", "metadata": {}, "score": "58.553307"}
{"text": "moves the current node , pointed to by a pointer , from said specified node toward the parent node , which is a higher - level node , of said current node , one node level at a time , until said root is reached , .", "label": "", "metadata": {}, "score": "58.55494"}
{"text": "moves the current node , pointed to by a pointer , from said specified node toward the parent node , which is a higher - level node , of said current node , one node level at a time , until said root is reached , .", "label": "", "metadata": {}, "score": "58.55494"}
{"text": "In the sixth embodiment , the structure adjustment is performed according to the status of the binary tree 31 , because a plurality of processing types are combined to change the structure of a specified range of the binary tree 31 .", "label": "", "metadata": {}, "score": "58.579193"}
{"text": "In the sixth embodiment , the structure adjustment is performed according to the status of the binary tree 31 , because a plurality of processing types are combined to change the structure of a specified range of the binary tree 31 .", "label": "", "metadata": {}, "score": "58.579193"}
{"text": "Thus , the updating means using ( u ) , if available , may be used to change a code string .As shown in the forth embodiment , changes may be made at a time to enhance efficiency .The updating means consists of the following three procedures : .", "label": "", "metadata": {}, "score": "58.60172"}
{"text": "78 is an example of a position tree representing the dictionary for the code string \" abbabb$ \" .A suffix tree is a Trie which uses a suffix ( a trailing substring ) of the code string s as the character string wi .", "label": "", "metadata": {}, "score": "58.618973"}
{"text": "78 is an example of a position tree representing the dictionary for the code string \" abbabb$ \" .A suffix tree is a Trie which uses a suffix ( a trailing substring ) of the code string s as the character string wi .", "label": "", "metadata": {}, "score": "58.618973"}
{"text": "So , when retrieving the pattern \" abc \" that is longer than the pattern \" ab \" , it is necessary to determine , for each of the results , if the trailing part matches the pattern .The object of this embodiment is to provide a data processing system which updates data for retrieval speedily when the length of a key - candidate substring is not limited .", "label": "", "metadata": {}, "score": "58.627636"}
{"text": "83 shows the code string in Table 1 stored in the second method .In the second method , the amount of memory depends on the number of consecutive code value intervals .That is , it depends , not on the number of positions , but on the number of intervals , increasing the memory efficiency .", "label": "", "metadata": {}, "score": "58.627785"}
{"text": "83 shows the code string in Table 1 stored in the second method .In the second method , the amount of memory depends on the number of consecutive code value intervals .That is , it depends , not on the number of positions , but on the number of intervals , increasing the memory efficiency .", "label": "", "metadata": {}, "score": "58.627785"}
{"text": "An Additional Approach to Multi - Factor Clustering .In some embodiments , an additional approach to multifactor clustering is implemented that supplements , or in some cases replaces the multi - factoring approach outlined above .This approach may be applied after , for example , a merged cluster map is built .", "label": "", "metadata": {}, "score": "58.631798"}
{"text": "An Additional Approach to Multi - Factor Clustering .In some embodiments , an additional approach to multifactor clustering is implemented that supplements , or in some cases replaces the multi - factoring approach outlined above .This approach may be applied after , for example , a merged cluster map is built .", "label": "", "metadata": {}, "score": "58.631798"}
{"text": "In addition , the added character \" d \" must be registered in the index .There is no need to re - arrange other key - candidate substrings , with their relative positional relation in the index remained unchanged .The following explains how the index will be re - organized when a character in the middle of the text is changed .", "label": "", "metadata": {}, "score": "58.667976"}
{"text": "In addition , since fewer indexed XPEs are associated with a \" longer \" substring key , each index probe is likely to be less time - consuming , as well .[ 0030 ] .DOM requires a main - memory representation of the XML data tree to be built before filtering can commence .", "label": "", "metadata": {}, "score": "58.684624"}
{"text": "Using the standard merge threshold ( e.g. , 0.5 ) , these two clusters may never have been merged if it did n't satisfy the basic merge criterion .Hence , a second measure that takes into account the overlap of sellers between clusters may be needed to enforce this necessary underlying relationship .", "label": "", "metadata": {}, "score": "58.745953"}
{"text": "Using the standard merge threshold ( e.g. , 0.5 ) , these two clusters may never have been merged if it did n't satisfy the basic merge criterion .Hence , a second measure that takes into account the overlap of sellers between clusters may be needed to enforce this necessary underlying relationship .", "label": "", "metadata": {}, "score": "58.745953"}
{"text": "As described above , this embodiment puts a plurality of changes into one unit of adjustment work to reduce the number of times a trailing string is re - arranged .[ 5 .Fifth Embodiment ] .The object of the fifth embodiment is to provide a data processing system which makes the counting of pattern appearances in the text more efficient .", "label": "", "metadata": {}, "score": "58.849358"}
{"text": "74 , consecutive eight blanks and two blank lines are represented as 28 blanks by a single node .The data processing system in the eighth embodiment is particularly suitable when data containing many sequences of the same code .In addition , compressing bit - string data , such as a facsimile image , with the use of a binary tree in the eighth embodiment allows any bit in the bit string to be identified as 1 or 0 .", "label": "", "metadata": {}, "score": "58.870422"}
{"text": "74 , consecutive eight blanks and two blank lines are represented as 28 blanks by a single node .The data processing system in the eighth embodiment is particularly suitable when data containing many sequences of the same code .In addition , compressing bit - string data , such as a facsimile image , with the use of a binary tree in the eighth embodiment allows any bit in the bit string to be identified as 1 or 0 .", "label": "", "metadata": {}, "score": "58.870422"}
{"text": "According to the invention of the fifth and sixth illustrative implementations , limiting the length of a key - candidate substring saves the area where key - candidate substrings are stored .In addition , limiting the length of a key - candidate substring eliminates the need for redundant comparison .", "label": "", "metadata": {}, "score": "58.90054"}
{"text": "In contrast , the XTrie scheme of the present invention focuses on filtering XML documents based on tree patterns ( based on XPath expressions ) , which demands far more sophisticated indexing techniques , since tree patterns consist of both data contents as well as structure .", "label": "", "metadata": {}, "score": "58.905277"}
{"text": "That is , combining the index with the text makes it possible to store as many codes as the code string characters as follows .TABLE 12 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Dictionary ) Lexicographic orderKey - candidate substringStart position _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # # STR4 # # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) # # STR5 # # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # # STR6 # # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "58.930626"}
{"text": "83 shows an example of data used in a conventional second method ; .FIG .84 shows an example of a conventional binary tree ; .FIG .85 shows an example of data used in a conventional third method ; .", "label": "", "metadata": {}, "score": "58.957954"}
{"text": "83 shows an example of data used in a conventional second method ; .FIG .84 shows an example of a conventional binary tree ; .FIG .85 shows an example of data used in a conventional third method ; .", "label": "", "metadata": {}, "score": "58.957954"}
{"text": "This section explains how the index generating means , the text generating means , and changing means are related .In this embodiment , the index generating means 22 may be implemented by sequentially executing the index - related function of the updating means 12 .", "label": "", "metadata": {}, "score": "58.967583"}
{"text": "Since our algorithm is designed with the sincere goal of achieving clustering based upon commonality of terms and other factors , we can define a measure based upon how much clusters overlap .Since we have n clusters , each pair C i , C j makes a contribution into the overall measure .", "label": "", "metadata": {}, "score": "58.99463"}
{"text": "Since our algorithm is designed with the sincere goal of achieving clustering based upon commonality of terms and other factors , we can define a measure based upon how much clusters overlap .Since we have n clusters , each pair C i , C j makes a contribution into the overall measure .", "label": "", "metadata": {}, "score": "58.99463"}
{"text": "In some embodiments , the weights are normalized to a sum of one over all the factors involved ( e.g. , 1/factors involved ) .New attributes can be added into the computation of relevancy score and the weights can be tuned so that appropriate relevancy can be achieved .", "label": "", "metadata": {}, "score": "59.01284"}
{"text": "In some embodiments , the weights are normalized to a sum of one over all the factors involved ( e.g. , 1/factors involved ) .New attributes can be added into the computation of relevancy score and the weights can be tuned so that appropriate relevancy can be achieved .", "label": "", "metadata": {}, "score": "59.01284"}
{"text": "86 shows a data structure represented in the fourth method .The fourth method eliminates the need for transferring data in memory when adding , deleting , dividing , or merging one or more intervals .However , to locate a particular position , this method still requires us to add up the lengths of intervals .", "label": "", "metadata": {}, "score": "59.016354"}
{"text": "86 shows a data structure represented in the fourth method .The fourth method eliminates the need for transferring data in memory when adding , deleting , dividing , or merging one or more intervals .However , to locate a particular position , this method still requires us to add up the lengths of intervals .", "label": "", "metadata": {}, "score": "59.016354"}
{"text": "14 is a flowchart showing the procedure for identifying an interval in a data processing system using the \" interval control method \" ; .FIG .15 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval length changed ) ; .", "label": "", "metadata": {}, "score": "59.02302"}
{"text": "claim 1 , further comprising labeling the at least one base cluster .The method of .claim 1 , further comprising evaluating the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "59.05169"}
{"text": "claim 1 , further comprising labeling the at least one base cluster .The method of .claim 1 , further comprising evaluating the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "59.05169"}
{"text": "Thus ropes are really represented as directed acyclic graphs .Nonetheless , we will continue to refer to trees , since that is both the usual case , and more intuitive .( The balanced bit is really of interest only for concatenation tree nodes , see below . )", "label": "", "metadata": {}, "score": "59.06759"}
{"text": "Thus ropes are really represented as directed acyclic graphs .Nonetheless , we will continue to refer to trees , since that is both the usual case , and more intuitive .( The balanced bit is really of interest only for concatenation tree nodes , see below . )", "label": "", "metadata": {}, "score": "59.06759"}
{"text": "10 ) .In this case , the first maintaining means 12 erases one of two boundaries so that the combined substring , generated as a result of erasure , is shorter in length .This prevents the update time from being increased even when the size of the combined substrings is increased .", "label": "", "metadata": {}, "score": "59.07618"}
{"text": "10 ) .In this case , the first maintaining means 12 erases one of two boundaries so that the combined substring , generated as a result of erasure , is shorter in length .This prevents the update time from being increased even when the size of the combined substrings is increased .", "label": "", "metadata": {}, "score": "59.07618"}
{"text": "A divider determines the first substring and second substring based on the code string from which a key string is retrieved .A data retrieval system which updates data quickly .A divider determines the first substring and second substring based on the code string from which a key string is retrieved .", "label": "", "metadata": {}, "score": "59.09868"}
{"text": "A divider determines the first substring and second substring based on the code string from which a key string is retrieved .A data retrieval system which updates data quickly .A divider determines the first substring and second substring based on the code string from which a key string is retrieved .", "label": "", "metadata": {}, "score": "59.09868"}
{"text": "Configuration of the Sixth Embodiment ] .FIG .36 is a functional block diagram showing the configuration of the sixth embodiment .The data processing system in this embodiment also has the re - arrange determining means 14 which determines whether to re - arrange a trailing string , part of which has been changed .", "label": "", "metadata": {}, "score": "59.114624"}
{"text": "An invention according to claim 10 is a data retrieval system as claimed in claim 1 or 3 , further comprising removing means for removing duplications of the trailing string .The invention of claim 42 realizes the invention of the claim 10 from a methodological standpoint and is a data retrieval method as claimed in claim 37 or 3 9 , further comprising a removing process for removing duplicate positions of said trailing string .", "label": "", "metadata": {}, "score": "59.190536"}
{"text": "An invention according to claim 10 is a data retrieval system as claimed in claim 1 or 3 , further comprising removing means for removing duplications of the trailing string .The invention of claim 42 realizes the invention of the claim 10 from a methodological standpoint and is a data retrieval method as claimed in claim 37 or 3 9 , further comprising a removing process for removing duplicate positions of said trailing string .", "label": "", "metadata": {}, "score": "59.190536"}
{"text": "And , a trailing string whose sequence has been changed is re - arranged .A trailing string whose sequence is not changed , once found , causes the re - arrange operation to be canceled ( The trailing string itself is not re - arranged ) .", "label": "", "metadata": {}, "score": "59.19291"}
{"text": "A data retrieval system as claimed in claim 41 , wherein said index is represented by a binary tree .A data retrieval system as claimed in claim 41 , wherein said text is said code string stored in contiguous addresses , each location being represented by an address .", "label": "", "metadata": {}, "score": "59.239944"}
{"text": "The organization of the data set in FIG .8 can be defined as the \" preprocessing \" step of the present invention , related to the creation of the PSTs and signatures for the data set .In using this data set , the method of the present invention moves on to the step of \" query parsing \" .", "label": "", "metadata": {}, "score": "59.24076"}
{"text": "Because a character is added to the end of the text , all the trailing strings are extended ( changed ) and , basically , all the trailing strings may have to be re - arranged .In most cases , however , the leading string part of each trailing string used for comparison does not include all the characters to the end of the trailing string .", "label": "", "metadata": {}, "score": "59.2543"}
{"text": "Based on this data , therefore , signature length should be bounded between 20 and 100 , with lower correlated data sets requiring longer signatures .Clearly , a small hash space consumes less space ; but to be effective , the size of the hash space should be large enough so as to avoid collisions .", "label": "", "metadata": {}, "score": "59.263725"}
{"text": "14 illustrates absolute error measurements for performing set hashing with maximal overlap on the ( highly correlated ) SERVICE data set .In this example , the signature length was varied between 10 and 50 , with the storage space ranging between 0.07 % and 1.5 % .", "label": "", "metadata": {}, "score": "59.280144"}
{"text": "To register index items efficiently , they should be registered sequentially , beginning with the index item which has the largest start position ; in this case , the method described in [ 6 - 2 - 4 .Increasing the Efficiency of Index Updating ( A ) ] may be used together .", "label": "", "metadata": {}, "score": "59.302616"}
{"text": "( B )Registering \" w \" when the trailing string \" . alpha.w \" is already registered in the index .Assume that the trailing string \" . alpha.w \" is registered between . beta.x and . gamma.y ( .gamma.y ) in the index as shown in Table 21 .", "label": "", "metadata": {}, "score": "59.33958"}
{"text": "This results in less positions and more coarse position increments ( less precise ) .Conversely , smaller position increments increase the number of position , requiring a huge amount of storage .In this case , only discrete amounts such as integers can be represented in practice .", "label": "", "metadata": {}, "score": "59.349525"}
{"text": "It is also an object of the first embodiment to provide a data processing system which uses a simple processing procedure .It is still another object of the first embodiment to provide a data retrieval system which retrieves all , but non - duplicating , data strings containing the whole or a part of a key string of a specified length or shorter .", "label": "", "metadata": {}, "score": "59.383415"}
{"text": "means for merging the compact cluster representation to generate a merged cluster , the merging based upon a first overlap value applied to the at least one document with common item data , the merged cluster being based at least in part on a the demand factor .", "label": "", "metadata": {}, "score": "59.404922"}
{"text": "means for merging the compact cluster representation to generate a merged cluster , the merging based upon a first overlap value applied to the at least one document with common item data , the merged cluster being based at least in part on a the demand factor .", "label": "", "metadata": {}, "score": "59.404922"}
{"text": "Basic Algorithms and Rope Balancing .Concatenation is normally implemented by allocating a new concatenation node , and having it refer to the two arguments to the concatenation operation .Thus in most cases its execution time is independent of the length of strings .", "label": "", "metadata": {}, "score": "59.469612"}
{"text": "Basic Algorithms and Rope Balancing .Concatenation is normally implemented by allocating a new concatenation node , and having it refer to the two arguments to the concatenation operation .Thus in most cases its execution time is independent of the length of strings .", "label": "", "metadata": {}, "score": "59.469612"}
{"text": "Therefore , if the upper limit trailing string and the lower limit trailing string of this range have a same leading string that is k in length , all the intervening trailing strings also have the same leading string that is k in length .", "label": "", "metadata": {}, "score": "59.492157"}
{"text": "Therefore , by using a function of simple statistical measures like the mean , mode and variance , it may be possible to measure the cohesiveness of clusters .If , in applying one of these measures , the prices vary a little too much , this is may be an indication of a bad cluster , and the cluster may be dropped , or discarded .", "label": "", "metadata": {}, "score": "59.50395"}
{"text": "Therefore , by using a function of simple statistical measures like the mean , mode and variance , it may be possible to measure the cohesiveness of clusters .If , in applying one of these measures , the prices vary a little too much , this is may be an indication of a bad cluster , and the cluster may be dropped , or discarded .", "label": "", "metadata": {}, "score": "59.50395"}
{"text": "The following summarizes the text update function .( t12 )The function inserts a new text item immediately before or after a text item ( whichever is specified ) .( t13 )The function deletes a text item from the text .", "label": "", "metadata": {}, "score": "59.51284"}
{"text": "Second substrings may be overlapped ( FIG .19 ) .Therefore , by omitting the check and removal processing for duplications , the processing speed is increased .Although there may be more duplicate retrieval results in this case , the removal of three duplications can be done according to the procedure used for the removal of two duplications .", "label": "", "metadata": {}, "score": "59.545288"}
{"text": "Second substrings may be overlapped ( FIG .19 ) .Therefore , by omitting the check and removal processing for duplications , the processing speed is increased .Although there may be more duplicate retrieval results in this case , the removal of three duplications can be done according to the procedure used for the removal of two duplications .", "label": "", "metadata": {}, "score": "59.545288"}
{"text": "A data retrieval system as claimed in claim 38 , wherein said index is represented by a binary tree .A data retrieval system as claimed in claim 38 , wherein said text is said code string stored in contiguous addresses , each location being represented by an address .", "label": "", "metadata": {}, "score": "59.54928"}
{"text": "10 is an example of a binary tree in a data processing system using the \" interval control method \" ( retrieval ) ; .FIG .11 is an example of a binary tree in a data processing system using the \" interval control method \" ( retrieval ) ; .", "label": "", "metadata": {}, "score": "59.550636"}
{"text": "27 shows a combination of the dictionary nodes and text nodes shown in FIG .23 .Even in this format , an address may be stored instead of a character string .FIG .28 shows this configuration .In FIG .", "label": "", "metadata": {}, "score": "59.565754"}
{"text": "57 is an example of data stored in the conventional third method .An advantage of this method is that , when a substring is expanded or reduced , only the length of the interval of the expanded or reduced substring need be changed .", "label": "", "metadata": {}, "score": "59.592743"}
{"text": "Thus , a need remains in the prior art for a reasonable method of determining cross - counts in multidimensional data sets that neither \" explodes \" as the number of dimensions increase nor yields results that are inaccurate and unable to be used .", "label": "", "metadata": {}, "score": "59.605263"}
{"text": "beta . \" is being registered according to the above procedure , a trailing string beginning with \" .beta . \" may be registered if no comparison ( retrieval ) is necessary because of ( A ) or ( B ) .", "label": "", "metadata": {}, "score": "59.61442"}
{"text": "3 ! , N in the interval 4 . . .5 ! , 0 in the interval 6 . . .9 ! , 1 in the interval 10 . . .15 ! , and 0 in the interval 16 . . .", "label": "", "metadata": {}, "score": "59.623512"}
{"text": "3 ! , N in the interval 4 . . .5 ! , 0 in the interval 6 . . .9 ! , 1 in the interval 10 . . .15 ! , and 0 in the interval 16 . . .", "label": "", "metadata": {}, "score": "59.623512"}
{"text": "6 , a second set of dart throws would be used to generate a second signature vector designated as S B .Finally , \u03c1 , as an estimate of \u03c1 , is determined from the number of respective signature vector components in S A that match components in S B .", "label": "", "metadata": {}, "score": "59.662437"}
{"text": "In the CLE Tags approach , an important multiple tags concepts within the cluster is applied , while in the CLE BD approach , the best document ( e.g. , a centroid or average ) that best represents the majority of the documents within the cluster is selected .", "label": "", "metadata": {}, "score": "59.741608"}
{"text": "In the CLE Tags approach , an important multiple tags concepts within the cluster is applied , while in the CLE BD approach , the best document ( e.g. , a centroid or average ) that best represents the majority of the documents within the cluster is selected .", "label": "", "metadata": {}, "score": "59.741608"}
{"text": "An invention according to a 23 . sup.rd illustrative implementation is data processing system of the 22 . sup.nd illustrative implementation wherein the retrieving means has counting means for counting the number of sub strings , each containing an identical leading string , using the sequence numbers of the first dictionary data item and the last dictionary data item .", "label": "", "metadata": {}, "score": "59.7594"}
{"text": "By building this set of relevant words , the search process is benefited , as the relevancy of clusters / cluster tags may be enhanced , and the recall / retrieval process is benefited as noise words are eliminated , improving recall .", "label": "", "metadata": {}, "score": "59.824753"}
{"text": "By building this set of relevant words , the search process is benefited , as the relevancy of clusters / cluster tags may be enhanced , and the recall / retrieval process is benefited as noise words are eliminated , improving recall .", "label": "", "metadata": {}, "score": "59.824753"}
{"text": "A data processing system as claimed in claim 1 , wherein the length of a key - candidate substring constituting said dictionary data is limited .A data processing system as claimed in claim 1 , wherein the length of a key - candidate substring constituting said dictionary data is not limited .", "label": "", "metadata": {}, "score": "59.85578"}
{"text": "FIGS . 10 ( a ) and ( b ) illustrate a comparison of the average error for the set hashing method of the present invention , as compared against a set of four different prior art methods , as discussed above .", "label": "", "metadata": {}, "score": "59.86364"}
{"text": "16 is a flowchart illustrating a method used to implement or execute an operation that clusters the search results , according to an example embodiment .FIG .17 shows a diagrammatic representation of a machine in the example form of a computer system within which a set of instructions for causing the machine to perform any one or more of the methodologies discussed herein may be executed , according to an example embodiment .", "label": "", "metadata": {}, "score": "59.88741"}
{"text": "16 is a flowchart illustrating a method used to implement or execute an operation that clusters the search results , according to an example embodiment .FIG .17 shows a diagrammatic representation of a machine in the example form of a computer system within which a set of instructions for causing the machine to perform any one or more of the methodologies discussed herein may be executed , according to an example embodiment .", "label": "", "metadata": {}, "score": "59.88741"}
{"text": "12 ( a ) , it is shown that as space increases , the accuracy for the set hashing method of the present invention improves steadily to reach acceptable error rates , even with only 1.5 % space allowed for deriving the estimation .", "label": "", "metadata": {}, "score": "59.907734"}
{"text": "According to the invention as claimed in claim 15 , the restoring means restores a substring based on dictionary data , eliminating the need to save the substring on which the tree is based and thereby requiring less storage .Because the restoration of a substring does not depend on the length of the original code , processing efficiency is further increased .", "label": "", "metadata": {}, "score": "59.92627"}
{"text": "According to the invention as claimed in claim 15 , the restoring means restores a substring based on dictionary data , eliminating the need to save the substring on which the tree is based and thereby requiring less storage .Because the restoration of a substring does not depend on the length of the original code , processing efficiency is further increased .", "label": "", "metadata": {}, "score": "59.92627"}
{"text": "70 ( c ) is a diagram showing one type of rebalancing ( double rotation ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .FIG .71 is a diagram showing the binary tree in which node colors have been changed in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "59.94543"}
{"text": "70 ( c ) is a diagram showing one type of rebalancing ( double rotation ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .FIG .71 is a diagram showing the binary tree in which node colors have been changed in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "59.94543"}
{"text": "Pr .I .Pr .I .Pr .II .For example , in the first method , preprocessing builds PSTs and the cross - count matrix , parsing is greedy , cross - count lookup involves matrix look - up , and estimation is a product operation .", "label": "", "metadata": {}, "score": "59.95987"}
{"text": "The function ( t13 ) allows the updating means 12 to delete text items , no longer necessary because of a change in the code string 1 , from the text 23 .In addition , the function ( t12 ) allows the updating means 12 to add new text items to the text 23 as a character is inserted into or added to the code string 1 .", "label": "", "metadata": {}, "score": "59.97934"}
{"text": "As described above , in this embodiment , the appearance positions of the pattern \" ab \" in the text can be determined easily with no duplication .[ 1 - 2 - 1 - 2 .Updating the Dictionary When Characters in the Text Are Changed ] .", "label": "", "metadata": {}, "score": "60.007286"}
{"text": "1027 - 1040 , Oct. 1991 .Pattern Recognition , vol .24 , No . 7 , pp .711 - 716 , Jan. 1 , 1991 , Shufen Kuo , et al . , \" A Two - Step String - Matching Procedure \" .", "label": "", "metadata": {}, "score": "60.008934"}
{"text": "In addition , the upper limit or lower limit which has a longer matching leading - string length is the leading string in the index which has the longest leading - string that matches the code string .The matching leading - string length represents the length for which the leading string of the upper limit or the lower limit matches the code string .", "label": "", "metadata": {}, "score": "60.01493"}
{"text": "Then , an operation 1406 is executed that receives weighted scores , wherein these weighted scores are received through the execution of operation 201 .Upon the execution of operations 1406 , 1403 and 1405 , an operation 1407 is executed that generates a merged cluster map as is depicted in , for example , .", "label": "", "metadata": {}, "score": "60.053135"}
{"text": "Then , an operation 1406 is executed that receives weighted scores , wherein these weighted scores are received through the execution of operation 201 .Upon the execution of operations 1406 , 1403 and 1405 , an operation 1407 is executed that generates a merged cluster map as is depicted in , for example , .", "label": "", "metadata": {}, "score": "60.053135"}
{"text": "In some embodiments , a system and method is disclosed for building a searchable data structure wherein each node in the data structure contains clusters of data .These clusters are generated based upon a variety of factors , including , for example , relevancy weighting , seller factors , price factors , category factors , image factors , and other suitable factors .", "label": "", "metadata": {}, "score": "60.066414"}
{"text": "In some embodiments , a system and method is disclosed for building a searchable data structure wherein each node in the data structure contains clusters of data .These clusters are generated based upon a variety of factors , including , for example , relevancy weighting , seller factors , price factors , category factors , image factors , and other suitable factors .", "label": "", "metadata": {}, "score": "60.066414"}
{"text": "By indexing on substrings rather than individual element names , our XTrie index provides a much more effective indexing mechanism than XFilter .A further limitation of XFilter is that its space requirement can grow to a very large size as an input document is parsed , which can also increase the filtering time significantly .", "label": "", "metadata": {}, "score": "60.093456"}
{"text": "More specifically , the first maintaining means 12 maintains the boundary interval at k or longer as follows .When the boundary interval is less than k ( FIG .8) , the first maintaining means 12 erases one of two boundaries associated with the interval ( FIG .", "label": "", "metadata": {}, "score": "60.09709"}
{"text": "More specifically , the first maintaining means 12 maintains the boundary interval at k or longer as follows .When the boundary interval is less than k ( FIG .8) , the first maintaining means 12 erases one of two boundaries associated with the interval ( FIG .", "label": "", "metadata": {}, "score": "60.09709"}
{"text": "FIG .70 shows rebalancing that is performed when condition 2 is not satisfied .That is , nodes x , f , g , and h in FIG .69 correspond to ( a ) in FIG .70 .Therefore , the color of node g is changed to red , and the colors of child nodes f and h are changed from red to black so that rank ( g ) is one level higher than other nodes .", "label": "", "metadata": {}, "score": "60.149498"}
{"text": "FIG .70 shows rebalancing that is performed when condition 2 is not satisfied .That is , nodes x , f , g , and h in FIG .69 correspond to ( a ) in FIG .70 .Therefore , the color of node g is changed to red , and the colors of child nodes f and h are changed from red to black so that rank ( g ) is one level higher than other nodes .", "label": "", "metadata": {}, "score": "60.149498"}
{"text": "A base cluster may be a set of electronic documents ( e.g. , online transactions ) that share common phrases in their item titles , or other type of common string based data .A suffix trie is then constructed for the purpose of organizing these electronic documents so as to allow for the retrieval of relevant search results .", "label": "", "metadata": {}, "score": "60.171165"}
{"text": "A base cluster may be a set of electronic documents ( e.g. , online transactions ) that share common phrases in their item titles , or other type of common string based data .A suffix trie is then constructed for the purpose of organizing these electronic documents so as to allow for the retrieval of relevant search results .", "label": "", "metadata": {}, "score": "60.171165"}
{"text": "A data processing system as claimed in claim 1 , wherein said code string is text containing a plurality of lines , . said interval is a line included in the text , and .A data processing system as claimed in claim 1 , wherein said code string is text containing a plurality of lines of a fixed length , and .", "label": "", "metadata": {}, "score": "60.20115"}
{"text": "A data processing system as claimed in claim 1 , wherein said code string is text containing a plurality of lines , . said interval is a line included in the text , and .A data processing system as claimed in claim 1 , wherein said code string is text containing a plurality of lines of a fixed length , and .", "label": "", "metadata": {}, "score": "60.20115"}
{"text": "FIG .10 is a block diagram of an example computer system such as the application server 111 .The various blocks illustrated herein may be implemented in hardware , firmware , or even software .In some embodiments , the item data includes at least one of an item title , an item category , and seller information .", "label": "", "metadata": {}, "score": "60.202454"}
{"text": "FIG .10 is a block diagram of an example computer system such as the application server 111 .The various blocks illustrated herein may be implemented in hardware , firmware , or even software .In some embodiments , the item data includes at least one of an item title , an item category , and seller information .", "label": "", "metadata": {}, "score": "60.202454"}
{"text": "Variation of the First Embodiment ] .A data retrieval system , described below , comprising some components of the data processing system in this embodiment may be built .This simply - structured data retrieval system with the configuration described above finds , within the text , the positions of all the non - duplicating appearances of a pattern to retrieved .", "label": "", "metadata": {}, "score": "60.225365"}
{"text": "An invention according to a 71 . sup.st illustrative implementation is a data retrieval system of the 60 . sup.th illustrative implementation wherein the text is the code string stored in contiguous addresses , each location being represented by an address .", "label": "", "metadata": {}, "score": "60.258453"}
{"text": "They are a subclass of function nodes , and a number of operations treat them simply as function nodes .Many uses of ropes will never result in the generation of a substring node .They are however essential for applications that use function nodes to lazily evaluate strings .", "label": "", "metadata": {}, "score": "60.269497"}
{"text": "They are a subclass of function nodes , and a number of operations treat them simply as function nodes .Many uses of ropes will never result in the generation of a substring node .They are however essential for applications that use function nodes to lazily evaluate strings .", "label": "", "metadata": {}, "score": "60.269497"}
{"text": "The data processing system using the interval control method , which has one node for each interval as described above , requires as many data blocks as intervals and so eliminates the need to use as many memory units as there are nodes , thereby increasing memory usage efficiency .", "label": "", "metadata": {}, "score": "60.272835"}
{"text": "Assume that , in the above example , the trailing string \" Xcab \" which is longer than \" cab \" , the shortest trailing string not requiring re - arrange operation , requires the whole trailing string to be compared .", "label": "", "metadata": {}, "score": "60.33767"}
{"text": "This happens , for example , when a part of text is copied to another location and a trailing string beginning either at the copied part ( changed position ) or to the left of the copied part is registered ( re - arranged ) in the index .", "label": "", "metadata": {}, "score": "60.3484"}
{"text": "In restoring a text , this method eliminates the need to reference the contents of a node in the dictionary tree ; the pointer value to a node in the text tree gives us a character string itself , ensuring efficient processing .", "label": "", "metadata": {}, "score": "60.368797"}
{"text": "FOURTH EMBODIMENT .The second substrings need not be consecutive ; each of them need only extend across the first boundary and , in addition , be k or longer apart from each side of the first boundary ( fourth embodiment ) .", "label": "", "metadata": {}, "score": "60.399033"}
{"text": "FOURTH EMBODIMENT .The second substrings need not be consecutive ; each of them need only extend across the first boundary and , in addition , be k or longer apart from each side of the first boundary ( fourth embodiment ) .", "label": "", "metadata": {}, "score": "60.399033"}
{"text": "A data processing system comprising : . updating means for updating , based on a change to said code string , the index and the text of said code string associated with the change , .A data processing system comprising : . index generating means for generating said index ; . text generating means for generating said text ; . changing means for changing said code string ; and .", "label": "", "metadata": {}, "score": "60.400574"}
{"text": "8 shows an example of a substring in the first embodiment of this invention ; .FIG .9 shows an example of a substring in the first embodiment of this invention ; .FIG .10 shows an example of a substring in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "60.403873"}
{"text": "8 shows an example of a substring in the first embodiment of this invention ; .FIG .9 shows an example of a substring in the first embodiment of this invention ; .FIG .10 shows an example of a substring in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "60.403873"}
{"text": "The data processing system also has a dictionary tree generating means 5 which generates a dictionary tree 4 based on the dictionary data 2 .In addition , the data processing system in this embodiment has a text data generating means 7 which generates text data 6 .", "label": "", "metadata": {}, "score": "60.434982"}
{"text": "FIG .14 is a flowchart illustrating an example method used to implement or execute operation 204 .Illustrated is an operation 1401 that receives item data .This item data may be , for example , the previously illustrated data relating to a sale or advertisement for the sale of a good or service , where this advertisement is considered a document .", "label": "", "metadata": {}, "score": "60.47113"}
{"text": "FIG .14 is a flowchart illustrating an example method used to implement or execute operation 204 .Illustrated is an operation 1401 that receives item data .This item data may be , for example , the previously illustrated data relating to a sale or advertisement for the sale of a good or service , where this advertisement is considered a document .", "label": "", "metadata": {}, "score": "60.47113"}
{"text": "Additional details with regard to each one of these operations will be more fully illustrated below .Document Preparation .In some embodiments , text in the form of strings are processed , wherein these strings are capable of reversible mapping to other strings .", "label": "", "metadata": {}, "score": "60.525574"}
{"text": "Additional details with regard to each one of these operations will be more fully illustrated below .Document Preparation .In some embodiments , text in the form of strings are processed , wherein these strings are capable of reversible mapping to other strings .", "label": "", "metadata": {}, "score": "60.525574"}
{"text": "For each input XML document , the total filtering time , which includes the CPU time to parse the input document , probe and update the index , and report the matched expressions , was measured .The performance metric for each category of documents ( small , medium , or large ) is the average filtering time over the set of 250 XML documents for that category .", "label": "", "metadata": {}, "score": "60.5596"}
{"text": "The property of being strongly present is boolean ( e.g. , a phrase is strongly present or not ) .Next , we define the Term Density ( TD ) score of a phrase p as the number of clusters in which phrase p is strongly present .", "label": "", "metadata": {}, "score": "60.56041"}
{"text": "The property of being strongly present is boolean ( e.g. , a phrase is strongly present or not ) .Next , we define the Term Density ( TD ) score of a phrase p as the number of clusters in which phrase p is strongly present .", "label": "", "metadata": {}, "score": "60.56041"}
{"text": "[ 0018]FIGS . 1A and 1B together illustrate unordered and ordered matching in exemplary XML document trees ; . [ 0019 ] .FIGS . 2A- 2 C together illustrate substring decompositions in exemplary XPath expression trees ; .[ 0020 ] .", "label": "", "metadata": {}, "score": "60.6354"}
{"text": "An invention according to a 69 . sup.th illustrative implementation is a data processing system of the 61 . sup.st illustrative implementation wherein the text is the code string stored in contiguous addresses , each location being represented by an address .", "label": "", "metadata": {}, "score": "60.743996"}
{"text": "8 is an example of data in a data processing system using the \" interval control method \" ; .FIG .9 is a flowchart showing the procedure for retrieving data in a data processing system using the \" interval control method \" ; .", "label": "", "metadata": {}, "score": "60.747345"}
{"text": "The method of .claim 1 , wherein the item data includes at least one of an item title , an item category , or seller information .The method of .claim 1 , wherein the item data is part of a plurality of merged clusters organized into a hierarchy of merged clusters .", "label": "", "metadata": {}, "score": "60.749474"}
{"text": "The faster search results are returned , the more efficient and effective a website is viewed by users and customers .In some embodiments , efficient data structures are leveraged to generate aggregations of searchable item data using a suffix ordering .", "label": "", "metadata": {}, "score": "60.796436"}
{"text": "The faster search results are returned , the more efficient and effective a website is viewed by users and customers .In some embodiments , efficient data structures are leveraged to generate aggregations of searchable item data using a suffix ordering .", "label": "", "metadata": {}, "score": "60.796436"}
{"text": "49 .a1-F1-E1 Formula 21 !During execution of splaying , double rotation ( zig - zig ) is first applied to nodes a , b , c , E , and D. This operation replaces node a with node c , and moves node a to the right child position of node d. FIG .", "label": "", "metadata": {}, "score": "60.848656"}
{"text": "49 .a1-F1-E1 Formula 21 !During execution of splaying , double rotation ( zig - zig ) is first applied to nodes a , b , c , E , and D. This operation replaces node a with node c , and moves node a to the right child position of node d. FIG .", "label": "", "metadata": {}, "score": "60.848656"}
{"text": "alpha .gamma . , then w is registered between x and y. .If this condition is not satisfied , retrieval is performed with \" w \" as the key to determine the insertion position .[ 6 - 2 - 5 .", "label": "", "metadata": {}, "score": "60.86517"}
{"text": "Other embodiments ] .Because this invention is not limited to the embodiments above but is applicable to other various types of embodiments , including the following .In those embodiments described above , the data lexicographically - arranged key - candidate substrings based on alphabetically order , is explained .", "label": "", "metadata": {}, "score": "60.87485"}
{"text": "11 shows an example of a substring in the first embodiment of this invention ; .FIG .12 shows an example of a substring in the first embodiment of this invention ; .FIG .13 shows an example of a substring in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "60.887524"}
{"text": "11 shows an example of a substring in the first embodiment of this invention ; .FIG .12 shows an example of a substring in the first embodiment of this invention ; .FIG .13 shows an example of a substring in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "60.887524"}
{"text": "RSS .Other Adobe Projects .Other Resources .Rope Implementation Overview .A rope is represented as a pointer to _ Rope_RopeRep structure , which represents a tree node .Every tree node corresponds to a piece of a rope .", "label": "", "metadata": {}, "score": "60.8897"}
{"text": "Next , the cluster label of C i is picked as a sequence of all the strongly present phrases in the selected best document .FIG .15 is a flowchart illustrating an example method used to execute operation 207 .Illustrated is an operation 1501 that receives a merged cluster map , such as that depicted in .", "label": "", "metadata": {}, "score": "60.94614"}
{"text": "Next , the cluster label of C i is picked as a sequence of all the strongly present phrases in the selected best document .FIG .15 is a flowchart illustrating an example method used to execute operation 207 .Illustrated is an operation 1501 that receives a merged cluster map , such as that depicted in .", "label": "", "metadata": {}, "score": "60.94614"}
{"text": "An invention according to a 67 . sup.th illustrative implementation is a data retrieval system of the 60 . sup.th illustrative implementation wherein the index is represented by a binary tree .According to the inventions of the 64 . sup.th trough 67 . sup.th illustrative implementations , representing the index as a binary tree significantly increases retrieval efficiency .", "label": "", "metadata": {}, "score": "60.96791"}
{"text": "2 , such as ( abc ) , are not stored in nodes ; they are shown for reference only .[ 1 - 2 - 1 - 1 .Retrieving a Position Where a Specified Pattern Occurs ] .The following explains how to retrieve a pattern , such as \" ab \" , in a tree representing the dictionary data 2 ( hereafter called a dictionary tree ) .", "label": "", "metadata": {}, "score": "60.97989"}
{"text": "The actual category is chosen by the seller of the item .The categories themselves , however , may be pre - defined .A seller may try his / her best to put an item in the right leaf category .", "label": "", "metadata": {}, "score": "61.07558"}
{"text": "The actual category is chosen by the seller of the item .The categories themselves , however , may be pre - defined .A seller may try his / her best to put an item in the right leaf category .", "label": "", "metadata": {}, "score": "61.07558"}
{"text": "These factors may be applied at any one of the stages of filtering out noise , building an uncompacted trie ( e.g. , data structure ) , building a compacted trie ( e.g. , data structure ) , building the merged cluster map , or even after these stages .", "label": "", "metadata": {}, "score": "61.082924"}
{"text": "These factors may be applied at any one of the stages of filtering out noise , building an uncompacted trie ( e.g. , data structure ) , building a compacted trie ( e.g. , data structure ) , building the merged cluster map , or even after these stages .", "label": "", "metadata": {}, "score": "61.082924"}
{"text": "While increased computing power may be one solution , another solution is to generate a more effective sorting , and search algorithm .When determining what is an effective sorting and search algorithm , one place to begin is with the data structure and the ability of that data structure to process a set of data .", "label": "", "metadata": {}, "score": "61.09764"}
{"text": "While increased computing power may be one solution , another solution is to generate a more effective sorting , and search algorithm .When determining what is an effective sorting and search algorithm , one place to begin is with the data structure and the ability of that data structure to process a set of data .", "label": "", "metadata": {}, "score": "61.09764"}
{"text": "According to the invention as claimed in claim 14 , the second maintaining means maintains the boundary interval at a length equal to or less than a specified length , preventing the dictionary data size and the update time from increasing .", "label": "", "metadata": {}, "score": "61.10993"}
{"text": "According to the invention as claimed in claim 14 , the second maintaining means maintains the boundary interval at a length equal to or less than a specified length , preventing the dictionary data size and the update time from increasing .", "label": "", "metadata": {}, "score": "61.10993"}
{"text": "FIG .61 is a diagram showing the binary tree to which node X has been added as the right child of node L in the sixth embodiment of this invention ; .FIG .62 is a diagram showing the binary tree , shown in FIG .", "label": "", "metadata": {}, "score": "61.120464"}
{"text": "FIG .61 is a diagram showing the binary tree to which node X has been added as the right child of node L in the sixth embodiment of this invention ; .FIG .62 is a diagram showing the binary tree , shown in FIG .", "label": "", "metadata": {}, "score": "61.120464"}
{"text": "For example , we could use price information as an additional parameter into the clustering system , such that clusters that are closer to each other in the price range might contribute as additional factor for merging criteria .In some embodiments , the various clusters illustrated in .", "label": "", "metadata": {}, "score": "61.163364"}
{"text": "For example , we could use price information as an additional parameter into the clustering system , such that clusters that are closer to each other in the price range might contribute as additional factor for merging criteria .In some embodiments , the various clusters illustrated in .", "label": "", "metadata": {}, "score": "61.163364"}
{"text": "The longest match node is a node at which the last match of the key code string , consisting of one or more labels beginning at the root , occurs .The procedure for finding it is described below .If the key string does not end when the longest match node is found ( step 44 ) , it is determined that the trailing string is not any of the already - stored trailing strings .", "label": "", "metadata": {}, "score": "61.190323"}
{"text": "The longest match node is a node at which the last match of the key code string , consisting of one or more labels beginning at the root , occurs .The procedure for finding it is described below .If the key string does not end when the longest match node is found ( step 44 ) , it is determined that the trailing string is not any of the already - stored trailing strings .", "label": "", "metadata": {}, "score": "61.190323"}
{"text": "An invention according to claim 16 is a data retrieval system as claimed in claim 1 or 3 , wherein dictionary data of a plurality of substrings is generated as a single tree .The invention of claim 44 realizes the invention of the claim 16 from a methodological standpoint and is a data retrieval method as claimed in claim 37 or 39 , wherein dictionary data of a plurality of substrings is generated as a single tree .", "label": "", "metadata": {}, "score": "61.196743"}
{"text": "An invention according to claim 16 is a data retrieval system as claimed in claim 1 or 3 , wherein dictionary data of a plurality of substrings is generated as a single tree .The invention of claim 44 realizes the invention of the claim 16 from a methodological standpoint and is a data retrieval method as claimed in claim 37 or 39 , wherein dictionary data of a plurality of substrings is generated as a single tree .", "label": "", "metadata": {}, "score": "61.196743"}
{"text": "In addition , this invention saves storage space significantly because character strings need only be stored in at least one of the dictionary tree and text tree .Therefore , when one or more characters are added to the text , this invention significantly reduces the time needed to update the dictionary .", "label": "", "metadata": {}, "score": "61.239815"}
{"text": "When processing data strings on a computer , it is necessary to match a data value in a data string against the position within the data string where the data value is stored .More specifically , it is necessary , during character string editing , to get a code that is in a particular position in a character string ; for example , to retrieve the 100-th character from a character string .", "label": "", "metadata": {}, "score": "61.265244"}
{"text": "When processing data strings on a computer , it is necessary to match a data value in a data string against the position within the data string where the data value is stored .More specifically , it is necessary , during character string editing , to get a code that is in a particular position in a character string ; for example , to retrieve the 100-th character from a character string .", "label": "", "metadata": {}, "score": "61.265244"}
{"text": "JJ .In some embodiments , cluster quality is an important measure .Cluster quality may be defined as follows .For each cluster , we have defined cluster tags .Cluster tags aggregated define the theme of that cluster .If the cluster tags are fairly independent of each other that indicate that the cluster quality is good .", "label": "", "metadata": {}, "score": "61.283367"}
{"text": "JJ .In some embodiments , cluster quality is an important measure .Cluster quality may be defined as follows .For each cluster , we have defined cluster tags .Cluster tags aggregated define the theme of that cluster .If the cluster tags are fairly independent of each other that indicate that the cluster quality is good .", "label": "", "metadata": {}, "score": "61.283367"}
{"text": "This sum is called a partial interval length .FIG .6 shows an example of the binary tree 31 , and FIG .7 explains the binary tree 31 in FIG .6 .These figures indicate the interval length and the code value , shown in FIG .", "label": "", "metadata": {}, "score": "61.302303"}
{"text": "36 .To do so , the trailing string must be compared with the trailing string immediately before or after the trailing string in the index .However , to find all these items , it is necessary to compare approximately ( length of copied part ) .", "label": "", "metadata": {}, "score": "61.334045"}
{"text": "Correctness here may be understood as based upon certain norms related to the categorization of items for sale .Here a category factor could be used to mean that items belong to the same category and to indicate that the items in the cluster are homogeneous .", "label": "", "metadata": {}, "score": "61.343834"}
{"text": "Correctness here may be understood as based upon certain norms related to the categorization of items for sale .Here a category factor could be used to mean that items belong to the same category and to indicate that the items in the cluster are homogeneous .", "label": "", "metadata": {}, "score": "61.343834"}
{"text": "35 . . .Interval identifying means .41 . . .Interval length changing means .42 . . .Adding means .43 . . .Deleting means .45 . . .Structure adjusting means .DETAILED DESCRIPTION .", "label": "", "metadata": {}, "score": "61.457504"}
{"text": "This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim .Rather , as the following claims reflect , inventive subject matter lies in less than all features of a single disclosed embodiment .", "label": "", "metadata": {}, "score": "61.459137"}
{"text": "This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim .Rather , as the following claims reflect , inventive subject matter lies in less than all features of a single disclosed embodiment .", "label": "", "metadata": {}, "score": "61.459137"}
{"text": "5 is a diagram of an uncompacted tree 500 that may be generated through the execution of , for example , an STC algorithm , such as the one utilized in operation 204 .For example , subtree 501 contains nodes 3 through 7 wherein , for example , node 3 labeled herein as 502 , is linked to a node 4 labeled 503 through the edge labeled \" Pepsi . \"", "label": "", "metadata": {}, "score": "61.4607"}
{"text": "5 is a diagram of an uncompacted tree 500 that may be generated through the execution of , for example , an STC algorithm , such as the one utilized in operation 204 .For example , subtree 501 contains nodes 3 through 7 wherein , for example , node 3 labeled herein as 502 , is linked to a node 4 labeled 503 through the edge labeled \" Pepsi . \"", "label": "", "metadata": {}, "score": "61.4607"}
{"text": "And an invention according to a 31 . sup.st illustrative implementation is a data retrieval system of the 26 . sup.th illustrative implementation wherein the length of a key - candidate substring constituting the dictionary data is not limited .According to the invention of the 30 . sup.th and 31 . sup.st illustrative implementations , not limiting the length of a key - candidate substring eliminates the need for a subsequent check on the subsequent portion of each substring in the text .", "label": "", "metadata": {}, "score": "61.50125"}
{"text": "The XTrie index relies on substring decompositions for installing XPEs into the indexing structure .The choice of a specific class of substring decompositions impacts both the space and performance of the index .Though all substring decompositions fall within the broad scope of the present invention , minimal decompositions , in particular , have two important performance advantages .", "label": "", "metadata": {}, "score": "61.516647"}
{"text": "This means that , because a trailing string ends at the end of the substring , each trailing string is uniquely identified once the start position is determined .For example , the number of the trailing string \" abc \" is 3 and it ends at the end of the substring \" ababc \" and , so , the starting position is determined to be 2 .", "label": "", "metadata": {}, "score": "61.56462"}
{"text": "This means that , because a trailing string ends at the end of the substring , each trailing string is uniquely identified once the start position is determined .For example , the number of the trailing string \" abc \" is 3 and it ends at the end of the substring \" ababc \" and , so , the starting position is determined to be 2 .", "label": "", "metadata": {}, "score": "61.56462"}
{"text": "85 is an example of data stored in the conventional third method .An advantage of this method is that , when a substring is expanded or reduced , only the length of the interval of the expanded or reduced substring need be changed .", "label": "", "metadata": {}, "score": "61.597633"}
{"text": "85 is an example of data stored in the conventional third method .An advantage of this method is that , when a substring is expanded or reduced , only the length of the interval of the expanded or reduced substring need be changed .", "label": "", "metadata": {}, "score": "61.597633"}
{"text": "An invention according to a 37 . sup.th illustrative implementation is a data processing system of the 33 . sup.rd illustrative implementation wherein , when registering the leading string of the trailing string . alpha.w in a table arranged lexicographically with the leading string of the trailing string as the key , said registering means registers the leading string of . alpha.w immediately after the leading string of .", "label": "", "metadata": {}, "score": "61.62487"}
{"text": "14 is a flowchart illustrating a method used to implement or execute a suffix tree cluster algorithm , according to an example embodiment .FIG .15 is a flowchart illustrating a method used to execute an operation that labels various clusters , according to an example embodiment .", "label": "", "metadata": {}, "score": "61.624954"}
{"text": "14 is a flowchart illustrating a method used to implement or execute a suffix tree cluster algorithm , according to an example embodiment .FIG .15 is a flowchart illustrating a method used to execute an operation that labels various clusters , according to an example embodiment .", "label": "", "metadata": {}, "score": "61.624954"}
{"text": "A data processing system as claimed in claim 14 , wherein rotation , double rotation ( zig - zig ) and double rotation ( zig - zag ) are used as a structure adjustment procedure for changing the structure while maintaining the sequence of said nodes of said binary tree .", "label": "", "metadata": {}, "score": "61.628593"}
{"text": "A data processing system as claimed in claim 14 , wherein rotation , double rotation ( zig - zig ) and double rotation ( zig - zag ) are used as a structure adjustment procedure for changing the structure while maintaining the sequence of said nodes of said binary tree .", "label": "", "metadata": {}, "score": "61.628593"}
{"text": "Distributed Computing Components and Protocols .Some example embodiments may include remote procedure calls being used to implement one or more of the above illustrated components across a distributed programming environment as distributed computing components .For example , an interface component ( e.g. , an interface tier ) may reside on a first computer system that is remotely located from a second computer system containing a logic component ( e.g. , a logic tier ) .", "label": "", "metadata": {}, "score": "61.640907"}
{"text": "Distributed Computing Components and Protocols .Some example embodiments may include remote procedure calls being used to implement one or more of the above illustrated components across a distributed programming environment as distributed computing components .For example , an interface component ( e.g. , an interface tier ) may reside on a first computer system that is remotely located from a second computer system containing a logic component ( e.g. , a logic tier ) .", "label": "", "metadata": {}, "score": "61.640907"}
{"text": "42 , the left half is a binary tree representing a text .Each node contains a character stored in each position of the code string .This character is also the first character of the trailing string starting in that position .", "label": "", "metadata": {}, "score": "61.6679"}
{"text": "Using this merged cluster map 113 , a search result 114 may be generated and provided to the user 101 via the search interface 107 .In some embodiments , the query 108 may be sent to more than one web server 110 .", "label": "", "metadata": {}, "score": "61.711723"}
{"text": "Using this merged cluster map 113 , a search result 114 may be generated and provided to the user 101 via the search interface 107 .In some embodiments , the query 108 may be sent to more than one web server 110 .", "label": "", "metadata": {}, "score": "61.711723"}
{"text": "64 is a diagram showing the binary tree in which node X to be deleted has been moved to the root by means of splaying in the sixth embodiment of this invention ; .FIG .65 is a diagram showing the binary tree in which node R immediately following node X to be deleted has been moved to the root by means of splaying in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "61.742737"}
{"text": "64 is a diagram showing the binary tree in which node X to be deleted has been moved to the root by means of splaying in the sixth embodiment of this invention ; .FIG .65 is a diagram showing the binary tree in which node R immediately following node X to be deleted has been moved to the root by means of splaying in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "61.742737"}
{"text": "68 is a diagram showing information contained in a node in a sample balanced binary tree in the sixth embodiment of this invention ; .FIG .69 is a diagram showing the tree , shown in FIG .67 , where ( a node representing ) a new interval x has been inserted to the left of the interval representing node f in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "61.763206"}
{"text": "68 is a diagram showing information contained in a node in a sample balanced binary tree in the sixth embodiment of this invention ; .FIG .69 is a diagram showing the tree , shown in FIG .67 , where ( a node representing ) a new interval x has been inserted to the left of the interval representing node f in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "61.763206"}
{"text": "This change was made to accommodate STL code that assumes small iterators that can be cheaply passed by value .We try to aid such code further by providing an iterator assignment operation which does not copy the cache part of the iterator unless it has been initialized .", "label": "", "metadata": {}, "score": "61.82074"}
{"text": "This change was made to accommodate STL code that assumes small iterators that can be cheaply passed by value .We try to aid such code further by providing an iterator assignment operation which does not copy the cache part of the iterator unless it has been initialized .", "label": "", "metadata": {}, "score": "61.82074"}
{"text": "Finally , FIG .8D compares the effect of the \" depth \" of the XPEs on the performance of the filtering algorithms .The graphs show that the performance of all the algorithms improves slightly as the depth of the XPEs increases .", "label": "", "metadata": {}, "score": "61.924282"}
{"text": "And an invention according to a 52 .According to the data processing system of the 51 . sup.st illustrative implementation and the data processing method of the 52 . sup.nd illustrative implementation , an efficient data processing system and the data processing method , which can compare two substrings easily and can restore the whole or a part of a code string , can be configured .", "label": "", "metadata": {}, "score": "61.92469"}
{"text": "BRIEF DESCRIPTION OF THE DRAWINGS .FIG .1 is a functional block diagram showing the configuration of the first embodiment of this invention ; .FIG .2 shows an example of substrings in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "62.028206"}
{"text": "BRIEF DESCRIPTION OF THE DRAWINGS .FIG .1 is a functional block diagram showing the configuration of the first embodiment of this invention ; .FIG .2 shows an example of substrings in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "62.028206"}
{"text": "42 is a diagram showing the configuration of the eighth embodiment of this invention ; .FIG .43 is a flowchart showing the procedure for determining the node immediately preceding a specified node ; .FIG .44 is a flowchart showing the procedure for determining the node immediately preceding a specified node by splaying ; .", "label": "", "metadata": {}, "score": "62.048798"}
{"text": "The collection of automata for all the tree patterns is indexed using a hash table on the single element names ( i.e. , automata transitions ) .[ 0090 ] .XTrie is more space - efficient than XFilter , since the space cost of XTrie is dominated by the number of substrings in each tree pattern , while the space cost of XFilter is dominated by the number of element names in each tree pattern .", "label": "", "metadata": {}, "score": "62.05022"}
{"text": "50 is a conceptual diagram showing the format of data contained each n ode .As this figure shows , data contained in each node consists of a pointer to the right child , a pointer to the left child , a pointer to the higher - level node ( parent ) , and the partial interval length of the node .", "label": "", "metadata": {}, "score": "62.10627"}
{"text": "50 is a conceptual diagram showing the format of data contained each n ode .As this figure shows , data contained in each node consists of a pointer to the right child , a pointer to the left child , a pointer to the higher - level node ( parent ) , and the partial interval length of the node .", "label": "", "metadata": {}, "score": "62.10627"}
{"text": "42 : Adding means .43 : Deleting means .45 : Structure adjusting means .DETAILED DESCRIPTION .Referring to the attached drawings , there is shown a preferred embodiment ( hereafter called embodiment ) of the this invention .Notice that the embodiment described below is implemented on a computer and that each function of the embodiment is implemented by a procedure ( program ) controlling this computer .", "label": "", "metadata": {}, "score": "62.1617"}
{"text": "42 : Adding means .43 : Deleting means .45 : Structure adjusting means .DETAILED DESCRIPTION .Referring to the attached drawings , there is shown a preferred embodiment ( hereafter called embodiment ) of the this invention .Notice that the embodiment described below is implemented on a computer and that each function of the embodiment is implemented by a procedure ( program ) controlling this computer .", "label": "", "metadata": {}, "score": "62.1617"}
{"text": "This query 108 may be , for example , a search query generated for the purposes of searching some type of web accessible database .In one embodiment , the query 108 is sent across a network 109 to a web server 110 .", "label": "", "metadata": {}, "score": "62.19332"}
{"text": "This query 108 may be , for example , a search query generated for the purposes of searching some type of web accessible database .In one embodiment , the query 108 is sent across a network 109 to a web server 110 .", "label": "", "metadata": {}, "score": "62.19332"}
{"text": "FIG .77 is an example of table ( dictionary ) containing positions and substring identifiers for the code string \" abbabb$ \" .In this figure , the symbol $ is a dummy code appended at the end of the code string to identify the position .", "label": "", "metadata": {}, "score": "62.203354"}
{"text": "FIG .77 is an example of table ( dictionary ) containing positions and substring identifiers for the code string \" abbabb$ \" .In this figure , the symbol $ is a dummy code appended at the end of the code string to identify the position .", "label": "", "metadata": {}, "score": "62.203354"}
{"text": "An approach for multidimensional substring selectivity estimation utilizes set hashing to generate cross - counts as needed , instead of storing cross - counts for the most frequently co - occurring substrings .Multidimensional substring selectivity estimation using set hashing of cross - counts US 6738762 B1 .", "label": "", "metadata": {}, "score": "62.366444"}
{"text": "[ 6 - 2 - 3 .Re- arranging Trailing Strings during Index Updating When Part of the Text Is Changed ] .When part of the text is changed and trailing strings must be re - arranged during index updating , most trailing strings except those in the changed part ( at the changed position ) and those in the adjustment range are already registered in the index .", "label": "", "metadata": {}, "score": "62.371635"}
{"text": "That is , the character in position 4 ( in this example , this is the root node ) in the text tree has been changed to \" c \" .There is no change in the pointers between the dictionary tree and the text tree because they remain unchanged .", "label": "", "metadata": {}, "score": "62.37723"}
{"text": "The computer system of .claim 12 , further comprising a labeling engine to label the at least one base cluster .The computer system of .claim 12 , further comprising an evaluation engine to evaluate the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "62.505203"}
{"text": "The computer system of .claim 12 , further comprising a labeling engine to label the at least one base cluster .The computer system of .claim 12 , further comprising an evaluation engine to evaluate the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "62.505203"}
{"text": "All workloads consisted of 1000 queries , where four different workloads were used , each having a different selectivity .For positive queries , the following error measure was used : .E . abs .N . q .Q .", "label": "", "metadata": {}, "score": "62.51165"}
{"text": "54 is an example of data used in the conventional first method ( insert ) ; .FIG .55 is an example of data used in the conventional second method ; .FIG .56 is an example of a conventional binary tree ; .", "label": "", "metadata": {}, "score": "62.561283"}
{"text": "The system as recited in .claim 14 wherein said tree builder builds a substring table for said XPath expression tree .The system as recited in .claim 14 wherein said tree prober probes said substring table only for matching substrings that appear as a leaf substring in one of said XPath expressions .", "label": "", "metadata": {}, "score": "62.597984"}
{"text": "This invention eliminates the need to re - generate the whole dictionary data , reducing the update time .An invention according to claim 7 , if used , further increases the efficiency .This prevents the update time from being increased even when the size of the combined substrings is increased .", "label": "", "metadata": {}, "score": "62.60914"}
{"text": "This invention eliminates the need to re - generate the whole dictionary data , reducing the update time .An invention according to claim 7 , if used , further increases the efficiency .This prevents the update time from being increased even when the size of the combined substrings is increased .", "label": "", "metadata": {}, "score": "62.60914"}
{"text": "The system as recited in .claim 1 wherein said tree builder builds a substring table for said XPath expression tree .The system as recited in .claim 1 wherein said tree prober probes said substring table only for matching substrings that appear as a leaf substring in one of said XPath expressions .", "label": "", "metadata": {}, "score": "62.62278"}
{"text": "16 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval added ) ; .FIG .17 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval added ) ; .", "label": "", "metadata": {}, "score": "62.64032"}
{"text": "20 shows an example of a substring in the fifth embodiment of this invention ; .FIG .21 is a block diagram showing the configuration of the data processing system in the sixth embodiment of this invention ; .FIG .", "label": "", "metadata": {}, "score": "62.71225"}
{"text": "20 shows an example of a substring in the fifth embodiment of this invention ; .FIG .21 is a block diagram showing the configuration of the data processing system in the sixth embodiment of this invention ; .FIG .", "label": "", "metadata": {}, "score": "62.71225"}
{"text": "FIG .53 is a diagram showing the data and pointers of node d and its subordinate nodes in FIG .51 in the sixth embodiment of this invention ; .FIG .54 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "62.773525"}
{"text": "FIG .53 is a diagram showing the data and pointers of node d and its subordinate nodes in FIG .51 in the sixth embodiment of this invention ; .FIG .54 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "62.773525"}
{"text": "The primary mission of the system 700 is to disseminate XML documents to the plurality of subscribers based on the words of interest thus encapsulated .[ 0092 ] .The system 700 further includes a tree builder 730 .The tree builder 730 builds a document data tree for the XML documents and further builds an XPath expression tree ( and , in the illustrated embodiment , a related substring table ) based on substrings in the XPath expressions .", "label": "", "metadata": {}, "score": "62.818314"}
{"text": "24 is a flowchart showing the retrieval procedure used by the data processing system in the sixth embodiment .The interval retrieving means 33 calculates the range of the current node based on the interval lengths of the current node and the lower - level nodes ( step 242 ) , and compares the calculated range with the specified position .", "label": "", "metadata": {}, "score": "62.82206"}
{"text": "24 is a flowchart showing the retrieval procedure used by the data processing system in the sixth embodiment .The interval retrieving means 33 calculates the range of the current node based on the interval lengths of the current node and the lower - level nodes ( step 242 ) , and compares the calculated range with the specified position .", "label": "", "metadata": {}, "score": "62.82206"}
{"text": "Unlike a conventional system , the data processing system using the interval control method eliminates the need to move all the nodes corresponding to the intervals following the changed node , enhancing data processing efficiency .[ B-4 - 2 .Adding an Interval ] .", "label": "", "metadata": {}, "score": "62.88757"}
{"text": "One method prevents a binary tree from growing vertically to keep the time of one operation within a specified time ( e.g. , red - black tree ) .The other method reduces the total time of the operation ( that is , reduces the average time for one operation ) although it does not keep the time of one operation within a specified time ( e.g. , splay tree ) .", "label": "", "metadata": {}, "score": "62.968277"}
{"text": "One method prevents a binary tree from growing vertically to keep the time of one operation within a specified time ( e.g. , red - black tree ) .The other method reduces the total time of the operation ( that is , reduces the average time for one operation ) although it does not keep the time of one operation within a specified time ( e.g. , splay tree ) .", "label": "", "metadata": {}, "score": "62.968277"}
{"text": "Various types of operations are sometimes mixed ; for example , a character is deleted and then another character is added in an adjacent location .When a trailing string not requiring rearrangement is found , the check is re - started at the trailing string which begins at the rightmost ( end ) position of the change position immediately preceding ( the start position of ) the trailing string not requiring rearrangement .", "label": "", "metadata": {}, "score": "62.97589"}
{"text": "FIG .1 is a functional block diagram showing the configuration of the first embodiment of this invention ; .FIG .2 is a diagram showing the data structure used in the first embodiment of this invention ; .FIG .", "label": "", "metadata": {}, "score": "63.01789"}
{"text": "XPE Decompositions and Matchings .[ 0042 ] .This section describes the mechanisms employed in the XTrie index for decomposing XPEs into sequences of XML element names ( i.e. , substrings ) and defines several important concepts for matching based on substring trees that play a key role in the XTrie indexing structure and matching algorithms .", "label": "", "metadata": {}, "score": "63.05257"}
{"text": "It can be said as follows .[ 6 .Sixth Embodiment ] .This embodiment relates to a data processing system which enhances the efficiency of code string comparison which is required when the index is retrieved using a specified code string or when a trailing string is added to the index .", "label": "", "metadata": {}, "score": "63.053802"}
{"text": "Further , fast and accurate estimates for multidimensional string selectivity estimation may also help in refining queries in an online data analysis environment .In addition , the time needed to build the data structure should not be prohibitive so that periodic rebuilding is feasible .", "label": "", "metadata": {}, "score": "63.055725"}
{"text": "Information may be erased or deleted , not only by deleting the information from a storage area , but also by setting a flag indicating the erasure of the information .[ 1 .First Embodiment ] .The object of the first embodiment is to provide a data processing system which updates data for retrieval speedily .", "label": "", "metadata": {}, "score": "63.130367"}
{"text": "FIG .7 is a flowchart showing the procedure for changing a code string .The changing means 10 in FIG .1 changes a code string , more specifically , a substring to be changed ( step 71 ) .Then , it determines whether or not the length of the changed substring has been changed ( step 72 ) .", "label": "", "metadata": {}, "score": "63.147976"}
{"text": "FIG .7 is a flowchart showing the procedure for changing a code string .The changing means 10 in FIG .1 changes a code string , more specifically , a substring to be changed ( step 71 ) .Then , it determines whether or not the length of the changed substring has been changed ( step 72 ) .", "label": "", "metadata": {}, "score": "63.147976"}
{"text": "The system as recited in .claim 14 wherein said matches are ordered matches .The system as recited in .claim 14 wherein said tree builder comprises an event - based parsing interface .The system as recited in .claim 14 wherein said substrings are minimal decompositions of said XPath expressions .", "label": "", "metadata": {}, "score": "63.165638"}
{"text": "16 ! is set .In particular , a binary tree in which data storage areas for the nodes are connected by pointers does not require a large consecutive area and therefore uses memory efficiently .The ability to use a precision most suitable for each interval allows the user to use any type of interval data such as floating - point data .", "label": "", "metadata": {}, "score": "63.176678"}
{"text": "16 ! is set .In particular , a binary tree in which data storage areas for the nodes are connected by pointers does not require a large consecutive area and therefore uses memory efficiently .The ability to use a precision most suitable for each interval allows the user to use any type of interval data such as floating - point data .", "label": "", "metadata": {}, "score": "63.176678"}
{"text": "The resulting statistical measure or score is achieved by looking at , among other things , the historical information of the query terms typed by the user , the set of results returned , and the set of results that the user actually clicked through .", "label": "", "metadata": {}, "score": "63.193233"}
{"text": "The resulting statistical measure or score is achieved by looking at , among other things , the historical information of the query terms typed by the user , the set of results returned , and the set of results that the user actually clicked through .", "label": "", "metadata": {}, "score": "63.193233"}
{"text": "[ 0012 ] .In one embodiment of the present invention , the substrings are minimal decompositions of the XPath expressions .However , the substrings may be non - minimal decompositions of the XPath expressions .[ 0013 ] .The present invention introduces a method of searching an XML document that carries out steps analogous to those performed by the tree prober of this embodiment .", "label": "", "metadata": {}, "score": "63.195415"}
{"text": "A third , storage tier , may be a persistent storage medium or non - persistent storage medium .In some cases , one or more of these tiers may be collapsed into another , resulting in a two - tier architecture , or even a one - tier architecture .", "label": "", "metadata": {}, "score": "63.2929"}
{"text": "A third , storage tier , may be a persistent storage medium or non - persistent storage medium .In some cases , one or more of these tiers may be collapsed into another , resulting in a two - tier architecture , or even a one - tier architecture .", "label": "", "metadata": {}, "score": "63.2929"}
{"text": "Cross - counts are then approximated by estimating particular hash value set intersections .Other and further aspects of the present invention will become apparent during the course of the following discussion and by reference to the accompanying drawings .BRIEF DESCRIPTION OF THE DRAWINGS .", "label": "", "metadata": {}, "score": "63.340508"}
{"text": "( c ) Double rotation including two single rotations .Rebalancing is performed by sequentially applying a combination of these operations .These operations change partial interval lengths as follows : ( a ) Promote and demote , which do not change the structure of a binary tree , do not change the partial interval length .", "label": "", "metadata": {}, "score": "63.437588"}
{"text": "( c ) Double rotation including two single rotations .Rebalancing is performed by sequentially applying a combination of these operations .These operations change partial interval lengths as follows : ( a ) Promote and demote , which do not change the structure of a binary tree , do not change the partial interval length .", "label": "", "metadata": {}, "score": "63.437588"}
{"text": "18 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval added ) ; .FIG .19 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval added ) ; .", "label": "", "metadata": {}, "score": "63.46723"}
{"text": "46 .First , the system searches the key - candidate substrings , arranged in order of start positions , for those containing \" c \" that has been changed .In the right side of FIG .46 , they are \" 2 , ababcab , 1 \" to \" 7 , cab , 5 .", "label": "", "metadata": {}, "score": "63.530922"}
{"text": "The document disseminator 750 selectively disseminates the XML documents to the plurality of subsribers based on the matches .[ 0095 ] .Experimental Evaluation .[ 0096 ] .To determine the effectiveness of XTrie , its performance is compared to XFilter .", "label": "", "metadata": {}, "score": "63.535004"}
{"text": "The majority of existing publish / subscribe systems have typically relied on simple subscription mechanisms , such as keyword or \" bag of words \" matching , or simple comparison predicates on attribute values .For example , prior art systems such as \" Gryphon \" ( M. K. Aguilera , R. E. Strom , D. C. Sturman , M. Astley and T. D. Chandra , \" Matching Events in a Content - based Subscription System \" In Proc .", "label": "", "metadata": {}, "score": "63.551525"}
{"text": "FIG .63 is a diagram showing the binary tree , shown in FIG .60 , where node L has no right child and node X is the right child of node L , in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "63.555183"}
{"text": "FIG .63 is a diagram showing the binary tree , shown in FIG .60 , where node L has no right child and node X is the right child of node L , in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "63.555183"}
{"text": "FIG .66 shows how the binary tree looks like after node X has been deleted .This means that only the partial interval length of the root node need be adjusted during deletion , increasing the processing speed .Balanced Binary Tree !", "label": "", "metadata": {}, "score": "63.55648"}
{"text": "FIG .66 shows how the binary tree looks like after node X has been deleted .This means that only the partial interval length of the root node need be adjusted during deletion , increasing the processing speed .Balanced Binary Tree !", "label": "", "metadata": {}, "score": "63.55648"}
{"text": "And an invention according to a 20 .According to the data processing system of the 19 . sup.th illustrative implementation and the data processing method of the 20 . sup.th illustrative implementation , putting a plurality of changes to a specified range into one unit of adjustment work reduces the number of re - arrange operations of trailing strings into the dictionary data .", "label": "", "metadata": {}, "score": "63.588863"}
{"text": "Compare ( k+1)th and the following characters of \" s \" with the ( k+1)th and the following characters of the code string , and let the number of matching characters from the comparing start position be \" j \" .( k+j ) .", "label": "", "metadata": {}, "score": "63.6924"}
{"text": "9 is a diagram illustrating a merged cluster map , according to an example embodiment .FIG .10 is a block diagram illustrating an application server , according to an example embodiment .FIG .11 is a flowchart illustrating a method used to implement a demand data engine , according to an example embodiment .", "label": "", "metadata": {}, "score": "63.69813"}
{"text": "9 is a diagram illustrating a merged cluster map , according to an example embodiment .FIG .10 is a block diagram illustrating an application server , according to an example embodiment .FIG .11 is a flowchart illustrating a method used to implement a demand data engine , according to an example embodiment .", "label": "", "metadata": {}, "score": "63.69813"}
{"text": "Once transmitted , an operation 1405 is executed that receives a merged base cluster score from , for example , the execution of operation 205 .Next , an operation 1403 is executed that acts to compact the data structure as , for example , illustrated in .", "label": "", "metadata": {}, "score": "63.71305"}
{"text": "Once transmitted , an operation 1405 is executed that receives a merged base cluster score from , for example , the execution of operation 205 .Next , an operation 1403 is executed that acts to compact the data structure as , for example , illustrated in .", "label": "", "metadata": {}, "score": "63.71305"}
{"text": "Moreover , this node 14 labeled as 510 is connected additionally to a node 16 labeled as 513 via an edge labeled \" Opener . \"Further , the node 13 labeled as 508 is connected to a node 17 labeled as 509 by an edge labeled \" Lighter .", "label": "", "metadata": {}, "score": "63.758907"}
{"text": "Moreover , this node 14 labeled as 510 is connected additionally to a node 16 labeled as 513 via an edge labeled \" Opener . \"Further , the node 13 labeled as 508 is connected to a node 17 labeled as 509 by an edge labeled \" Lighter .", "label": "", "metadata": {}, "score": "63.758907"}
{"text": "Seller Factor .In some embodiments , a factor that takes into account the overlap of sellers between clusters may enforce the sanctity or legitimacy of the merge .The use of seller information to influence the clustering process is based upon the assumption that sellers who sell similar items tend to appear in related clusters .", "label": "", "metadata": {}, "score": "63.760918"}
{"text": "Seller Factor .In some embodiments , a factor that takes into account the overlap of sellers between clusters may enforce the sanctity or legitimacy of the merge .The use of seller information to influence the clustering process is based upon the assumption that sellers who sell similar items tend to appear in related clusters .", "label": "", "metadata": {}, "score": "63.760918"}
{"text": "So , single rotation is performed once to change node b to red , and node e to black .FIG .72 shows how the binary tree looks like after single rotation has been performed and node colors have been changed .", "label": "", "metadata": {}, "score": "63.763264"}
{"text": "So , single rotation is performed once to change node b to red , and node e to black .FIG .72 shows how the binary tree looks like after single rotation has been performed and node colors have been changed .", "label": "", "metadata": {}, "score": "63.763264"}
{"text": "( Reference : Robert Endre Tarjan . \" 4.2 Balanced binary trees ( pp .48 - 53 ) \" in Data Structures and Network Algorithms ) .Operations for rebalancing after node insertion or deletion are : .( a ) Promote , demote .", "label": "", "metadata": {}, "score": "63.840187"}
{"text": "( Reference : Robert Endre Tarjan . \" 4.2 Balanced binary trees ( pp .48 - 53 ) \" in Data Structures and Network Algorithms ) .Operations for rebalancing after node insertion or deletion are : .( a ) Promote , demote .", "label": "", "metadata": {}, "score": "63.840187"}
{"text": "These schemas may be normalized using certain normalization algorithms so as to avoid abnormalities such as non - additive joins and other problems .Additionally , these normalization algorithms may include Boyce - Codd Normal Form or some other normalization or optimization algorithm known in the art .", "label": "", "metadata": {}, "score": "63.84469"}
{"text": "These schemas may be normalized using certain normalization algorithms so as to avoid abnormalities such as non - additive joins and other problems .Additionally , these normalization algorithms may include Boyce - Codd Normal Form or some other normalization or optimization algorithm known in the art .", "label": "", "metadata": {}, "score": "63.84469"}
{"text": "Adjustment Procedure Involved in Changing the Text ] .In the data structure in this embodiment , a key - candidate substring stored in the index is created by referring to a portion of the text .Therefore , when one character is added to the end of the text , that character is added to the end of each key .", "label": "", "metadata": {}, "score": "63.84909"}
{"text": "1 does this processing .The following table shows how the text data 6 and the dictionary data 2 have been changed : .[ TABLE 5 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) a b a b b a c a b . fwdarw .", "label": "", "metadata": {}, "score": "63.856308"}
{"text": "32(D ) is a diagram showing a \" change position \" when a character is added at the end position in the text in the third embodiment of this invention ; .FIG .33 is a functional block diagram showing the configuration of the fourth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "63.88637"}
{"text": "The code of a character string may be represented in characters or words .Data may be stored for any period of time ; it may be volatile after a specified time .Data not to be changed , for example dictionary data , may be stored in ROM .", "label": "", "metadata": {}, "score": "63.93727"}
{"text": "The code of a character string may be represented in characters or words .Data may be stored for any period of time ; it may be volatile after a specified time .Data not to be changed , for example dictionary data , may be stored in ROM .", "label": "", "metadata": {}, "score": "63.93727"}
{"text": "The code of a character string may be represented in characters or words .Data may be stored for any period of time ; it may be volatile after a specified time .Data not to be changed , for example dictionary data , may be stored in ROM .", "label": "", "metadata": {}, "score": "63.93727"}
{"text": "9 can be shown as various numerical scores .For example , the clusters in .FIG .9 may be merged into five clusters as given below : .Multi - Factor Clustering .In some cases , the clustering search results with the standard STC algorithm do not take into account other factors that may influence the quality of clusters .", "label": "", "metadata": {}, "score": "63.95708"}
{"text": "9 can be shown as various numerical scores .For example , the clusters in .FIG .9 may be merged into five clusters as given below : .Multi - Factor Clustering .In some cases , the clustering search results with the standard STC algorithm do not take into account other factors that may influence the quality of clusters .", "label": "", "metadata": {}, "score": "63.95708"}
{"text": "Further , an evaluation engine 1008 may be implemented to evaluate the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "64.015045"}
{"text": "Further , an evaluation engine 1008 may be implemented to evaluate the merged cluster to determine a coverage value for the merged cluster , and a second overlap value relating to the at least one documents contained within the merged cluster .", "label": "", "metadata": {}, "score": "64.015045"}
{"text": "Then , the current node is moved toward the root ( step 312 ) until it becomes the root ( step 314 ) while increasing or decreasing the partial interval length of each current node by a specified change amount .That is , even when the length of an interval is changed in the sixth embodiment , only the nodes from that node to the root need be changed .", "label": "", "metadata": {}, "score": "64.03587"}
{"text": "Then , the current node is moved toward the root ( step 312 ) until it becomes the root ( step 314 ) while increasing or decreasing the partial interval length of each current node by a specified change amount .That is , even when the length of an interval is changed in the sixth embodiment , only the nodes from that node to the root need be changed .", "label": "", "metadata": {}, "score": "64.03587"}
{"text": "And an invention according to the 44 .According to the data retrieval system of the 43 . sup.rd illustrative implementation and the data retrieval method of the 44 . sup.th illustrative implementation , a simply - structured data retrieval system and the data retrieval method , which does not generate text , can be configured .", "label": "", "metadata": {}, "score": "64.11985"}
{"text": "Further , certain data structures may result in more accurate search results being produced for a given query .BRIEF DESCRIPTION OF THE DRAWINGS .Some embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings in which : .", "label": "", "metadata": {}, "score": "64.18239"}
{"text": "Further , certain data structures may result in more accurate search results being produced for a given query .BRIEF DESCRIPTION OF THE DRAWINGS .Some embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings in which : .", "label": "", "metadata": {}, "score": "64.18239"}
{"text": "49 is an example of table ( dictionary ) containing positions and substring identifiers for the code string \" abbabb$ \" .In this figure , the symbol $ is a dummy code appended at the end of the code string to identify the position .", "label": "", "metadata": {}, "score": "64.190445"}
{"text": "Penalizing these items for not in the right order would affect the recall of the algorithm .On the other hand , if we ignore the order of the words when the data is input to the algorithm , a large number of low quality clusters would be output .", "label": "", "metadata": {}, "score": "64.20986"}
{"text": "Penalizing these items for not in the right order would affect the recall of the algorithm .On the other hand , if we ignore the order of the words when the data is input to the algorithm , a large number of low quality clusters would be output .", "label": "", "metadata": {}, "score": "64.20986"}
{"text": "0099 ] . XPathExpressions .[ 0100 ] .An XPath expression generator was implemented that takes a DTD as input and creates a set of valid XPath expressions ( with no duplicates ) based on the following set of six input parameters .", "label": "", "metadata": {}, "score": "64.24498"}
{"text": "The method as recited in . claim 8 wherein said instances are ordered matches .The method as recited in . claim 8 wherein said parsing is carried out with an event - based parsing interface .The method as recited in . claim 8 wherein said substrings are minimal decompositions of said XPath expressions .", "label": "", "metadata": {}, "score": "64.25716"}
{"text": "Additionally illustrated is a node 19 referenced as 908 that roughly corresponds to nodes 712 and 809 .Associated with this node 19 is the substring \" Cap \" which may appear in , for example , document 0 .Further illustrated is a node 14 referenced as 909 and node 15 referenced as 910 wherein this node 14and 15 are connected to a bidirectional edge .", "label": "", "metadata": {}, "score": "64.266075"}
{"text": "Additionally illustrated is a node 19 referenced as 908 that roughly corresponds to nodes 712 and 809 .Associated with this node 19 is the substring \" Cap \" which may appear in , for example , document 0 .Further illustrated is a node 14 referenced as 909 and node 15 referenced as 910 wherein this node 14and 15 are connected to a bidirectional edge .", "label": "", "metadata": {}, "score": "64.266075"}
{"text": "Since rope nodes can be shared by different ropes , which can be concurrently copied , updated , or destroyed by different threads , reference counts must be updated atomically .This is the only explicit synchronization performed by the implementation , since the reference count is the only part of a potentially shared data structure that is updated .", "label": "", "metadata": {}, "score": "64.30747"}
{"text": "Since rope nodes can be shared by different ropes , which can be concurrently copied , updated , or destroyed by different threads , reference counts must be updated atomically .This is the only explicit synchronization performed by the implementation , since the reference count is the only part of a potentially shared data structure that is updated .", "label": "", "metadata": {}, "score": "64.30747"}
{"text": "[ 6 - 2 . Operation And Effects of the Sixth Embodiment ] .The sixth embodiment having the configuration described above performs operation as follows .[ 6 - 2 - 1 .Increasing the Efficiency in Comparing Keys ( Code Strings ) at Index Retrieval Time ] .", "label": "", "metadata": {}, "score": "64.30881"}
{"text": "[ 0108 ] .Experimental Results .[0109 ] .[ 0110 ] .[ 0110]FIG .8A compares the scalability of the algorithms as a function of P , the size of the set of indexed XPEs .The results show that the filtering time increases almost linearly with P , with Lazy XTrie being the fastest algorithm , which outperforms XFilter - LB by a factor of between 2 and 4 .", "label": "", "metadata": {}, "score": "64.32767"}
{"text": "This method is advantageous because the simple - to - use retrieval procedure ensures retrieval efficiency .Referring to FIG .40 , there is shown an implementation of the unit function ( x3 ) mentioned above .In FIG .40 , assume that the user wants to retrieve the pattern \" bac \" from the index .", "label": "", "metadata": {}, "score": "64.33385"}
{"text": "In FIG .67 , a black node is represented by a solid line , whereas a red node is represented by a dashed line .Information on a node in this tree contains a one - bit field where the color for the node is stored .", "label": "", "metadata": {}, "score": "64.36239"}
{"text": "In FIG .67 , a black node is represented by a solid line , whereas a red node is represented by a dashed line .Information on a node in this tree contains a one - bit field where the color for the node is stored .", "label": "", "metadata": {}, "score": "64.36239"}
{"text": "49 is a diagram showing an example of binary tree in the sixth embodiment of this invention ; .FIG .50 is a conceptual diagram showing the data format for each node in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "64.36614"}
{"text": "49 is a diagram showing an example of binary tree in the sixth embodiment of this invention ; .FIG .50 is a conceptual diagram showing the data format for each node in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "64.36614"}
{"text": "Ninth embodiment ] .That is , this embodiment explains that the index and text functions shown in the seventh embodiment may be implemented and executed in the configuration shown in FIG .42 in the eighth embodiment .[ b 9 - 1 .", "label": "", "metadata": {}, "score": "64.441154"}
{"text": "This call is provided to an item listing database 112 .Once operation 401 is executed , and the call made to the item listing database 112 , a further operation 402 is executed .This operation 402 transmits the search results as a form of item data to the previously illustrated STC algorithm , as embodied in operation 204 .", "label": "", "metadata": {}, "score": "64.45885"}
{"text": "This call is provided to an item listing database 112 .Once operation 401 is executed , and the call made to the item listing database 112 , a further operation 402 is executed .This operation 402 transmits the search results as a form of item data to the previously illustrated STC algorithm , as embodied in operation 204 .", "label": "", "metadata": {}, "score": "64.45885"}
{"text": "60 , where node X may be added as the right child of node L. .In addition , when node addition and associated partial interval length adjustment are involved , processing may be performed as follows .First , a node corresponding to the new interval is added using some method , with the net interval length of the node being 0 .", "label": "", "metadata": {}, "score": "64.5207"}
{"text": "60 , where node X may be added as the right child of node L. .In addition , when node addition and associated partial interval length adjustment are involved , processing may be performed as follows .First , a node corresponding to the new interval is added using some method , with the net interval length of the node being 0 .", "label": "", "metadata": {}, "score": "64.5207"}
{"text": "claim 4 wherein in performing step c ) generating a signature length in the range of 10 to 100 .The method as defined in .claim 4 wherein the data sets are highly correlated and a signature length of approximately 20 is used .", "label": "", "metadata": {}, "score": "64.564674"}
{"text": "Additionally , a calculator 1012 may be implemented to calculate a relevance score using the demand factor , the relevance score calculated , in part , based on a comparison of a similarity of a demand category histogram , and a supply category histogram .", "label": "", "metadata": {}, "score": "64.60858"}
{"text": "Additionally , a calculator 1012 may be implemented to calculate a relevance score using the demand factor , the relevance score calculated , in part , based on a comparison of a similarity of a demand category histogram , and a supply category histogram .", "label": "", "metadata": {}, "score": "64.60858"}
{"text": "Assume that the forth character \" b \" in the text \" ababcab \" is changed to the character \" c \" ( The changing means 11 shown in FIG .1 changes characters ) .[ TABLE 3 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) a b a b c a b . fwdarw .", "label": "", "metadata": {}, "score": "64.626465"}
{"text": "The system as recited in .claim 1 wherein said matches are ordered matches .The system as recited in .claim 1 wherein said tree builder comprises an event - based parsing interface .The system as recited in .claim 1 wherein said substrings are minimal decompositions of said XPath expressions .", "label": "", "metadata": {}, "score": "64.642075"}
{"text": "Information may be erased or deleted , not only by deleting the information from a storage area , but also by setting a flag indicating the erasure of the information .FIRST EMBODIMENT .It is an object of the first embodiment to provide a data retrieval system and a data processing method which update data speedily .", "label": "", "metadata": {}, "score": "64.70816"}
{"text": "Information may be erased or deleted , not only by deleting the information from a storage area , but also by setting a flag indicating the erasure of the information .FIRST EMBODIMENT .It is an object of the first embodiment to provide a data retrieval system and a data processing method which update data speedily .", "label": "", "metadata": {}, "score": "64.70816"}
{"text": "31 is a flowchart showing a procedure for changing an interval length in the sixth embodiment of this invention ; .FIG .32 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .", "label": "", "metadata": {}, "score": "64.75741"}
{"text": "31 is a flowchart showing a procedure for changing an interval length in the sixth embodiment of this invention ; .FIG .32 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .", "label": "", "metadata": {}, "score": "64.75741"}
{"text": "66 is a diagram showing the binary tree from which node X has been deleted in the sixth embodiment of this invention ; .FIG .67 is a diagram showing a sample balanced binary tree in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "64.78311"}
{"text": "66 is a diagram showing the binary tree from which node X has been deleted in the sixth embodiment of this invention ; .FIG .67 is a diagram showing a sample balanced binary tree in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "64.78311"}
{"text": "NBids : number of bids placed immediately after searching the phrase P ; .No . of View Item Counts : Number of items viewed by the user immediately after searching the phrase P ; .Category histogram of view item counts : Histogram of view item counts grouped by the category for the phrase P. Relevancy Score .", "label": "", "metadata": {}, "score": "64.810745"}
{"text": "NBids : number of bids placed immediately after searching the phrase P ; .No . of View Item Counts : Number of items viewed by the user immediately after searching the phrase P ; .Category histogram of view item counts : Histogram of view item counts grouped by the category for the phrase P. Relevancy Score .", "label": "", "metadata": {}, "score": "64.810745"}
{"text": "Illustrated is a node 21 referenced as 901 that is connected bi - directionally to a node 22 labeled as 902 .This node 21 references the substring \" Lighter \" and the document that contains the substring \" Lighter \" which , in this case , is document 2 .", "label": "", "metadata": {}, "score": "64.87948"}
{"text": "Illustrated is a node 21 referenced as 901 that is connected bi - directionally to a node 22 labeled as 902 .This node 21 references the substring \" Lighter \" and the document that contains the substring \" Lighter \" which , in this case , is document 2 .", "label": "", "metadata": {}, "score": "64.87948"}
{"text": "For example , a computer serves as a means when executing an instruction , but serves as another means when executing another instruction .In addition , one means may be implemented by one instruction in some cases , but by a plurality of instructions in some other cases .", "label": "", "metadata": {}, "score": "64.8962"}
{"text": "Also , a pointer from a node added to the dictionary tree to a node added to the text tree is added .The \" interval control method \" will be described later in detail .FIG .4 shows the dictionary tree and the text tree to which the character string \" ba \" has been added .", "label": "", "metadata": {}, "score": "64.93556"}
{"text": "49 ) with the binary tree after splaying ( FIG .56 ) indicates that the length of a path from each node to the root has been changed as shown below .TABLE 2______________________________________Node Before splaying After splaying______________________________________b 6 3c 5 4d 4 2e 3 3f 2 1 g 1 2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "65.047485"}
{"text": "49 ) with the binary tree after splaying ( FIG .56 ) indicates that the length of a path from each node to the root has been changed as shown below .TABLE 2______________________________________Node Before splaying After splaying______________________________________b 6 3c 5 4d 4 2e 3 3f 2 1 g 1 2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "65.047485"}
{"text": "Notice that the embodiment described below is implemented on a computer and that each function of the embodiment is implemented by a procedure ( program ) controlling this computer .Each \" means \" mentioned in this specification refers to a conceptual equivalent of each function of this embodiment ; that is , there is not always a one - to - one correspondence between means and particular pieces of hardware or software routines .", "label": "", "metadata": {}, "score": "65.050186"}
{"text": "EIGHTH EMBODIMENT .It is possible to represent a code string , such as text consisting of a plurality of lines , with a single binary tree .In this case , the maximum number of characters of a line is fixed to a large number , n , and blanks are padded in the positions containing no character .", "label": "", "metadata": {}, "score": "65.0737"}
{"text": "EIGHTH EMBODIMENT .It is possible to represent a code string , such as text consisting of a plurality of lines , with a single binary tree .In this case , the maximum number of characters of a line is fixed to a large number , n , and blanks are padded in the positions containing no character .", "label": "", "metadata": {}, "score": "65.0737"}
{"text": "Ignoring this factor ( e.g. , incorrect lists / mislabels ) , if one were to look at the distribution of items within a cluster across categories , it will give one an understanding of how well the items are clustered .", "label": "", "metadata": {}, "score": "65.09799"}
{"text": "Ignoring this factor ( e.g. , incorrect lists / mislabels ) , if one were to look at the distribution of items within a cluster across categories , it will give one an understanding of how well the items are clustered .", "label": "", "metadata": {}, "score": "65.09799"}
{"text": "According to the invention of the 82 . sup.nd illustrative implementation , a data retrieval method , which can easily find the number of substrings satisfying the retrieval condition , may be built .An invention according to an 83 . sup.rd illustrative implementation is a data processing method of the 46 . sup.th and 52 .", "label": "", "metadata": {}, "score": "65.13392"}
{"text": "57 is an example of data used in the conventional third method ; and .31 . . .Binary tree .32 . . .Binary tree generating means .33 . . .Interval retrieving means .34 . . .", "label": "", "metadata": {}, "score": "65.13995"}
{"text": "And an invention according to an eighth illustrative implementation is a data processing system of the third illustrative implementation wherein the length of a key candidate substring constituting the dictionary data is not limited .According to the invention of the seventh and eighth illustrative implementations , not limiting the length of a key - candidate substring eliminates the need to later check the subsequent substring in the text and enables a substring of any length to be retrieved by simply retrieving from the index directly .", "label": "", "metadata": {}, "score": "65.16372"}
{"text": "These various components may be implemented by a computer system on an as - needed basis .These components may be linked to other components via various APIs , and then compiled into one complete server , client , and/or peer software application .", "label": "", "metadata": {}, "score": "65.175674"}
{"text": "These various components may be implemented by a computer system on an as - needed basis .These components may be linked to other components via various APIs , and then compiled into one complete server , client , and/or peer software application .", "label": "", "metadata": {}, "score": "65.175674"}
{"text": "72 is a diagram showing the binary tree in which single rotation has been performed and node colors have been changed in the sixth embodiment of this invention ; .FIG .73 shows a binary tree in the seventh embodiment of this invention ; .", "label": "", "metadata": {}, "score": "65.20111"}
{"text": "72 is a diagram showing the binary tree in which single rotation has been performed and node colors have been changed in the sixth embodiment of this invention ; .FIG .73 shows a binary tree in the seventh embodiment of this invention ; .", "label": "", "metadata": {}, "score": "65.20111"}
{"text": "The Abstract of the Disclosure is provided to comply with 37 C.F.R. \u00a7 1.72(b ) , requiring an abstract that will allow the reader to quickly ascertain the nature of the technical disclosure .It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims .", "label": "", "metadata": {}, "score": "65.25255"}
{"text": "The Abstract of the Disclosure is provided to comply with 37 C.F.R. \u00a7 1.72(b ) , requiring an abstract that will allow the reader to quickly ascertain the nature of the technical disclosure .It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims .", "label": "", "metadata": {}, "score": "65.25255"}
{"text": "Next , an operation 1409 is executed that receives the coverage and overlap rule set , wherein this information is received from , for example , the execution of operation 206 .Then , a decisional operation 1410 is executed that determines whether the coverage and overlap is sufficient for the purposes of facilitating , for example , broad coverage with minimal overlap .", "label": "", "metadata": {}, "score": "65.27109"}
{"text": "Next , an operation 1409 is executed that receives the coverage and overlap rule set , wherein this information is received from , for example , the execution of operation 206 .Then , a decisional operation 1410 is executed that determines whether the coverage and overlap is sufficient for the purposes of facilitating , for example , broad coverage with minimal overlap .", "label": "", "metadata": {}, "score": "65.27109"}
{"text": "53 shows how the pointers in the data items at node d and lower - level nodes in FIG .51 , which have been restructured as shown in FIG .52 , are linked .In this figure , while node B , which is the left child of node d , is not changed , node a , which is the right child of node d , and the lower - level nodes have been changed .", "label": "", "metadata": {}, "score": "65.29508"}
{"text": "53 shows how the pointers in the data items at node d and lower - level nodes in FIG .51 , which have been restructured as shown in FIG .52 , are linked .In this figure , while node B , which is the left child of node d , is not changed , node a , which is the right child of node d , and the lower - level nodes have been changed .", "label": "", "metadata": {}, "score": "65.29508"}
{"text": "In addition , dictionary data requires less space a table .An invention according to claim 4 is a data retrieval system as claimed in claim 3 , wherein each label is one unit code in the code string .According to the invention as claimed in claim 4 , a label is always one unit code in the code string .", "label": "", "metadata": {}, "score": "65.2962"}
{"text": "In addition , dictionary data requires less space a table .An invention according to claim 4 is a data retrieval system as claimed in claim 3 , wherein each label is one unit code in the code string .According to the invention as claimed in claim 4 , a label is always one unit code in the code string .", "label": "", "metadata": {}, "score": "65.2962"}
{"text": "28 , they are combined into one item consisting of the top part and the bottom part .This configuration , which eliminates the need to reference the nodes in both trees , does not require pointers , resulting in a significant reduction in the amount of required storage .", "label": "", "metadata": {}, "score": "65.35794"}
{"text": "12 is a flowchart illustrating a method used to implement an operation that computes a base cluster score using the merged threshold data , according to an example embodiment .FIG .13 is a flowchart illustrating a method used to implement an operation that provides merged threshold data , according to an example embodiment .", "label": "", "metadata": {}, "score": "65.437256"}
{"text": "12 is a flowchart illustrating a method used to implement an operation that computes a base cluster score using the merged threshold data , according to an example embodiment .FIG .13 is a flowchart illustrating a method used to implement an operation that provides merged threshold data , according to an example embodiment .", "label": "", "metadata": {}, "score": "65.437256"}
{"text": "claim 1 , wherein the item data includes at least one of an item title , an item category , or seller information .The method of .claim 1 , wherein the item data is part of a plurality of merged clusters organized into a hierarchy of merged clusters .", "label": "", "metadata": {}, "score": "65.47983"}
{"text": "merging the compact cluster representation to generate a merged cluster , the merging based upon a first overlap value applied to the at least one document with common item data , the merged cluster being based at least in part on the demand factor .", "label": "", "metadata": {}, "score": "65.55034"}
{"text": "merging the compact cluster representation to generate a merged cluster , the merging based upon a first overlap value applied to the at least one document with common item data , the merged cluster being based at least in part on the demand factor .", "label": "", "metadata": {}, "score": "65.55034"}
{"text": "merging the compact cluster representation to generate a merged cluster , the merging based upon a first overlap value applied to the at least one document with common item data , the merged cluster being based at least in part on the demand factor .", "label": "", "metadata": {}, "score": "65.55034"}
{"text": "Presenting Clustered Search Results .FIG .16 is a flowchart illustrating an example method used to implement or execute operation 208 .Illustrated is an operation 1601 that receives phrase data .Next , an operation 1602 is executed that provides a Graphical User Interface ( GUI ) for display in user interaction .", "label": "", "metadata": {}, "score": "65.55176"}
{"text": "Presenting Clustered Search Results .FIG .16 is a flowchart illustrating an example method used to implement or execute operation 208 .Illustrated is an operation 1601 that receives phrase data .Next , an operation 1602 is executed that provides a Graphical User Interface ( GUI ) for display in user interaction .", "label": "", "metadata": {}, "score": "65.55176"}
{"text": "FIG .57 is a diagram showing a part of the binary tree before an interval is added through splaying in the sixth embodiment of this invention ; .FIG .58 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "65.61171"}
{"text": "FIG .57 is a diagram showing a part of the binary tree before an interval is added through splaying in the sixth embodiment of this invention ; .FIG .58 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "65.61171"}
{"text": "20 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval deleted ) ; .FIG .21 is an example of a binary tree in a data processing system using the \" interval control method \" ( interval deleted ) ; .", "label": "", "metadata": {}, "score": "65.73062"}
{"text": "Component Design .Some example embodiments may include the above - illustrated tiers , and their processes or operations , as being written as one or more software components .Common to many of these components is the ability to generate , use , and manipulate data .", "label": "", "metadata": {}, "score": "65.78476"}
{"text": "Component Design .Some example embodiments may include the above - illustrated tiers , and their processes or operations , as being written as one or more software components .Common to many of these components is the ability to generate , use , and manipulate data .", "label": "", "metadata": {}, "score": "65.78476"}
{"text": "It should be noted that the implementation of each function is not limited to the method described above .The seventh embodiment , which is based on a higher concept of these functions , may be implemented using the data structure shown in FIG .", "label": "", "metadata": {}, "score": "65.82924"}
{"text": "Intuitively , presume that \" darts \" are thrown randomly at a universe U. In accordance with the present invention , therefore , signature vectors S ij are created for each pair of sets , where these signatures can then be operated on directly to estimate the set resemblance between any pair of sets .", "label": "", "metadata": {}, "score": "65.92234"}
{"text": "In the seventh embodiment , the first binary tree representing the sequence of lines and each of the second binary trees representing the contents of each line are created separately .Therefore , when either the sequence of lines or the content of each line is changed , there is no need for changing the other type of binary tree .", "label": "", "metadata": {}, "score": "66.01802"}
{"text": "In the seventh embodiment , the first binary tree representing the sequence of lines and each of the second binary trees representing the contents of each line are created separately .Therefore , when either the sequence of lines or the content of each line is changed , there is no need for changing the other type of binary tree .", "label": "", "metadata": {}, "score": "66.01802"}
{"text": "Since even non - destructive updates copy only portions of a rope , and since many rope clients will use them purely as immutable strings , this is often not a serious loss .But it may be for some applications .", "label": "", "metadata": {}, "score": "66.052765"}
{"text": "Since even non - destructive updates copy only portions of a rope , and since many rope clients will use them purely as immutable strings , this is often not a serious loss .But it may be for some applications .", "label": "", "metadata": {}, "score": "66.052765"}
{"text": "For example , the OS need not always be used , and any programming language may be used .An interpreter ( serially interpretive execution ) such as BASIC may be used to code a program .The program may be stored on any storage device .", "label": "", "metadata": {}, "score": "66.07117"}
{"text": "For example , the OS need not always be used , and any programming language may be used .An interpreter ( serially interpretive execution ) such as BASIC may be used to code a program .The program may be stored on any storage device .", "label": "", "metadata": {}, "score": "66.07117"}
{"text": "For example , the OS need not always be used , and any programming language may be used .An interpreter ( serially interpretive execution ) such as BASIC may be used to code a program .The program may be stored on any storage device .", "label": "", "metadata": {}, "score": "66.07117"}
{"text": "6 is an example of a binary tree in a data processing system using the \" interval control method \" ; .FIG .7 is a diagram illustrating a binary tree in a data processing system using the \" interval control method \" ; .", "label": "", "metadata": {}, "score": "66.0791"}
{"text": "58 shows a data structure represented in the fourth method .The fourth method eliminates the need for transferring data in memory when adding , deleting , dividing , or merging one or more intervals .However , to locate a particular position , this method still requires us to add up the lengths of intervals .", "label": "", "metadata": {}, "score": "66.09443"}
{"text": "52 shows an example of a directed acyclic word graph .However , when the code string s is updated in a traditional data structure , the time required for updating retrieval data increases in proportion to the length of the code string s .", "label": "", "metadata": {}, "score": "66.150024"}
{"text": "6 is a flowchart showing the procedure for retrieving data in the first embodiment of this invention ; .FIG .7 is a flowchart showing the procedure for changing a code string used in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "66.18303"}
{"text": "6 is a flowchart showing the procedure for retrieving data in the first embodiment of this invention ; .FIG .7 is a flowchart showing the procedure for changing a code string used in the first embodiment of this invention ; .", "label": "", "metadata": {}, "score": "66.18303"}
{"text": "A retriever a trailing string whose leading string is a key string or a part of the key string , based on the dictionary data .A remover removes duplicate trailing strings .When a changer changes the code string , an updater updates dictionary data associated with the substring based on the contents of the change .", "label": "", "metadata": {}, "score": "66.1857"}
{"text": "A retriever a trailing string whose leading string is a key string or a part of the key string , based on the dictionary data .A remover removes duplicate trailing strings .When a changer changes the code string , an updater updates dictionary data associated with the substring based on the contents of the change .", "label": "", "metadata": {}, "score": "66.1857"}
{"text": "Some embodiments may utilize the Open Systems Interconnection ( OSI ) model , or the Transmission Control Protocol / Internet Protocol ( TCP / IP ) protocol stack model for defining the protocols used by a network to transmit data .In the case of software having a three tier architecture , the various tiers ( e.g. , the interface , logic , and storage tiers ) reside on the application layer of the TCP / IP protocol stack .", "label": "", "metadata": {}, "score": "66.21414"}
{"text": "Some embodiments may utilize the Open Systems Interconnection ( OSI ) model , or the Transmission Control Protocol / Internet Protocol ( TCP / IP ) protocol stack model for defining the protocols used by a network to transmit data .In the case of software having a three tier architecture , the various tiers ( e.g. , the interface , logic , and storage tiers ) reside on the application layer of the TCP / IP protocol stack .", "label": "", "metadata": {}, "score": "66.21414"}
{"text": "Pr . abc .Pr . ab .x .Pr . bc .Pr .b .The utilization of the set hashing technique with larger data sets has been investigated and found to be reliable for both positive queries ( substring queries existing in the data set ) and negative queries ( substring queries not present in the data set ) .", "label": "", "metadata": {}, "score": "66.24579"}
{"text": "In addition , this invention saves storage space significantly because character strings need only be stored in at least one of the dictionary data and text data .Therefore , when one or more characters are added to the text , this invention significantly reduces the time needed to update the dictionary .", "label": "", "metadata": {}, "score": "66.27804"}
{"text": "As a result , the text data 6 and the dictionary data 2 are changed as follows : .[ TABLE 4 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) a b a b c a b . fwdarw .", "label": "", "metadata": {}, "score": "66.28422"}
{"text": "Once operation 204 successfully completes its execution , a further operation 207 is executed that labels the various clusters generated through the execution of the operation 204 .Then , in some cases , an operation 208 is executed that , in effect , clusters the search results .", "label": "", "metadata": {}, "score": "66.30821"}
{"text": "Once operation 204 successfully completes its execution , a further operation 207 is executed that labels the various clusters generated through the execution of the operation 204 .Then , in some cases , an operation 208 is executed that , in effect , clusters the search results .", "label": "", "metadata": {}, "score": "66.30821"}
{"text": "In particular , the XPath language ( \" XML Path Language ( Xpath ) 1.0 .\" [ 0005 ] .Given the increased complexity of structural , XPath - based data filters , effectively identifying the subscriptions that match an incoming XML document poses a difficult and important research challenge .", "label": "", "metadata": {}, "score": "66.3929"}
{"text": "Note that , in FIG .72 where the binary tree after node insertion and structure adjustment is shown , the net interval lengths of nodes e and b remain the same as before , as described below ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Formula 52 !", "label": "", "metadata": {}, "score": "66.41249"}
{"text": "Note that , in FIG .72 where the binary tree after node insertion and structure adjustment is shown , the net interval lengths of nodes e and b remain the same as before , as described below ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Formula 52 !", "label": "", "metadata": {}, "score": "66.41249"}
{"text": "For example , if the last character \" c \" of the code string s is deleted in FIG .51 , three paths ( c ) are deleted and the labels on two paths ( abc ) are changed to ( ab ) .", "label": "", "metadata": {}, "score": "66.53232"}
{"text": "FIG .23 explains the binary tree in the sixth embodiment of this invention ; .FIG .24 is a flowchart showing the procedure for retrieving data in the sixth embodiment of this invention ; .FIG .25 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) ; .", "label": "", "metadata": {}, "score": "66.58644"}
{"text": "FIG .23 explains the binary tree in the sixth embodiment of this invention ; .FIG .24 is a flowchart showing the procedure for retrieving data in the sixth embodiment of this invention ; .FIG .25 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) ; .", "label": "", "metadata": {}, "score": "66.58644"}
{"text": "10 ( a ) , the average error using set hashing in the EVENT data set was smaller by a factor of four when compared to the various prior art methods .It is to be understood that set hashing as used in accordance with the present invention can be generalized to perform selectivity estimations for dimensions higher than the two - dimensional examples discussed above .", "label": "", "metadata": {}, "score": "66.59138"}
{"text": "FIG .19 shows the binary tree 31 to which a new node has been added at the position . beta . shown in FIG .17 .[ B-4 - 3 .Deleting an Interval ] .When deleting an interval , the deleting means 43 deletes from the binary tree 31 the node corresponding to the interval to be deleted , adjusts the connection among the nodes , and adjusts the partial interval lengths .", "label": "", "metadata": {}, "score": "66.61142"}
{"text": "It is an object of this invention to provide an efficient data processing system , a data retrieval system , a data processing method and a data retrieval method .SUMMARY OF THE INVENTION .An invention according to a fifth illustrative implementation is a data processing system of the first illustrative implementation wherein the length of a key - candidate substring constituting the dictionary data is limited .", "label": "", "metadata": {}, "score": "66.66461"}
{"text": "13 , each separate curve corresponds to a fixed amount of storage space ( ranging from 0.7 % of available storage space to 1.5 % of the storage space ) .The knee of the curves appears at a signature length of approximately 50 .", "label": "", "metadata": {}, "score": "66.71195"}
{"text": "FIG .10 ( a ) is associated with experiments performed in the EVENT data set and FIG .10 ( b ) is associated with experiments performed in the SERVICE data set .Set hashing with both maximal overlap ( MO ) parsing and \" greedy parsing followed by the application of independent assumption \" ( ID ) parsing was tried .", "label": "", "metadata": {}, "score": "66.77655"}
{"text": "Functions of an index and a text ] .This section explains the most general functions of an index and a text .Configuration and function of an index .( 1 ) Index retrieval function .The following summarizes the index retrieval function .", "label": "", "metadata": {}, "score": "66.84526"}
{"text": "b \" b a c \" . fwdarw .b a b c a b Lower limit 1 . fwdarw .b c a b c a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "66.89216"}
{"text": "FIG .59 is a diagram showing the binary tree to which an interval has been added through splaying in the sixth embodiment of this invention ; .FIG .60 is a diagram showing the binary tree to which , in the binary tree shown in FIG .", "label": "", "metadata": {}, "score": "66.908936"}
{"text": "FIG .59 is a diagram showing the binary tree to which an interval has been added through splaying in the sixth embodiment of this invention ; .FIG .60 is a diagram showing the binary tree to which , in the binary tree shown in FIG .", "label": "", "metadata": {}, "score": "66.908936"}
{"text": "FIG .39 shows the binary tree 31 to which a node has been added at the position \u03b2 shown in FIG .37 .Interval Deletion Process .In the sixth embodiment , the deleting means 42 adjusts the node connection sequence and the interval lengths to maintain the integrity , such as the sequence of the remaining intervals , of the binary tree 31 .", "label": "", "metadata": {}, "score": "66.938354"}
{"text": "FIG .39 shows the binary tree 31 to which a node has been added at the position \u03b2 shown in FIG .37 .Interval Deletion Process .In the sixth embodiment , the deleting means 42 adjusts the node connection sequence and the interval lengths to maintain the integrity , such as the sequence of the remaining intervals , of the binary tree 31 .", "label": "", "metadata": {}, "score": "66.938354"}
{"text": "Thus , there has been a resurgence of interest in the storage , management and query processing of textual data .In many applications involving databases that process textual data , users pose ( sub)string queries , which may either search for exact matches , or contain wildcards .", "label": "", "metadata": {}, "score": "66.93945"}
{"text": "This simply - configured data retrieval system allows all , but non - duplicating , appearances of a pattern to be retrieved within the text .[ 4 . Fourth Embodiment ] .The object of the fourth embodiment is to provide a data processing system which makes adjustment work more efficient by putting a plurality of changes into one unit of processing .", "label": "", "metadata": {}, "score": "66.99696"}
{"text": "An invention according to claim 9 is a data retrieval system as claimed in claim 1 or 3 , wherein , when a trailing string obtained as retrieval includes the whole key string , the retrieving means issues a message indicating the fact .", "label": "", "metadata": {}, "score": "67.00249"}
{"text": "An invention according to claim 9 is a data retrieval system as claimed in claim 1 or 3 , wherein , when a trailing string obtained as retrieval includes the whole key string , the retrieving means issues a message indicating the fact .", "label": "", "metadata": {}, "score": "67.00249"}
{"text": "gamma.y .When none of these conditions is satisfied , retrieval is performed for the index , with \" . alpha.w \" as the key , to determine the insertion point .All these conditions need not be checked .For example , if the check is made only for conditions ( 1 ) and ( 2 ) and these conditions are not true , retrieval may be performed for the index with \" . alpha.w \" as the key .", "label": "", "metadata": {}, "score": "67.00739"}
{"text": "In some cases , similar clusters are identified , and those that are similar are merged .The idea is that clusters that have document sets that significantly overlap are probably related to the same theme and hence need to be merged .", "label": "", "metadata": {}, "score": "67.04031"}
{"text": "In some cases , similar clusters are identified , and those that are similar are merged .The idea is that clusters that have document sets that significantly overlap are probably related to the same theme and hence need to be merged .", "label": "", "metadata": {}, "score": "67.04031"}
{"text": "0093 ] .The system 700 further includes a tree prober 740 .The tree prober 740 employs the XPath expression tree to probe the document data tree and obtain matches with the substrings .[ 0094 ] .As stated above , the matches determine which subscribers are sent which XML documents .", "label": "", "metadata": {}, "score": "67.09779"}
{"text": "[0002 ] . \"Design and Evaluation of a Wide - Area Event Notification Service , \" ACM Transactions on Computer Systems , 19(3 ) : 332 - 383 , August 2001 .In general , such publish - subscribe architectures are implemented using a set of networked servers that selectively propagate relevant messages to the consumer population , where message relevance is determined by subscriptions representing the consumers ' interests in specific messages .", "label": "", "metadata": {}, "score": "67.14076"}
{"text": "It is also an object of this embodiment to provide a data processing system which uses a simple processing procedure .It is still another object of this embodiment to provide a data retrieval system which retrieves all , but non - duplicating , data strings containing a key string of a variable length .", "label": "", "metadata": {}, "score": "67.16334"}
{"text": "Strings in the form of advertisements appearing on web pages advertising the sale of goods or services may be one example of a document .These advertisements may contain titles , seller information , and other descriptive string based information .Example embodiments may include the populating of an item listing database 112 for the purpose of providing data upon which to conduct a search .", "label": "", "metadata": {}, "score": "67.2213"}
{"text": "Strings in the form of advertisements appearing on web pages advertising the sale of goods or services may be one example of a document .These advertisements may contain titles , seller information , and other descriptive string based information .Example embodiments may include the populating of an item listing database 112 for the purpose of providing data upon which to conduct a search .", "label": "", "metadata": {}, "score": "67.2213"}
{"text": "The following is an example of this type of code : .[ TABLE 1 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Position Code value _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 0 2 0 3 0 4 N 5 N 6 0 7 0 8 0 9 0 10 1 11 1 12 1 13 1 14 1 15 1 16 0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "67.22366"}
{"text": "In the following discussion , assume that the character string \" ba \" is inserted after position 4 ( \" b \" ) of the text \" ababcab \" .Note that the notation \" bca-456 \" , consisting of a substring and its character positions , is used for easy understanding .", "label": "", "metadata": {}, "score": "67.228584"}
{"text": "Similarly , \" b \" becomes \" bb \" and so it must be moved after \" babcabb \" .TABLE 10 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # # STR2 # # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Dictionary ) Lexicographic orderKey - candidate substringStart position _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # # STR3 # # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "67.26543"}
{"text": "An invention according to claim 22 is a data processing system as claimed in claim 18 , further comprising binary tree updating means for updating the binary tree , when the interval is changed , according to the contents of the change .", "label": "", "metadata": {}, "score": "67.28497"}
{"text": "An invention according to claim 22 is a data processing system as claimed in claim 18 , further comprising binary tree updating means for updating the binary tree , when the interval is changed , according to the contents of the change .", "label": "", "metadata": {}, "score": "67.28497"}
{"text": "B-4 .Updating the Binary Tree ] .When an interval is changed , the binary tree updating means 34 updates the binary tree 31 according to the contents of the change .When the length of an interval in the code string is changed , the interval length changing means 41 changes the corresponding interval length in the binary tree 31 .", "label": "", "metadata": {}, "score": "67.334656"}
{"text": "80 shows an example of a directed acyclic word graph .However , when the code string s is updated in a traditional data structure , the time required for updating retrieval data increases as the code string s becomes longer .", "label": "", "metadata": {}, "score": "67.35036"}
{"text": "80 shows an example of a directed acyclic word graph .However , when the code string s is updated in a traditional data structure , the time required for updating retrieval data increases as the code string s becomes longer .", "label": "", "metadata": {}, "score": "67.35036"}
{"text": "For example , adding 10 characters at the beginning of a character string increases the position of a subsequent character within the character string by 10 ( characters ) .For example , the value of a signal from a circuit is represented by L ( low ) , H ( high ) , and F ( floating , undefined ) .", "label": "", "metadata": {}, "score": "67.356964"}
{"text": "For example , adding 10 characters at the beginning of a character string increases the position of a subsequent character within the character string by 10 ( characters ) .For example , the value of a signal from a circuit is represented by L ( low ) , H ( high ) , and F ( floating , undefined ) .", "label": "", "metadata": {}, "score": "67.356964"}
{"text": "On Irix and win32 platforms , the current implementation maintains reference counts using an atomic add operation .A more generic implementation based on PThread mutexes is also provided .But it is unlikely to provide optimal performance for applications that use ropes extensively .", "label": "", "metadata": {}, "score": "67.37832"}
{"text": "On Irix and win32 platforms , the current implementation maintains reference counts using an atomic add operation .A more generic implementation based on PThread mutexes is also provided .But it is unlikely to provide optimal performance for applications that use ropes extensively .", "label": "", "metadata": {}, "score": "67.37832"}
{"text": "This facility makes it possible to manipulate a rope that is computed lazily as the pieces are needed .For example , it is possible to treat a file as a rope without actually reading in the entire file .Thus a text editor can represent even a 100 MB file being edited as a rope , updating it with standard rope operations , while still consuming only very small amount of memory .", "label": "", "metadata": {}, "score": "67.43878"}
{"text": "This facility makes it possible to manipulate a rope that is computed lazily as the pieces are needed .For example , it is possible to treat a file as a rope without actually reading in the entire file .Thus a text editor can represent even a 100 MB file being edited as a rope , updating it with standard rope operations , while still consuming only very small amount of memory .", "label": "", "metadata": {}, "score": "67.43878"}
{"text": "Note that this change does not apply to the substrings already deleted .For the text data , \" ba \" is deleted from the text \" ababbacab \" , and the position of the following substring ( cab-789 ) is adjusted to the position of cab-567 .", "label": "", "metadata": {}, "score": "67.441986"}
{"text": "For example , the embodiment may be built on a computer network to which a plurality of computers are connected .Any type of CPU may be used , a plurality of CPUs may be used at the same time , or a single CPU may be used in the time - sharing manner to process a plurality of processes concurrently .", "label": "", "metadata": {}, "score": "67.45509"}
{"text": "For example , the embodiment may be built on a computer network to which a plurality of computers are connected .Any type of CPU may be used , a plurality of CPUs may be used at the same time , or a single CPU may be used in the time - sharing manner to process a plurality of processes concurrently .", "label": "", "metadata": {}, "score": "67.45509"}
{"text": "For example , the embodiment may be built on a computer network to which a plurality of computers are connected .Any type of CPU may be used , a plurality of CPUs may be used at the same time , or a single CPU may be used in the time - sharing manner to process a plurality of processes concurrently .", "label": "", "metadata": {}, "score": "67.45509"}
{"text": "53 - 56 ) \" in Data Structures and Network Algorithms ) .During splaying , one of rotation , double rotation ( zig - zig ) , and double rotation ( zig - zag ) which satisfies the condition is applied repeatedly , with the target node as the node farthest from the root , until the target node becomes the root .", "label": "", "metadata": {}, "score": "67.48103"}
{"text": "53 - 56 ) \" in Data Structures and Network Algorithms ) .During splaying , one of rotation , double rotation ( zig - zig ) , and double rotation ( zig - zag ) which satisfies the condition is applied repeatedly , with the target node as the node farthest from the root , until the target node becomes the root .", "label": "", "metadata": {}, "score": "67.48103"}
{"text": "In the sixth embodiment , when the length of an interval in the code string is changed , the interval length changing means 41 changes the corresponding interval length in the binary tree 31 .When an interval is deleted from the code string , the deleting means 42 deletes the node corresponding to the deleted interval from the binary tree 31 .", "label": "", "metadata": {}, "score": "67.51311"}
{"text": "In the sixth embodiment , when the length of an interval in the code string is changed , the interval length changing means 41 changes the corresponding interval length in the binary tree 31 .When an interval is deleted from the code string , the deleting means 42 deletes the node corresponding to the deleted interval from the binary tree 31 .", "label": "", "metadata": {}, "score": "67.51311"}
{"text": "[ 8 .Eighth Embodiment ] .This embodiment integrates the nodes of dictionary data and text data shown in FIG .2 , with the lexicographic order being represented by partial interval lengths .This embodiment may be applied to both a data processing system and a data retrieval system .", "label": "", "metadata": {}, "score": "67.55658"}
{"text": "In addition , the program may be divided into a plurality of modules which are stored on an external storage device .In this case , only the modules necessary for processing are read into main memory .Each program module may be stored on a storage device most suitable for it .", "label": "", "metadata": {}, "score": "67.62547"}
{"text": "In addition , the program may be divided into a plurality of modules which are stored on an external storage device .In this case , only the modules necessary for processing are read into main memory .Each program module may be stored on a storage device most suitable for it .", "label": "", "metadata": {}, "score": "67.62547"}
{"text": "In addition , the program may be divided into a plurality of modules which are stored on an external storage device .In this case , only the modules necessary for processing are read into main memory .Each program module may be stored on a storage device most suitable for it .", "label": "", "metadata": {}, "score": "67.62547"}
{"text": "FIG .21 is a block diagram showing the configuration of the sixth embodiment .It is an object of the sixth embodiment to provide a data processing system and a data processing method which process data efficiently .This data processing system and a data processing method are particularly suitable for implementing the data retrieval system and the data retrieval method described above .", "label": "", "metadata": {}, "score": "67.636215"}
{"text": "FIG .21 is a block diagram showing the configuration of the sixth embodiment .It is an object of the sixth embodiment to provide a data processing system and a data processing method which process data efficiently .This data processing system and a data processing method are particularly suitable for implementing the data retrieval system and the data retrieval method described above .", "label": "", "metadata": {}, "score": "67.636215"}
{"text": "It is still another object of the first embodiment to provide a data retrieval system and data retrieval method which process data using a simple procedure .Configuration of the First Embodiment !FIG .1 is a functional block diagram showing the configuration of the first embodiment .", "label": "", "metadata": {}, "score": "67.70147"}
{"text": "It is still another object of the first embodiment to provide a data retrieval system and data retrieval method which process data using a simple procedure .Configuration of the First Embodiment !FIG .1 is a functional block diagram showing the configuration of the first embodiment .", "label": "", "metadata": {}, "score": "67.70147"}
{"text": "It is another object of this invention to provide a data processing system and a data processing method which use memory efficiently .SUMMARY OF THE INVENTION .This means that the whole or a part of a key string included in the code string is always included in at least one of dictionaries , so that it is found during retrieval based on the dictionary data .", "label": "", "metadata": {}, "score": "67.73537"}
{"text": "It is another object of this invention to provide a data processing system and a data processing method which use memory efficiently .SUMMARY OF THE INVENTION .This means that the whole or a part of a key string included in the code string is always included in at least one of dictionaries , so that it is found during retrieval based on the dictionary data .", "label": "", "metadata": {}, "score": "67.73537"}
{"text": "This tree serves as dictionary data representing the correspondence between trailing strings and their positions ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ababc : 0 abc : 2 babc : 1 bc : 3 c : 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "67.73859"}
{"text": "This tree serves as dictionary data representing the correspondence between trailing strings and their positions ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ababc : 0 abc : 2 babc : 1 bc : 3 c : 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "67.73859"}
{"text": "claim 12 , further comprising a separating engine to filter the item data from the noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .", "label": "", "metadata": {}, "score": "67.86336"}
{"text": "claim 12 , further comprising a separating engine to filter the item data from the noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .", "label": "", "metadata": {}, "score": "67.86336"}
{"text": "0007 ] .Accordingly , what is needed in the art is a system and method for effectively addressing this problem .SUMMARY OF THE INVENTION .[0008 ] .To address the above - discussed deficiencies of the prior art , the present invention provides a system for , and method of , filtering an XML document with XPath expressions and a selective data dissemination system incorporating the system or the method .", "label": "", "metadata": {}, "score": "67.87529"}
{"text": "FIG .42 shows the binary tree 31 from which a node has been deleted .Structure Adjustment Process .When adding or deleting an interval , the structure adjusting means 45 changes the connection sequence of nodes to maintain the balance of the number of nodes in the binary tree 31 ( step 355 ) .", "label": "", "metadata": {}, "score": "67.8758"}
{"text": "FIG .42 shows the binary tree 31 from which a node has been deleted .Structure Adjustment Process .When adding or deleting an interval , the structure adjusting means 45 changes the connection sequence of nodes to maintain the balance of the number of nodes in the binary tree 31 ( step 355 ) .", "label": "", "metadata": {}, "score": "67.8758"}
{"text": "In some cases , internet refers to a network of networks .These networks may use a variety of protocols for the exchange of data , including the aforementioned TCP / IP , and additionally ATM , SNA , SDI , or some other suitable protocol .", "label": "", "metadata": {}, "score": "67.89148"}
{"text": "In some cases , internet refers to a network of networks .These networks may use a variety of protocols for the exchange of data , including the aforementioned TCP / IP , and additionally ATM , SNA , SDI , or some other suitable protocol .", "label": "", "metadata": {}, "score": "67.89148"}
{"text": "gamma.y , if the difference .gamma .between the shortest trailing string .gamma.y which is longer than the trailing string y coming immediately after the longest trailing string w which is shorter than said trailing string . alpha.w in said table and the trailing string y immediately after w matches the difference .", "label": "", "metadata": {}, "score": "67.920105"}
{"text": "gamma.y , if the difference .gamma .between the shortest trailing string .gamma.y which is longer than the trailing string y coming immediately after the longest trailing string w which is shorter than said trailing string . alpha.w in said table and the trailing string y immediately after w matches the difference .", "label": "", "metadata": {}, "score": "67.920105"}
{"text": "gamma.y , if the difference .gamma .between the shortest trailing string .gamma.y which is longer than the trailing string y coming immediately after the longest trailing string w which is shorter than said trailing string . alpha.w in said table and the trailing string y immediately after w matches the difference .", "label": "", "metadata": {}, "score": "67.920105"}
{"text": "gamma.y , if the difference .gamma .between the shortest trailing string .gamma.y which is longer than the trailing string y coming immediately after the longest trailing string w which is shorter than said trailing string . alpha.w in said table and the trailing string y immediately after w matches the difference .", "label": "", "metadata": {}, "score": "67.920105"}
{"text": "The virtual meaning of this invention lies in the configuration and function of an index and text as well as in procedure of the updating means and retrieving means implemented by an index and text .The index generating means and the text generating means are not those independent component that are always required .", "label": "", "metadata": {}, "score": "68.055145"}
{"text": "3 is a flowchart illustrating a method used to execute an operation that sends a Hyper Text Transfer Protocol ( HTTP ) call to a relevancy weighting system , according to an example embodiment .FIG .4 is a flowchart illustrating a method used to execute an operation that makes an Application Programming Interface ( API ) call to a search backend call , according to an example embodiment .", "label": "", "metadata": {}, "score": "68.05583"}
{"text": "3 is a flowchart illustrating a method used to execute an operation that sends a Hyper Text Transfer Protocol ( HTTP ) call to a relevancy weighting system , according to an example embodiment .FIG .4 is a flowchart illustrating a method used to execute an operation that makes an Application Programming Interface ( API ) call to a search backend call , according to an example embodiment .", "label": "", "metadata": {}, "score": "68.05583"}
{"text": "An invention according to an eleventh illustrative implementation is a data processing system of the first illustrative implementation wherein the retrieving means retrieves data by referencing both the dictionary tree and the text tree .According to the invention of the eleventh illustrative implementation , the retrieving means retrieves data by referencing both the dictionary tree and the text tree via pointers , storing a character string efficiently .", "label": "", "metadata": {}, "score": "68.09552"}
{"text": "4 is a flowchart illustrating an example method used to execute operation 202 .Shown is a query 108 that is provided and/or retrieved by an operation 401 .This operation 401 acts to parse the query 108 and generates a search back end call using the query data that is parsed from the query 108 .", "label": "", "metadata": {}, "score": "68.11215"}
{"text": "4 is a flowchart illustrating an example method used to execute operation 202 .Shown is a query 108 that is provided and/or retrieved by an operation 401 .This operation 401 acts to parse the query 108 and generates a search back end call using the query data that is parsed from the query 108 .", "label": "", "metadata": {}, "score": "68.11215"}
{"text": "Description .BACKGROUND OF THE INVENTION .[ 1 .Field of the Invention ] .This invention relates to an improved data retrieval system which retrieves a code string such as a character string .It also relates to an improved data processing system which processes data and so on .", "label": "", "metadata": {}, "score": "68.199875"}
{"text": "The parameter \u03b8 ( ranging from 0 to 1 ) controls the skewness of the Zipf distribution ( G. Zipf .Human Behaviour and Principle of Least Effort .Addison - Wesley , Cambridge , Mass. , 1949 , incorporated herein by reference ) used for selecting element names , where a value of 0 corresponds to a uniform distribution and a higher value corresponds to a more skewed distribution .", "label": "", "metadata": {}, "score": "68.21161"}
{"text": "That is , in this invention , general items needed for the operation of this invention , such as pointers , counters , flags , parameters , and buffers are used as necessary .Unless otherwise specified , information necessary for each portion of this embodiment is obtained from other portions holding the information .", "label": "", "metadata": {}, "score": "68.25372"}
{"text": "That is , in this invention , general items needed for the operation of this invention , such as pointers , counters , flags , parameters , and buffers are used as necessary .Unless otherwise specified , information necessary for each portion of this embodiment is obtained from other portions holding the information .", "label": "", "metadata": {}, "score": "68.25372"}
{"text": "That is , in this invention , general items needed for the operation of this invention , such as pointers , counters , flags , parameters , and buffers are used as necessary .Unless otherwise specified , information necessary for each portion of this embodiment is obtained from other portions holding the information .", "label": "", "metadata": {}, "score": "68.25372"}
{"text": "According to the invention of the 28 . sup.th and 29 . sup.th illustrative implementations , limiting the length of a key - candidate substring saves storage space where key - candidate substrings are stored .In addition , limiting the length of a key - candidate substring eliminates the need for redundant comparison .", "label": "", "metadata": {}, "score": "68.305565"}
{"text": "Therefore , there is little or no probability that \" . alpha.w \" and \" . alpha.xy.alpha.w \" are compared directly .Even if \" . alpha.w \" and \" . alpha.xy.alpha.w \" must be compared , direct comparison is performed only for the not - registered range \" xy.alpha .", "label": "", "metadata": {}, "score": "68.406204"}
{"text": "For example , data , which is described in this specification to reside on a hard disk , may be in main storage , an external storage unit , CPU register , or cache memory .In addition , data may be held in any form .", "label": "", "metadata": {}, "score": "68.49373"}
{"text": "For example , data , which is described in this specification to reside on a hard disk , may be in main storage , an external storage unit , CPU register , or cache memory .In addition , data may be held in any form .", "label": "", "metadata": {}, "score": "68.49373"}
{"text": "For example , data , which is described in this specification to reside on a hard disk , may be in main storage , an external storage unit , CPU register , or cache memory .In addition , data may be held in any form .", "label": "", "metadata": {}, "score": "68.49373"}
{"text": "49 .For node b : .Similarly , for node g : .Therefore , for node h : .This formula is expanded as follows : .Terms are eliminated as follows : . a5-h5-f4 Formula 40 !", "label": "", "metadata": {}, "score": "68.53143"}
{"text": "49 .For node b : .Similarly , for node g : .Therefore , for node h : .This formula is expanded as follows : .Terms are eliminated as follows : . a5-h5-f4 Formula 40 !", "label": "", "metadata": {}, "score": "68.53143"}
{"text": "1 , pp .116 - 124 , Oct. 22 , 1990 , William I Chang , et al . , \" Approximate String Matching In Sublinear Expected Time \" .Primary Examiner : Black ; Thomas G. Assistant Examiner : Lewis ; Cheryl R. Attorney , Agent or Firm : .", "label": "", "metadata": {}, "score": "68.626144"}
{"text": "[ 7 - 1 .Configuration of the Seventh Embodiment ] .FIG .39 is a functional block diagram showing the configuration of the seventh embodiment .In addition , the data processing system has the text generating means 24 which generates the text 23 .", "label": "", "metadata": {}, "score": "68.63017"}
{"text": "5 such that the string \" Pepsi Cola Bottle Opener \" may be generated through the clustering of various substrings within a hash table .At position 605 , the substring \" Coin \" is illustrated wherein the substring \" Coin \" roughly corresponds to node 18 referenced as 511 in .", "label": "", "metadata": {}, "score": "68.649124"}
{"text": "5 such that the string \" Pepsi Cola Bottle Opener \" may be generated through the clustering of various substrings within a hash table .At position 605 , the substring \" Coin \" is illustrated wherein the substring \" Coin \" roughly corresponds to node 18 referenced as 511 in .", "label": "", "metadata": {}, "score": "68.649124"}
{"text": "claim 1 , further comprising filtering the item data from the noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .The method of .", "label": "", "metadata": {}, "score": "68.665344"}
{"text": "claim 1 , further comprising filtering the item data from the noise data based upon a frequency with which a word is used in a search as compared to a frequency another word is used in the search .The method of .", "label": "", "metadata": {}, "score": "68.665344"}
{"text": "Thus the balance operation tends to not rebalance the same substring .The worst - case cost of rebalancing is nonetheless linear in the string .However , the observed behavior is that rebalancing typically consumes a small fraction of the running time .", "label": "", "metadata": {}, "score": "68.71019"}
{"text": "Thus the balance operation tends to not rebalance the same substring .The worst - case cost of rebalancing is nonetheless linear in the string .However , the observed behavior is that rebalancing typically consumes a small fraction of the running time .", "label": "", "metadata": {}, "score": "68.71019"}
{"text": "51 is a conceptual diagram showing how the nodes in a part of the binary tree in FIG .49 are connected by pointers in the sixth embodiment of this invention ; .FIG .52 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "68.77962"}
{"text": "51 is a conceptual diagram showing how the nodes in a part of the binary tree in FIG .49 are connected by pointers in the sixth embodiment of this invention ; .FIG .52 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "68.77962"}
{"text": "b c a b c a b Lower limit 0 . fwdarw ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "68.83283"}
{"text": "These various components may be written using the above illustrated object - oriented programming techniques and can be written in the same programming language or different programming languages .Various protocols may be implemented to enable these various components to communicate regardless of the programming language used to write these components .", "label": "", "metadata": {}, "score": "68.84052"}
{"text": "These various components may be written using the above illustrated object - oriented programming techniques and can be written in the same programming language or different programming languages .Various protocols may be implemented to enable these various components to communicate regardless of the programming language used to write these components .", "label": "", "metadata": {}, "score": "68.84052"}
{"text": "The \" input \" mentioned in this specification implies not only the input of data but also other types of processing closely related with data input .They include the echo - back , modification , and editing of entered data .", "label": "", "metadata": {}, "score": "68.84362"}
{"text": "The \" input \" mentioned in this specification implies not only the input of data but also other types of processing closely related with data input .They include the echo - back , modification , and editing of entered data .", "label": "", "metadata": {}, "score": "68.84362"}
{"text": "The \" input \" mentioned in this specification implies not only the input of data but also other types of processing closely related with data input .They include the echo - back , modification , and editing of entered data .", "label": "", "metadata": {}, "score": "68.84362"}
{"text": "Condition 1 : .( 2 ) When node x has the grandparent : .Condition 2 : . rank ( x ) .( 3 ) When node x is an external node : .Condition 3 : . and when node x has the parent : .", "label": "", "metadata": {}, "score": "68.894844"}
{"text": "Condition 1 : .( 2 ) When node x has the grandparent : .Condition 2 : . rank ( x ) .( 3 ) When node x is an external node : .Condition 3 : . and when node x has the parent : .", "label": "", "metadata": {}, "score": "68.894844"}
{"text": "This TCP segment also contains port information for a recipient software application residing remotely .This TCP segment is loaded into the data load field of an IP datagram residing at the network layer .Next , this IP datagram is loaded into a frame residing at the data link layer .", "label": "", "metadata": {}, "score": "68.915794"}
{"text": "This TCP segment also contains port information for a recipient software application residing remotely .This TCP segment is loaded into the data load field of an IP datagram residing at the network layer .Next , this IP datagram is loaded into a frame residing at the data link layer .", "label": "", "metadata": {}, "score": "68.915794"}
{"text": "An invention according to claim 7 is a data retrieval system as claimed in claim 6 , wherein the second edge is attached a label which is an extra code of one of two trailing strings corresponding to two end nodes connected by the edge .", "label": "", "metadata": {}, "score": "68.927826"}
{"text": "An invention according to claim 7 is a data retrieval system as claimed in claim 6 , wherein the second edge is attached a label which is an extra code of one of two trailing strings corresponding to two end nodes connected by the edge .", "label": "", "metadata": {}, "score": "68.927826"}
{"text": "And an invention according to a 48 .According to the data processing system of the 47 . sup.th illustrative implementation and the data processing method of the 48 . sup.th illustrative implementation , a simply - structured data processing system and the data processing method , which does not generate text , can be configured .", "label": "", "metadata": {}, "score": "69.03666"}
{"text": "A Computer System .FIG .17 shows a diagrammatic representation of a machine in the example form of a computer system 1700 within which a set of instructions for causing the machine to perform any one or more of the methodologies discussed herein may be executed .", "label": "", "metadata": {}, "score": "69.09981"}
{"text": "A Computer System .FIG .17 shows a diagrammatic representation of a machine in the example form of a computer system 1700 within which a set of instructions for causing the machine to perform any one or more of the methodologies discussed herein may be executed .", "label": "", "metadata": {}, "score": "69.09981"}
{"text": "And an invention according to a 46 .According to the data processing system of the 45 . sup.th illustrative implementation and the data processing method of the 46 . sup.th illustrative implementation , a simply - structured data processing system and the data processing method , which does not generate text , can be configured .", "label": "", "metadata": {}, "score": "69.17775"}
{"text": "The Xpath language treats XML documents as a tree of nodes ( corresponding to elements ) and offers an expressive way to specify and select parts of this tree . XPath expressions ( XPEs)are structural patterns that can be matched to nodes in the XML data tree .", "label": "", "metadata": {}, "score": "69.29228"}
{"text": "This demand data may be data relating to how often a word has been used by all users , or a portion of users conducting a search .Attribute data may be data that defines some other piece of data such that the attribute is dependant upon this other piece of data .", "label": "", "metadata": {}, "score": "69.31996"}
{"text": "This demand data may be data relating to how often a word has been used by all users , or a portion of users conducting a search .Attribute data may be data that defines some other piece of data such that the attribute is dependant upon this other piece of data .", "label": "", "metadata": {}, "score": "69.31996"}
{"text": "beta .between the shortest trailing string . beta.x which is longer than the trailing string x coming immediately before w which is the longest trailing string shorter than said trailing string . alpha.w in said table and the said trailing string x coming immediately before w matches the difference .", "label": "", "metadata": {}, "score": "69.36375"}
{"text": "beta .between the shortest trailing string . beta.x which is longer than the trailing string x coming immediately before w which is the longest trailing string shorter than said trailing string . alpha.w in said table and the said trailing string x coming immediately before w matches the difference .", "label": "", "metadata": {}, "score": "69.36375"}
{"text": "beta .between the shortest trailing string . beta.x which is longer than the trailing string x coming immediately before w which is the longest trailing string shorter than said trailing string . alpha.w in said table and the said trailing string x coming immediately before w matches the difference .", "label": "", "metadata": {}, "score": "69.36375"}
{"text": "beta .between the shortest trailing string . beta.x which is longer than the trailing string x coming immediately before w which is the longest trailing string shorter than said trailing string . alpha.w in said table and the said trailing string x coming immediately before w matches the difference .", "label": "", "metadata": {}, "score": "69.36375"}
{"text": "In a networked deployment , the machine may operate in the capacity of a server or a client machine in a server - client network environment or as a peer machine in a peer - to - peer ( or distributed ) network environment .", "label": "", "metadata": {}, "score": "69.37579"}
{"text": "In a networked deployment , the machine may operate in the capacity of a server or a client machine in a server - client network environment or as a peer machine in a peer - to - peer ( or distributed ) network environment .", "label": "", "metadata": {}, "score": "69.37579"}
{"text": "In this embodiment , all the trailing strings ( ababcab , babcab , abcab , bcab , cab , ab , b ) in the text are used as key - candidate substrings and , therefore , the average key length is one half of the whole length of the text .", "label": "", "metadata": {}, "score": "69.47885"}
{"text": "The complexity of Algorithm PROPAGATE - UPDATE is O(H L max ) .Since Algorithm MATCH - SUBSTRING makes at most L calls to Algorithm PROPAGATE - UPDATE , the complexity of Algorithm MATCH - SUBSTRING is O(L H L max ) .", "label": "", "metadata": {}, "score": "69.4843"}
{"text": "In a typical software configuration of this computer , a program executing each function of this embodiment runs as an application program under the operating system ( OS ) .Typically , the machine language generated by compiling a program coded in a high - level language or assembler is used .", "label": "", "metadata": {}, "score": "69.66611"}
{"text": "In a typical software configuration of this computer , a program executing each function of this embodiment runs as an application program under the operating system ( OS ) .Typically , the machine language generated by compiling a program coded in a high - level language or assembler is used .", "label": "", "metadata": {}, "score": "69.66611"}
{"text": "In a typical software configuration of this computer , a program executing each function of this embodiment runs as an application program under the operating system ( OS ) .Typically , the machine language generated by compiling a program coded in a high - level language or assembler is used .", "label": "", "metadata": {}, "score": "69.66611"}
{"text": "TECHNICAL FIELD OF THE INVENTION .[ 0001 ] .The present invention is directed , in general , to systems for processing markup languages and , more specifically , to a system and method for filtering Extensible Markup Language ( XML ) documents with XPath expressions .", "label": "", "metadata": {}, "score": "69.68449"}
{"text": "Second , the XTrie structure and algorithms are designed to support both ordered and unordered matching of XML data .Third , by indexing on sequences of element names organized in a trie structure and using a sophisticated matching algorithm , XTrie is able to both reduce the number of unnecessary index probes as well as avoid redundant matchings , thereby providing extremely efficient filtering .", "label": "", "metadata": {}, "score": "69.83228"}
{"text": "This is more prominent as the changed character is closer to the end of the code string s. .For example , if the last character \" c \" of the code string s is deleted in FIG .79 , three edges ( c ) are deleted and the labels on two edges ( abc ) are changed .", "label": "", "metadata": {}, "score": "69.89061"}
{"text": "This is more prominent as the changed character is closer to the end of the code string s. .For example , if the last character \" c \" of the code string s is deleted in FIG .79 , three edges ( c ) are deleted and the labels on two edges ( abc ) are changed .", "label": "", "metadata": {}, "score": "69.89061"}
{"text": "( length of copied part.div.2 ) characters on the average .That is , the number of characters that must be compared is proportional to the square of the length of the copied part ( matching part ) .So , it takes longer as the matching part becomes longer .", "label": "", "metadata": {}, "score": "69.91594"}
{"text": "EXAMPLE .The following explains , with the use of an example , how the comparison described above is performed .In the following discussion , assume that the trailing strings of the code string \" ababcab \" have already been registered lexicographically in the index .", "label": "", "metadata": {}, "score": "69.95482"}
{"text": "Some embodiments may also use price to measure the effectiveness of a cluster .This factor may , for example , be applied just before the generation of the merged cluster map .For example , in certain cases a fixed price exists for an item offered for sale ( e.g. , a \" buy it now \" price ) .", "label": "", "metadata": {}, "score": "69.98306"}
{"text": "Some embodiments may also use price to measure the effectiveness of a cluster .This factor may , for example , be applied just before the generation of the merged cluster map .For example , in certain cases a fixed price exists for an item offered for sale ( e.g. , a \" buy it now \" price ) .", "label": "", "metadata": {}, "score": "69.98306"}
{"text": "The computer system of .claim 12 , wherein the item data includes at least one of an item title , an item category , or seller information .The computer system of .claim 12 , wherein the item data is part of a plurality of merged clusters organized into a hierarchy of merged clusters .", "label": "", "metadata": {}, "score": "69.983215"}
{"text": "The computer system of .claim 12 , wherein the item data includes at least one of an item title , an item category , or seller information .The computer system of .claim 12 , wherein the item data is part of a plurality of merged clusters organized into a hierarchy of merged clusters .", "label": "", "metadata": {}, "score": "69.983215"}
{"text": "[ 0016 ] .The foregoing has outlined , rather broadly , preferred and alternative features of the present invention so that those skilled in the art may better understand the detailed description of the invention that follows .Additional features of the invention will be described hereinafter that form the subject of the claims of the invention .", "label": "", "metadata": {}, "score": "70.097946"}
{"text": "37 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .FIG .38 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .", "label": "", "metadata": {}, "score": "70.18886"}
{"text": "37 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .FIG .38 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .", "label": "", "metadata": {}, "score": "70.18886"}
{"text": "And an invention according to a 50 .According to the data retrieval system of the 49 . sup.th illustrative implementation and the data retrieval method of the 50 . sup.th illustrative implementation , an efficient data retrieval system and the data retrieval method , which can compare two substrings easily and can restore the whole or a part of a code string , can be configured .", "label": "", "metadata": {}, "score": "70.221405"}
{"text": "a b a b a b c a b a b c a b \" b a c \" . fwdarw .b b a b c a b b c a b c a b Lower limit 0 . fwdarw .", "label": "", "metadata": {}, "score": "70.26384"}
{"text": "The character in position 5 is retrieved in one of the following two ways : .( 1 ) Because the character \" b \" in position 4 is the second character \" b \" of the dictionary item \" abc \" , the character \" c \" which follows that character is in position 5 .", "label": "", "metadata": {}, "score": "70.3779"}
{"text": "Because the pattern \" bac \" is larger than the root \" b \" , the function follows the right path and continues the binary tree search by adding the second character ( that is , \" ba \" ) .Because \" ba \" is smaller than \" bcab \" which is in the next node , the function follows the left path to reach the node \" babcab \" .", "label": "", "metadata": {}, "score": "70.4276"}
{"text": "Reference count updates should be implemented in terms of an atomic add operation whenever such an operation is available .It is important that the reference count decrement operation not only atomically decrement the count , but also return the result as part of the atomic operation .", "label": "", "metadata": {}, "score": "70.47977"}
{"text": "Reference count updates should be implemented in terms of an atomic add operation whenever such an operation is available .It is important that the reference count decrement operation not only atomically decrement the count , but also return the result as part of the atomic operation .", "label": "", "metadata": {}, "score": "70.47977"}
{"text": "FIG .13 is a flowchart illustrating an example method used to implement operation 206 .Illustrated is a configuration instruction set 1301 that is received or processed through the execution of operation 1302 .Once operation 1302 is executed , and the configuration instruction set is received and parsed , an operation 1303 is executed that extracts merged threshold data .", "label": "", "metadata": {}, "score": "70.590385"}
{"text": "FIG .13 is a flowchart illustrating an example method used to implement operation 206 .Illustrated is a configuration instruction set 1301 that is received or processed through the execution of operation 1302 .Once operation 1302 is executed , and the configuration instruction set is received and parsed , an operation 1303 is executed that extracts merged threshold data .", "label": "", "metadata": {}, "score": "70.590385"}
{"text": "The balance operation proceeds as described in the paper cited above .The operation is non - destructive ; rebalanced pieces formerly shared with other ropes are no longer shared after the operation .As a rope is being balanced , the balanced bit is set in each concatenation node that has sufficiently small depth for its length .", "label": "", "metadata": {}, "score": "70.68445"}
{"text": "The balance operation proceeds as described in the paper cited above .The operation is non - destructive ; rebalanced pieces formerly shared with other ropes are no longer shared after the operation .As a rope is being balanced , the balanced bit is set in each concatenation node that has sufficiently small depth for its length .", "label": "", "metadata": {}, "score": "70.68445"}
{"text": "The present invention is superior to the prior system in that intervals are processed .In addition , the prior system follows a path from a specified node to the root to calculate the sequence number of the specified node from its address ; however , it can not retrieve a node when a value within an interval is given .", "label": "", "metadata": {}, "score": "70.99379"}
{"text": "The present invention is superior to the prior system in that intervals are processed .In addition , the prior system follows a path from a specified node to the root to calculate the sequence number of the specified node from its address ; however , it can not retrieve a node when a value within an interval is given .", "label": "", "metadata": {}, "score": "70.99379"}
{"text": "Then , the following steps are repeated until the current node becomes the root ( step 282 ) .That is , the current node is moved to the parent with the old current node as the child node ( step 283 ) .", "label": "", "metadata": {}, "score": "71.038826"}
{"text": "Then , the following steps are repeated until the current node becomes the root ( step 282 ) .That is , the current node is moved to the parent with the old current node as the child node ( step 283 ) .", "label": "", "metadata": {}, "score": "71.038826"}
{"text": "71 shows how the binary tree looks like after the node colors have been changed .In this state , both node g and its parent node e become red , requiring further adjustment .That is , because node a is black , nodes g , e , b , and a correspond to ( b ) in FIG .", "label": "", "metadata": {}, "score": "71.15396"}
{"text": "71 shows how the binary tree looks like after the node colors have been changed .In this state , both node g and its parent node e become red , requiring further adjustment .That is , because node a is black , nodes g , e , b , and a correspond to ( b ) in FIG .", "label": "", "metadata": {}, "score": "71.15396"}
{"text": "31 is a diagram showing the configuration of the index used in the third embodiment of this invention .FIG .32(A ) is a diagram showing a \" change position \" when a character is changed in the text in the third embodiment of this invention ; .", "label": "", "metadata": {}, "score": "71.19825"}
{"text": "15 contains a graph of absolute error associated with hashing techniques of the present invention as a function of the hash space size .DETAILED DESCRIPTION .A basic premise of the present invention is the realization that it is not necessary to have exact cross - count values in order to achieve accurate multidimensional selectivity estimation .", "label": "", "metadata": {}, "score": "71.412384"}
{"text": "30 is a functional block diagram showing an example of hardware configuration for use in the retrieval described above .That is , there are as many information areas as the nodes , each area consisting of the pointer storage area P and the partial interval length storage area L. These areas are contained in a fixed - length array .", "label": "", "metadata": {}, "score": "71.45614"}
{"text": "30 is a functional block diagram showing an example of hardware configuration for use in the retrieval described above .That is , there are as many information areas as the nodes , each area consisting of the pointer storage area P and the partial interval length storage area L. These areas are contained in a fixed - length array .", "label": "", "metadata": {}, "score": "71.45614"}
{"text": "An invention according to an 80 . sup.th illustrative implementation is a data processing method of the 34 .An invention according to an 81 . sup.st illustrative implementation is a data processing method of the 34 .According to the inventions of the 78 . sup.th to 81 . sup.st illustrative implementations , whether or not the leading string of a trailing string which contain the changed part is to be re - arranged can be determined easily when a part of the code string is changed .", "label": "", "metadata": {}, "score": "71.54192"}
{"text": "An invention according to a 41 . sup.st illustrative implementation is a data processing system of the 33 .An invention according to a 42 . sup.nd illustrative implementation is a data processing system of the 33 .According to the inventions of the 39 . sup.th to 42 . sup.nd illustrative implementations , whether or not the leading string of a trailing string which contain the changed part is to be re - arranged can be determined easily when a part of the code string is changed .", "label": "", "metadata": {}, "score": "71.67616"}
{"text": "This parsing operation may , in some embodiments , remove ( e.g. , filter ) noise words from an electronic document in the form of , for example , an advertisement .These noise words may be duplicate words in the electronic document , or words that otherwise do not add meaning to the electronic document .", "label": "", "metadata": {}, "score": "71.68014"}
{"text": "This parsing operation may , in some embodiments , remove ( e.g. , filter ) noise words from an electronic document in the form of , for example , an advertisement .These noise words may be duplicate words in the electronic document , or words that otherwise do not add meaning to the electronic document .", "label": "", "metadata": {}, "score": "71.68014"}
{"text": "Dictionary data of each of a plurality of substrings may be created as a single tree ( third embodiment ) .FIG .17 shows an example of this tree .This tree serves two functions : dictionary data for the leading string \" ababc \" and the trailing string \" abcab \" of the code string \" ababcab \" .", "label": "", "metadata": {}, "score": "71.750946"}
{"text": "Dictionary data of each of a plurality of substrings may be created as a single tree ( third embodiment ) .FIG .17 shows an example of this tree .This tree serves two functions : dictionary data for the leading string \" ababc \" and the trailing string \" abcab \" of the code string \" ababcab \" .", "label": "", "metadata": {}, "score": "71.750946"}
{"text": "An additional substring contains the terms \" Pepsi Cola Coin Bank , \" wherein this substring is contained in documents 0 and 3 ( see e.g. , node 19 referenced herein as 514 ) .FIG .6 is a diagram of an example hash table 600 illustrating a data structure that may be used to store item data in the form of strings or substrings that may appear in , for example , various documents .", "label": "", "metadata": {}, "score": "71.75215"}
{"text": "An additional substring contains the terms \" Pepsi Cola Coin Bank , \" wherein this substring is contained in documents 0 and 3 ( see e.g. , node 19 referenced herein as 514 ) .FIG .6 is a diagram of an example hash table 600 illustrating a data structure that may be used to store item data in the form of strings or substrings that may appear in , for example , various documents .", "label": "", "metadata": {}, "score": "71.75215"}
{"text": "gamma.y which are immediately before and after the shortest trailing string . alpha.w which is longer than said trailing string w in said table , the leading string of the longest trailing string x which is shorter than .beta.x is adjacent to the leading string of the longest trailing string y which is shorter than .", "label": "", "metadata": {}, "score": "72.03551"}
{"text": "gamma.y which are immediately before and after the shortest trailing string . alpha.w which is longer than said trailing string w in said table , the leading string of the longest trailing string x which is shorter than .beta.x is adjacent to the leading string of the longest trailing string y which is shorter than .", "label": "", "metadata": {}, "score": "72.03551"}
{"text": "Document preparation ; 2 .Identifying base clusters ; and 3 .Merging clusters .During the merging of clusters , various relevance weighing factors ( e.g. , multi - factor clustering ) may be utilized to merge the clusters in more or less desirable ways depending upon the selected factors .", "label": "", "metadata": {}, "score": "72.13574"}
{"text": "Document preparation ; 2 .Identifying base clusters ; and 3 .Merging clusters .During the merging of clusters , various relevance weighing factors ( e.g. , multi - factor clustering ) may be utilized to merge the clusters in more or less desirable ways depending upon the selected factors .", "label": "", "metadata": {}, "score": "72.13574"}
{"text": "While both of these methods are effective when working with only two dimensions and a relatively small number of tuples in the data set , they suffer from a \" space dimensionality explosion \" , since both methods may consume an exponential amount of storage space for storing cross - counts .", "label": "", "metadata": {}, "score": "72.139755"}
{"text": "40 is a diagram showing how the unit function ( .times.3 ) is implemented ; .FIG .41(A ) , FIG .41(B ) and FIG .41(C ) are diagrams showing how the unit function ( .times.5 ) is implemented ; .", "label": "", "metadata": {}, "score": "72.17953"}
{"text": "The key - candidate substring in the index corresponding to this is \" 3 , abcab , 3 \" .As a result , \" bcab \" and \" cab \" , shorter than \" abcab \" in the text , is determined that they must be re - arranged .", "label": "", "metadata": {}, "score": "72.31518"}
{"text": "An invention according to a 72 . sup.nd illustrative implementation is a data processing system of the 45 . sup.th , 46 . sup.th , 51 . sup.st and 53 . sup.rd illustrative implementations wherein the updating means combines the updates for a plurality of changes to the code string into one unit of work .", "label": "", "metadata": {}, "score": "72.351"}
{"text": "[ 1 - 2 - 1 - 4 .Deleting a Character String from the Text ] .To delete a character string from the text , this embodiment performs the insertion procedure described above in the reverse order .Assume that the character string \" ba \" is deleted from the text \" ababbacab \" .", "label": "", "metadata": {}, "score": "72.37114"}
{"text": "( This is less of an issue with a garbage collector , since it turns out to be reasonably efficient to maintain such caches in the function object itself .Without a garbage collector , this requires locking around cache accesses , which is usually unacceptable . )", "label": "", "metadata": {}, "score": "72.38349"}
{"text": "( This is less of an issue with a garbage collector , since it turns out to be reasonably efficient to maintain such caches in the function object itself .Without a garbage collector , this requires locking around cache accesses , which is usually unacceptable . )", "label": "", "metadata": {}, "score": "72.38349"}
{"text": "A data processing system comprising : .A data processing method comprising : .Description .BACKGROUND OF THE INVENTION .Field of the Invention .This invention relates to an improved data retrieval system and data retrieval method which retrieve the whole or a part of a key string from a code string such as a character string .", "label": "", "metadata": {}, "score": "72.4519"}
{"text": "A data processing system comprising : .A data processing method comprising : .Description .BACKGROUND OF THE INVENTION .Field of the Invention .This invention relates to an improved data retrieval system and data retrieval method which retrieve the whole or a part of a key string from a code string such as a character string .", "label": "", "metadata": {}, "score": "72.4519"}
{"text": "39 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .FIG .40 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .", "label": "", "metadata": {}, "score": "72.47107"}
{"text": "39 shows an example of a binary tree in the sixth embodiment of this invention ( add interval ) ; .FIG .40 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .", "label": "", "metadata": {}, "score": "72.47107"}
{"text": "In some embodiments , the operation 401 interfaces with the item listing database 112 via an API such as Open Database Connectivity ( ODBC ) , Java Database Connectivity ( JDBC ) , or some other type of database API .Some embodiments may include the various databases ( e.g. , 112 ) being relational databases , or , in some cases , On - Line Analytical Processing ( OLAP ) based databases .", "label": "", "metadata": {}, "score": "72.48839"}
{"text": "In some embodiments , the operation 401 interfaces with the item listing database 112 via an API such as Open Database Connectivity ( ODBC ) , Java Database Connectivity ( JDBC ) , or some other type of database API .Some embodiments may include the various databases ( e.g. , 112 ) being relational databases , or , in some cases , On - Line Analytical Processing ( OLAP ) based databases .", "label": "", "metadata": {}, "score": "72.48839"}
{"text": "Example stochastic algorithms include : genetic algorithms , ant algorithms , tabu search algorithms , or monte carlo algorithms ( e.g. , simulated annealing ) .Common to these algorithms is the use of randomness ( e.g. , randomly generated numbers ) to avoid the problem of being unduly wedded to a local minima or maxima .", "label": "", "metadata": {}, "score": "72.49574"}
{"text": "Example stochastic algorithms include : genetic algorithms , ant algorithms , tabu search algorithms , or monte carlo algorithms ( e.g. , simulated annealing ) .Common to these algorithms is the use of randomness ( e.g. , randomly generated numbers ) to avoid the problem of being unduly wedded to a local minima or maxima .", "label": "", "metadata": {}, "score": "72.49574"}
{"text": "32(B ) is a diagram showing a \" change position \" when a character is inserted in the text in the third embodiment of this invention ; .FIG .32(C ) is a diagram showing a \" change position \" when a character is deleted in the text in the third embodiment of this invention ; .", "label": "", "metadata": {}, "score": "72.534485"}
{"text": "The following is an example of this type of code : .TABLE 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Position Data _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 0 2 0 3 0 4 N 5 N 6 0 7 0 8 0 9 0 10 1 11 1 12 1 13 1 14 1 15 1 16 0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "72.54637"}
{"text": "The following is an example of this type of code : .TABLE 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Position Data _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 0 2 0 3 0 4 N 5 N 6 0 7 0 8 0 9 0 10 1 11 1 12 1 13 1 14 1 15 1 16 0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "72.54637"}
{"text": "This node 16 referenced as 709 is connected to a node 17 referenced as 710 and a node 18 referenced as 711 .Node 17 referenced as 710 is a leaf node , such that documents 0 and 2 contain the substring \" Bottle Cap . \"", "label": "", "metadata": {}, "score": "72.57184"}
{"text": "This node 16 referenced as 709 is connected to a node 17 referenced as 710 and a node 18 referenced as 711 .Node 17 referenced as 710 is a leaf node , such that documents 0 and 2 contain the substring \" Bottle Cap . \"", "label": "", "metadata": {}, "score": "72.57184"}
{"text": "Abstract .A system for , and method of , filtering an XML document with XPath expressions and a selective data dissemination system incorporating the system or the method .A system for filtering an XML document with XPath expressions , comprising : . a tree builder that builds a document data tree for said XML document and an XPath expression tree based on substrings in said XPath expressions ; and .", "label": "", "metadata": {}, "score": "72.78694"}
{"text": "TECHNICAL FIELD .The present invention relates to query processing of textual data stored in miultidimensional data sets and , more particularly , to a method of estimating co - occurrence of query substrings across the dimensions of the data set .", "label": "", "metadata": {}, "score": "72.941574"}
{"text": "They include the entry of ranges to be output or instruction of screen scrolling .Also , input and output may be integrated into an interactive input / output operation and , through this integrated operation , the user may select , specify or identify processing to be performed .", "label": "", "metadata": {}, "score": "73.05205"}
{"text": "They include the entry of ranges to be output or instruction of screen scrolling .Also , input and output may be integrated into an interactive input / output operation and , through this integrated operation , the user may select , specify or identify processing to be performed .", "label": "", "metadata": {}, "score": "73.05205"}
{"text": "They include the entry of ranges to be output or instruction of screen scrolling .Also , input and output may be integrated into an interactive input / output operation and , through this integrated operation , the user may select , specify or identify processing to be performed .", "label": "", "metadata": {}, "score": "73.05205"}
{"text": "The trade - off with respect to the prior art is that a much larger number of cross - counts can be reconstructed in the present invention than could be stored using prior art methods , but at the loss of accuracy of the counts .", "label": "", "metadata": {}, "score": "73.102844"}
{"text": "FIG .1 is a diagram of an example system 100 illustrating a system for using search clustering .Shown is a user 101 utilizing a search interface 107 that resides on any one of a number of devices 102 .These devices 102 may include , for example , a cell phone 103 , a computer system 104 , a television 105 , and/or a Personal Digital Assistant ( PDA ) 106 .", "label": "", "metadata": {}, "score": "73.11257"}
{"text": "FIG .1 is a diagram of an example system 100 illustrating a system for using search clustering .Shown is a user 101 utilizing a search interface 107 that resides on any one of a number of devices 102 .These devices 102 may include , for example , a cell phone 103 , a computer system 104 , a television 105 , and/or a Personal Digital Assistant ( PDA ) 106 .", "label": "", "metadata": {}, "score": "73.11257"}
{"text": "Key - candidate substring Start position _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a b a b c a b 1 b a b c a b 2 a b c a b 3 b c a b 4 c a b 5 a b 6 b 7 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "73.1429"}
{"text": "claim 1 , further comprising removing the noise data identified based on the demand factor from the search queries .A computer system comprising : . at least one processor ; . a demand data engine to calculate a demand factor based on relationships of items and categories to query terms of search queries and further to identify noise data using the demand factor , the relationships established from user actions resulting from the search queries ; . a calculator to calculate a relevance score using the demand factor , the relevance score calculated , in part , based on a comparison of a similarity of a demand category histogram and a supply category histogram ; . a retrieving engine to retrieve , from a plurality of listings , item data filtered from the noise data ; . a cluster generator to construct , using the at least one processor , at least one base cluster having at least one document with common item data stored in a suffix ordering ; . a compacting engine to compact the at least one base cluster to create a compacted cluster representation having a reduced duplicate suffix ordering amongst the clusters ; and .", "label": "", "metadata": {}, "score": "73.34277"}
{"text": "claim 1 , further comprising removing the noise data identified based on the demand factor from the search queries .A computer system comprising : . at least one processor ; . a demand data engine to calculate a demand factor based on relationships of items and categories to query terms of search queries and further to identify noise data using the demand factor , the relationships established from user actions resulting from the search queries ; . a calculator to calculate a relevance score using the demand factor , the relevance score calculated , in part , based on a comparison of a similarity of a demand category histogram and a supply category histogram ; . a retrieving engine to retrieve , from a plurality of listings , item data filtered from the noise data ; . a cluster generator to construct , using the at least one processor , at least one base cluster having at least one document with common item data stored in a suffix ordering ; . a compacting engine to compact the at least one base cluster to create a compacted cluster representation having a reduced duplicate suffix ordering amongst the clusters ; and .", "label": "", "metadata": {}, "score": "73.34277"}
{"text": "The term \" machine - readable medium \" should be taken to include a single medium or multiple media ( e.g. , a centralized or distributed database , and/or associated caches and servers ) that store the one or more sets of instructions .", "label": "", "metadata": {}, "score": "73.36405"}
{"text": "The term \" machine - readable medium \" should be taken to include a single medium or multiple media ( e.g. , a centralized or distributed database , and/or associated caches and servers ) that store the one or more sets of instructions .", "label": "", "metadata": {}, "score": "73.36405"}
{"text": "Those skilled in the art should also realize that such equivalent constructions do not depart from the spirit and scope of the invention in its broadest form .BRIEF DESCRIPTION OF THE DRAWINGS .[0017 ] .For a more complete understanding of the present invention , reference is now made to the following descriptions taken in conjunction with the accompanying drawings , in which : .", "label": "", "metadata": {}, "score": "73.384895"}
{"text": "An invention according to a 14 . sup.th illustrative implementation is a data processing system of the third illustrative implementation wherein the retrieving means restores a substring based on the dictionary data and/or the text data .According to the invention of the 14 . sup.th illustrative implementation , the retrieving means restores a substring based on the dictionary data and/or the text data , eliminating the need for the substring restoring means provided separately .", "label": "", "metadata": {}, "score": "73.42585"}
{"text": "beta.x \" be a trailing string that is one character longer than x , and \" .gamma.y \" be a trailing string that is one character longer than y , respectively .TABLE 20 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( index ) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ . vertline .", "label": "", "metadata": {}, "score": "73.4265"}
{"text": "0058 ] .The Xtrie Indexing Scheme .[ 0059 ] .In this section , an Xtrie indexing scheme for filtering XML documents based on XPEs carried out according to the principles of the present invention will be introduced .Only ordered matchings will be discussed .", "label": "", "metadata": {}, "score": "73.50397"}
{"text": "An invention according to a 32 . sup.nd illustrative implementation is a data retrieval system of the 24 .According to the invention of the 32 . sup.nd illustrative implementation , the data retrieval system finds the positions of all the non - duplicating appearances of a pattern to be retrieved .", "label": "", "metadata": {}, "score": "73.661285"}
{"text": "Note that an embodiment implemented by a computer is only an example ; all or part of this invention may be packaged , if possible , on an electronic circuit such as a custom chip ( custom - made integrated circuit ) .", "label": "", "metadata": {}, "score": "73.79777"}
{"text": "Note that an embodiment implemented by a computer is only an example ; all or part of this invention may be packaged , if possible , on an electronic circuit such as a custom chip ( custom - made integrated circuit ) .", "label": "", "metadata": {}, "score": "73.79777"}
{"text": "Note that an embodiment implemented by a computer is only an example ; all or part of this invention may be packaged , if possible , on an electronic circuit such as a custom chip ( custom - made integrated circuit ) .", "label": "", "metadata": {}, "score": "73.79777"}
{"text": "In the case of a database using tables and SQL , a database application such as , for example , MYSQL \u2122 , MICROSOFT SQL SERVER \u2122 , ORACLE 8I \u2122 , 10 G \u2122 , or some other suitable database application may be used to manage the data .", "label": "", "metadata": {}, "score": "73.88713"}
{"text": "In the case of a database using tables and SQL , a database application such as , for example , MYSQL \u2122 , MICROSOFT SQL SERVER \u2122 , ORACLE 8I \u2122 , 10 G \u2122 , or some other suitable database application may be used to manage the data .", "label": "", "metadata": {}, "score": "73.88713"}
{"text": "FIG .1 illustrates the pair of PSTs for the data set : ( ab , 12 ) , ( abc , 123 ) , ( bc , 123 ) , ( ab , 23 ) .FIG . 1 ( a ) includes the PST for the alpha data dimension , and FIG . 1 ( b ) includes the PST for the numeric data dimension .", "label": "", "metadata": {}, "score": "74.1199"}
{"text": "In the dictionary tree , although \" abc \" in FIG .2 is changed to \" abb \" ( Remember that the dictionary tree does not contain a key itself ) , the pointer need not be changed because , as described above , it remain unchanged after insertion .", "label": "", "metadata": {}, "score": "74.12067"}
{"text": "-Dmytro Korduban Feb 29 ' 12 at 10:05 .4 Answers 4 .Yes , suffix trees can be used to find all common substrings .I would say to use a suffix array instead , but if you already have a suffix tree , building a suffix array from a suffix tree takes linear time by DFS .", "label": "", "metadata": {}, "score": "74.171524"}
{"text": "FIG .3 is a flowchart illustrating an example method used to execute operation 201 .Illustrated is a query 108 that is provided to an operation 301 .In cases where this operation 301 is executed , this query 108 is classified through the retrieval of a query type from a query type database 303 .", "label": "", "metadata": {}, "score": "74.187706"}
{"text": "FIG .3 is a flowchart illustrating an example method used to execute operation 201 .Illustrated is a query 108 that is provided to an operation 301 .In cases where this operation 301 is executed , this query 108 is classified through the retrieval of a query type from a query type database 303 .", "label": "", "metadata": {}, "score": "74.187706"}
{"text": "0105 ] .Algorithms . [ 0106 ] .The performance of four algorithms is compared : ( 1 ) XFilter , ( 2 ) XFilter with \" list balance \" optimization ( Altinel , et al . , supra ) , which is denoted by XFilter - LB , ( 3 ) Eager XTrie and ( 4 ) Lazy Xtrie .", "label": "", "metadata": {}, "score": "74.24135"}
{"text": "Using parsed data ( e.g. , the search terms ) from the query 108 , the application server 111 may then , for example , build a merged cluster map 113 using data stored in an item listing database 112 .The application server 111 may be operatively coupled to this item listing database 112 .", "label": "", "metadata": {}, "score": "74.27867"}
{"text": "Using parsed data ( e.g. , the search terms ) from the query 108 , the application server 111 may then , for example , build a merged cluster map 113 using data stored in an item listing database 112 .The application server 111 may be operatively coupled to this item listing database 112 .", "label": "", "metadata": {}, "score": "74.27867"}
{"text": "The first embodiment having the configuration described above performs operation as follows .[ 1 - 2 - 1 .Generating Dictionary Data And Text Data ] .The following explains the data structure used in this embodiment .Assume that the code string 1 is \" ababcab \" .", "label": "", "metadata": {}, "score": "74.331345"}
{"text": "An invention according to a 58 . sup.th illustrative implementation is a data retrieval system of the 43 . sup.rd or 49 . sup.th illustrative implementations wherein the length of a key - candidate substring constituting the index is limited .An invention according to a 59 . sup.th illustrative implementation is a data processing system of the 45 . sup.th , 47 . sup.th , 51 . sup.st or 53 . sup.rd illustrative implementations wherein the length of a key - candidate substring constituting the index is limited .", "label": "", "metadata": {}, "score": "74.4578"}
{"text": "33 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .FIG .34 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .", "label": "", "metadata": {}, "score": "74.58334"}
{"text": "33 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .FIG .34 shows an example of a binary tree in the sixth embodiment of this invention ( change interval length ) ; .", "label": "", "metadata": {}, "score": "74.58334"}
{"text": "AI structures , and the algorithms that underlie them , used to ascertain a relationship between an item and/or category and query terms fall into one of two categories : deterministic or stochastic .Some example deterministic algorithms include case - based reasoning , the aforementioned bayesian networks ( including hidden markov models ) , neural networks , or fuzzy systems .", "label": "", "metadata": {}, "score": "74.61674"}
{"text": "AI structures , and the algorithms that underlie them , used to ascertain a relationship between an item and/or category and query terms fall into one of two categories : deterministic or stochastic .Some example deterministic algorithms include case - based reasoning , the aforementioned bayesian networks ( including hidden markov models ) , neural networks , or fuzzy systems .", "label": "", "metadata": {}, "score": "74.61674"}
{"text": ", supra ; F. Fabret . H. Jacobsen , F. Llirbat , K. Ross and D. Shasha , \" Filtering Algorithms and Implementations for Very Fast Publish / Subscribe Systems , \" In Proc . of ACM SIGMOD , pages 115 - 126 , Santa Barbara , Calif. , May 2001 . ; and B. Nguyen , S. Abiteboul , G. Cobena and M. Preda , \" Monitoring XML data on the Web , \" In Proc . of ACM SIGMOD , pages 437 - 448 , Santa Barbara , Calif. , May 2001 , all incorporated herein by reference ) .", "label": "", "metadata": {}, "score": "74.68664"}
{"text": "This invention is not restricted to t he preferred embodiments described herein , but may be embodied in other specific forms , such as those described below , without departing from the spirit or essential characteristics thereof .For example , although only alphabetically - sequenced dictionary data or trees consisting of alphabetic characters are used in the above embodiments , any type of characters , such as Japanese characters or Hankul alphabet characters , may be used in a code string .", "label": "", "metadata": {}, "score": "74.68785"}
{"text": "This invention is not restricted to t he preferred embodiments described herein , but may be embodied in other specific forms , such as those described below , without departing from the spirit or essential characteristics thereof .For example , although only alphabetically - sequenced dictionary data or trees consisting of alphabetic characters are used in the above embodiments , any type of characters , such as Japanese characters or Hankul alphabet characters , may be used in a code string .", "label": "", "metadata": {}, "score": "74.68785"}
{"text": "This three - tier architecture may be implemented using one technology , or , as will be discussed below , a variety of technologies .This three - tier architecture , and the technologies through which it is implemented , may be executed on two or more computer systems organized in a server - client , peer to peer , or so some other suitable configuration .", "label": "", "metadata": {}, "score": "74.779396"}
{"text": "This three - tier architecture may be implemented using one technology , or , as will be discussed below , a variety of technologies .This three - tier architecture , and the technologies through which it is implemented , may be executed on two or more computer systems organized in a server - client , peer to peer , or so some other suitable configuration .", "label": "", "metadata": {}, "score": "74.779396"}
{"text": "Here , because both \" Xcab \" and \" XcabY \" are trailing strings , the trailing strings from which the substring \" X \" has been removed ( that is , \" cab \" and \" cabY \" ) are also trailing strings .", "label": "", "metadata": {}, "score": "74.989395"}
{"text": "First , the XTrie is designed to support effective filtering based on complex XPath expressions ( as opposed to simple , single - path specifications ) .Second , the XTrie structure and algorithms are designed to support both ordered and unordered matching of XML data .", "label": "", "metadata": {}, "score": "75.00539"}
{"text": "One piece of hardware sometimes comprises different means .For example , a computer serves as a means when executing an instruction , but serves as another means when executing another instruction .In addition , one means may be implemented by one instruction in some cases , but by a plurality of instructions in some other cases .", "label": "", "metadata": {}, "score": "75.070114"}
{"text": "One piece of hardware sometimes comprises different means .For example , a computer serves as a means when executing an instruction , but serves as another means when executing another instruction .In addition , one means may be implemented by one instruction in some cases , but by a plurality of instructions in some other cases .", "label": "", "metadata": {}, "score": "75.070114"}
{"text": "22 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .23 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .24 is a diagram showing the data structure in the second embodiment of this invention ; .", "label": "", "metadata": {}, "score": "75.12076"}
{"text": "Upon the completion and the execution of operation 301 , an operation 302 is executed .Through the execution of this operation 302 , an HTTP call is generated that includes the query classification information taken or received from the operation 301 .", "label": "", "metadata": {}, "score": "75.346245"}
{"text": "Upon the completion and the execution of operation 301 , an operation 302 is executed .Through the execution of this operation 302 , an HTTP call is generated that includes the query classification information taken or received from the operation 301 .", "label": "", "metadata": {}, "score": "75.346245"}
{"text": "According to the data retrieval system of the 26 . sup.th illustrative implementation and the data retrieval method of the 27 .An invention according to a 28 . sup.th illustrative implementation is a data retrieval system of the 24 . sup.th illustrative implementation wherein the length of a key - candidate substring constituting the dictionary data is limited .", "label": "", "metadata": {}, "score": "75.38094"}
{"text": "Additionally , this node 5 , labeled here as 504 , may be linked to a node 6 labeled as 505 via an edge labeled as \" Bottle . \"Moreover , this node 6 , labeled here as 50 , may be linked to a node 7 labeled herein as 506 via an edge titled \" Opener . \"", "label": "", "metadata": {}, "score": "75.38544"}
{"text": "Additionally , this node 5 , labeled here as 504 , may be linked to a node 6 labeled as 505 via an edge labeled as \" Bottle . \"Moreover , this node 6 , labeled here as 50 , may be linked to a node 7 labeled herein as 506 via an edge titled \" Opener . \"", "label": "", "metadata": {}, "score": "75.38544"}
{"text": "An invention according to a tenth illustrative implementation is a data processing system of the third illustrative implementation , wherein at least one of the dictionary data generating means and text data generating means establishes pointers between the dictionary data and text data .", "label": "", "metadata": {}, "score": "75.44733"}
{"text": "5 .Further , a position 603 in a hash table 600 contains the substring \" Cap \" and the set of documents containing the substring \" Pepsi Cola Bottle Cap , \" which in this case is the set containing the document labeled as 0 .", "label": "", "metadata": {}, "score": "75.62378"}
{"text": "5 .Further , a position 603 in a hash table 600 contains the substring \" Cap \" and the set of documents containing the substring \" Pepsi Cola Bottle Cap , \" which in this case is the set containing the document labeled as 0 .", "label": "", "metadata": {}, "score": "75.62378"}
{"text": "Further , connected to the node 2 , referenced as 702 , is a node 4 referenced as 704 where an edge labeled \" Bottle \" connects node 2 and node 4 .Moreover , a node 7 referenced as 705 is also connected to the node 2 referenced as 702 via an edge labeled as \" Lighter .", "label": "", "metadata": {}, "score": "76.25108"}
{"text": "Further , connected to the node 2 , referenced as 702 , is a node 4 referenced as 704 where an edge labeled \" Bottle \" connects node 2 and node 4 .Moreover , a node 7 referenced as 705 is also connected to the node 2 referenced as 702 via an edge labeled as \" Lighter .", "label": "", "metadata": {}, "score": "76.25108"}
{"text": "Lower limit 1 . fwdarw .b c a b c a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "76.42115"}
{"text": "CROSS REFERENCE TO RELATED APPLICATIONS .TECHNICAL FIELD .The present application relates generally to the technical field of search algorithms and , in one specific example , the generation of a searchable data structure .BACKGROUND .In many cases , the success of a search algorithm is tied to the data structure that is being searched , and more specifically the organization of this data structure .", "label": "", "metadata": {}, "score": "76.430305"}
{"text": "CROSS REFERENCE TO RELATED APPLICATIONS .TECHNICAL FIELD .The present application relates generally to the technical field of search algorithms and , in one specific example , the generation of a searchable data structure .BACKGROUND .In many cases , the success of a search algorithm is tied to the data structure that is being searched , and more specifically the organization of this data structure .", "label": "", "metadata": {}, "score": "76.430305"}
{"text": "3 illustrates an exemplary XPath expression tree ; . [ 0021 ] .[ 0021]FIG .4 illustrates an exemplary SEARCH software algorithm to search an XPath expression tree ; .[ 0022 ] .[ 0022]FIG .5 illustrates an exemplary MATCH - SUBSTRING software algorithm to process a matched substring ; .", "label": "", "metadata": {}, "score": "76.56413"}
{"text": "Example methods and systems to facilitate video mail in a peer to peer network are illustrated .In the following description , for purposes of explanation , numerous specific details are set forth in order to provide a thorough understanding of example embodiments .", "label": "", "metadata": {}, "score": "76.68265"}
{"text": "Example methods and systems to facilitate video mail in a peer to peer network are illustrated .In the following description , for purposes of explanation , numerous specific details are set forth in order to provide a thorough understanding of example embodiments .", "label": "", "metadata": {}, "score": "76.68265"}
{"text": "alpha . gamma .A data retrieval method comprising the steps of : . generating said index , .A data processing method comprising the steps of : . updating , based on a change to said code string , an index of said code string associated with the change , .", "label": "", "metadata": {}, "score": "76.94778"}
{"text": "28 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .29 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .30 is a functional block diagram showing the configuration of the third embodiment of this invention ; .", "label": "", "metadata": {}, "score": "76.98825"}
{"text": "Illustrated at position 601 in the hash table is the substring \" Lighter .\" This substring may roughly correspond to , for example , the node 13 referenced as 508 in .FIG .5 .Adjacent to this position 601 is a position 602 that contains the substring \" Bottle \" wherein this substring \" Bottle \" roughly corresponds to the node 14 referenced as 510 in .", "label": "", "metadata": {}, "score": "77.04817"}
{"text": "Illustrated at position 601 in the hash table is the substring \" Lighter .\" This substring may roughly correspond to , for example , the node 13 referenced as 508 in .FIG .5 .Adjacent to this position 601 is a position 602 that contains the substring \" Bottle \" wherein this substring \" Bottle \" roughly corresponds to the node 14 referenced as 510 in .", "label": "", "metadata": {}, "score": "77.04817"}
{"text": "Note that , in this case , characters are retrieved with a key string from end to start .[ Effect of invention ] .As described above , this invention provides an efficient data processing system , a data retrieval system , data processing method , and data retrieval method .", "label": "", "metadata": {}, "score": "77.139435"}
{"text": "According to the invention of the 35 . sup.th illustrative implementation , the data processing system does not compare the common leading string but starts comparing the codes immediately after the last common character , increasing code string comparison efficiency .An invention according to a 36 . sup.th illustrative implementation is a data processing system of the 33 .", "label": "", "metadata": {}, "score": "77.1731"}
{"text": "The following shows the contents of the dictionary and text : .[ TABLE 6 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Text ) a b a b c a b 1 2 3 4 5 6 7 ( Dictionary )", "label": "", "metadata": {}, "score": "77.179924"}
{"text": "The present invention therefore introduces a novel index structure , termed XTrie , that supports the efficient filtering of XML documents based on XPath expressions .The XTrie index structure offers several novel features that make it especially attractive for large - scale publish / subscribe systems .", "label": "", "metadata": {}, "score": "77.21667"}
{"text": "The XTrie Matching Algorithm .[ 0077 ] .The XTrie indexing scheme is designed to support on - line filtering of streaming XML data and is based on the SAX event - based interface that reports parsing events .FIG .", "label": "", "metadata": {}, "score": "77.397415"}
{"text": "26 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) FIG .27 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) ; .FIG .", "label": "", "metadata": {}, "score": "77.437485"}
{"text": "26 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) FIG .27 shows an example of a binary tree in the sixth embodiment of this invention ( retrieval ) ; .FIG .", "label": "", "metadata": {}, "score": "77.437485"}
{"text": "First , XTrie is designed to support effective filtering based on complex XPath expressions ( as opposed to simple , single - path specifications ) .Second , the XTrie structure and algorithms are designed to support both ordered and unordered matching of XML data .", "label": "", "metadata": {}, "score": "77.54473"}
{"text": "Titles , as entered by users , have high degree of variability .For example , for any single phrase / item we can have a large number of variations in occurrence location in the title along with the combination of noise words like adjectives and prepositions .", "label": "", "metadata": {}, "score": "77.55216"}
{"text": "Titles , as entered by users , have high degree of variability .For example , for any single phrase / item we can have a large number of variations in occurrence location in the title along with the combination of noise words like adjectives and prepositions .", "label": "", "metadata": {}, "score": "77.55216"}
{"text": "All the algorithms were implemented in C++ and compiled using GNU C++ version 2.95.3 .Experiments were conducted on a Sun Ultra-250 with 512 MB of main memory running Solaris 2.7 .All the index structures were resident in main - memory for all the experiments .", "label": "", "metadata": {}, "score": "77.97493"}
{"text": "47 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .48 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "78.02475"}
{"text": "47 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .48 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "78.02475"}
{"text": "As stated above , the present invention is directed , among other things , to a novel index structure , termed \" XTrie , \" that supports the efficient filtering of XML documents based on XPath expressions .The XTrie index structure offers several novel features that make it especially attractive for large - scale publish / subscribe systems .", "label": "", "metadata": {}, "score": "78.0396"}
{"text": "While embodiments of the present invention have been described above , it is to be understood that modifications and variations will occur to those skilled in the art without departing from the spirit of the invention as clarified by the appended claims .", "label": "", "metadata": {}, "score": "78.13378"}
{"text": "While embodiments of the present invention have been described above , it is to be understood that modifications and variations will occur to those skilled in the art without departing from the spirit of the invention as clarified by the appended claims .", "label": "", "metadata": {}, "score": "78.13378"}
{"text": "Additionally , this application server 110 may be connected to a plurality of item listing databases in addition to item listing database 112 .Further , though not depicted , this application server 111 and/or a plurality of application servers may be operatively coupled to any one of a number of database servers that may serve as an intermediary between the application server 111 and databases such as the item listing database 112 .", "label": "", "metadata": {}, "score": "78.20801"}
{"text": "Additionally , this application server 110 may be connected to a plurality of item listing databases in addition to item listing database 112 .Further , though not depicted , this application server 111 and/or a plurality of application servers may be operatively coupled to any one of a number of database servers that may serve as an intermediary between the application server 111 and databases such as the item listing database 112 .", "label": "", "metadata": {}, "score": "78.20801"}
{"text": "An invention according to a 64 . sup.th illustrative implementation is a data processing system of the 59 . sup.th illustrative implementation wherein the index is represented by a binary tree .An invention according to a 65 . sup.th illustrative implementation is a data processing system of the 61 . sup.st illustrative implementation wherein the index is represented by a binary tree .", "label": "", "metadata": {}, "score": "78.524"}
{"text": "An invention according to a 75 . sup.th illustrative implementation is a data processing method of the 34 .According to the invention of the 75 .An invention according to a 76 . sup.th illustrative implementation is a data processing method of the 34 . sup.th illustrative implementation wherein , when registering the leading string of the trailing string . alpha.w in a table arranged lexicographically with the leading string of the trailing string as the key , said registering step registers the leading string of . alpha.w immediately after the leading string of .", "label": "", "metadata": {}, "score": "78.536865"}
{"text": "The accuracy of log N ( 18 ) bits and 32 bits is shown as being very close .However , the accuracy of the 16 bit space size is much worse .This is intuitive since there are over 200,000 tuples in this data set and 16 bits are not enough to represent that many tuples , resulting in a large number of collisions .", "label": "", "metadata": {}, "score": "78.59378"}
{"text": "( 1 ) When . alpha . beta . , . alpha.w is registered immediately after . beta.x .( 2 ) When . alpha .gamma . , . alpha.w is registered immediately before .gamma.y .( 3 ) When . delta .", "label": "", "metadata": {}, "score": "78.630264"}
{"text": "Cluster Exapansion .In some embodiments , the STC algorithm takes into account the order of the phrases when base clusters are formed .For example , for a base cluster \" ipod nano \" only those items that have the exact phrase \" ipod nano \" in the same order are included in the clustering .", "label": "", "metadata": {}, "score": "78.727646"}
{"text": "Cluster Exapansion .In some embodiments , the STC algorithm takes into account the order of the phrases when base clusters are formed .For example , for a base cluster \" ipod nano \" only those items that have the exact phrase \" ipod nano \" in the same order are included in the clustering .", "label": "", "metadata": {}, "score": "78.727646"}
{"text": "The following explains , with the use of an example , how retrieval is performed .In the example , the code string \" bac \" is retrieved .[ TABLE 15 ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", "label": "", "metadata": {}, "score": "78.96561"}
{"text": "This time , \" c \" does not affect the lexicographic order between the index item and each adjacent item .Therefore , the index item is judged not to be re - arranged .As shown in FIG .46 , both \" babcab and \" ababcab \" are determined that \" they need not be re - arranged .", "label": "", "metadata": {}, "score": "79.229034"}
{"text": "Gather the demand data for the query q , both the contained and related queries of q ; .Gather the attribute data for all the search results of query q ; .Remove from the set of collected words common noise words like \" Sealed \" , \" amazing \" ; .", "label": "", "metadata": {}, "score": "79.43192"}
{"text": "Gather the demand data for the query q , both the contained and related queries of q ; .Gather the attribute data for all the search results of query q ; .Remove from the set of collected words common noise words like \" Sealed \" , \" amazing \" ; .", "label": "", "metadata": {}, "score": "79.43192"}
{"text": "This contradicts the preposition that \" cab does not require the whole trailing string to be compared \" .This contradiction results from the assumption that the trailing string \" Xcab \" which is longer than \" cab \" requires the whole trailing string to be compared .", "label": "", "metadata": {}, "score": "79.46653"}
{"text": "As shown , the position of the item \" cab \" and the position of the changed item \" cca \" have been changed in Table 3 .( In Table 2 , \" cab \" is the seventh item and \" bca \" is the sixth item ) .", "label": "", "metadata": {}, "score": "79.48828"}
{"text": "45 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .46 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "79.71565"}
{"text": "45 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .46 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "79.71565"}
{"text": "37 is a diagram showing the operation of the sixth embodiment of this invention ; .FIG .38 is a diagram showing the operation of the sixth embodiment of this invention ; .FIG .39 is a functional block diagram showing the configuration of the seventh embodiment of this invention ; .", "label": "", "metadata": {}, "score": "79.80518"}
{"text": "The system 700 includes a document receiver 710 .The document receiver 710 is adapted to receive XML documents from a plurality of publishers ( not shown ) .The system 700 further includes a subscription receiver 720 .The subscription receiver 720 is adapted to receive words of interest from a plurality of subscribers ( not shown ) .", "label": "", "metadata": {}, "score": "80.52841"}
{"text": "The software may also reside , completely or at least partially , within the main memory 1701 and/or within the processor 1702 during execution thereof by the computer system 1700 , the main memory 1701 and the processor 1702 also constituting machine - readable media .", "label": "", "metadata": {}, "score": "80.56842"}
{"text": "The software may also reside , completely or at least partially , within the main memory 1701 and/or within the processor 1702 during execution thereof by the computer system 1700 , the main memory 1701 and the processor 1702 also constituting machine - readable media .", "label": "", "metadata": {}, "score": "80.56842"}
{"text": "DELTA.p is immediately before .gamma.y , and when .DELTA . alpha .gamma . , . alpha.w is registered immediately before .gamma.y .( 6 ) When .phi.q is immediately after .gamma.y , and when . gamma . alpha . phi .", "label": "", "metadata": {}, "score": "80.79745"}
{"text": "However , this method has the following problems : .( 1 ) Data occupies as many locations as there are code values , degrading the memory efficiency .In particular , when there are many codes of the same value , the memory is wasted .", "label": "", "metadata": {}, "score": "80.88054"}
{"text": "Protect your idea and hire a patent lawyer .Data processing system , data retrieval system , data processing method and data retrieval method .Abstract .A data processing system , a data retrieval system , a data processing method , and a data retrieval method requiring less time to update data to be used in retrieval .", "label": "", "metadata": {}, "score": "80.9928"}
{"text": "In recent years , a new suite of services ( such as LDAP directory services ) , standards ( such as XML ) , and applications ( such as E - commerce ) have emerged , due at least in part to the proliferation of the Internet .", "label": "", "metadata": {}, "score": "81.14653"}
{"text": "26 , ( ab ) and ( c ) are addresses or pointers which are coded as \" ab \" and \" c \" , respectively ( or which contain codes \" ab \" and \" c \" in their addresses or pointers ) .", "label": "", "metadata": {}, "score": "81.157196"}
{"text": "43 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .44 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "81.31013"}
{"text": "43 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .FIG .44 shows an example of a binary tree in the sixth embodiment of this invention ( adjust structure ) ; .", "label": "", "metadata": {}, "score": "81.31013"}
{"text": "41 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .FIG .42 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .", "label": "", "metadata": {}, "score": "81.46677"}
{"text": "41 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .FIG .42 shows an example of a binary tree in the sixth embodiment of this invention ( delete interval ) ; .", "label": "", "metadata": {}, "score": "81.46677"}
{"text": "25 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .26 is a diagram showing the data structure in the second embodiment of this invention ; .FIG .27 is a diagram showing the data structure in the second embodiment of this invention ; .", "label": "", "metadata": {}, "score": "81.57805"}
{"text": "alpha . gamma .A data retrieval system comprising : . index generating means for generating said index , .A data processing system comprising : . updating means for updating , based on a change to said code string , an index of said code string associated with the change , .", "label": "", "metadata": {}, "score": "81.74099"}
{"text": "Marketplace Applications .A commercial website may have thousands , if not millions , of item descriptions ( e.g. , item data ) .These descriptions may include title information , advertisement information , and other information generated to illustrate and categorize an item for sale on a website .", "label": "", "metadata": {}, "score": "81.74228"}
{"text": "Marketplace Applications .A commercial website may have thousands , if not millions , of item descriptions ( e.g. , item data ) .These descriptions may include title information , advertisement information , and other information generated to illustrate and categorize an item for sale on a website .", "label": "", "metadata": {}, "score": "81.74228"}
{"text": "70 ( a ) is a diagram showing one type of rebalancing ( promotion ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .FIG .70( b ) is a diagram showing one type of rebalancing ( single rotation ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "81.761765"}
{"text": "70 ( a ) is a diagram showing one type of rebalancing ( promotion ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .FIG .70( b ) is a diagram showing one type of rebalancing ( single rotation ) when condition 2 is not satisfied in the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "81.761765"}
{"text": "According to the invention as claimed in claim 11 , the updating means adds and then deletes data during update .This invention allows some data pieces to be made available , if they can still be used , even after the update , making the update time less than when data is first deleted and then added .", "label": "", "metadata": {}, "score": "81.83817"}
{"text": "According to the invention as claimed in claim 11 , the updating means adds and then deletes data during update .This invention allows some data pieces to be made available , if they can still be used , even after the update , making the update time less than when data is first deleted and then added .", "label": "", "metadata": {}, "score": "81.83817"}
{"text": "It is a further object of this invention to provide a data processing system and a data processing method which process data efficiently .This data processing system and data processing method are particularly suitable for implementing the above described data retrieval system and data retrieval method .", "label": "", "metadata": {}, "score": "81.97297"}
{"text": "It is a further object of this invention to provide a data processing system and a data processing method which process data efficiently .This data processing system and data processing method are particularly suitable for implementing the above described data retrieval system and data retrieval method .", "label": "", "metadata": {}, "score": "81.97297"}
{"text": "So , formula 15 given above is used to change the partial interval length .( c ) Double rotation is equivalent to double rotation ( zig - zag ) in this invention .So , formula 17 given above is used to change the partial interval length .", "label": "", "metadata": {}, "score": "82.13332"}
{"text": "So , formula 15 given above is used to change the partial interval length .( c ) Double rotation is equivalent to double rotation ( zig - zag ) in this invention .So , formula 17 given above is used to change the partial interval length .", "label": "", "metadata": {}, "score": "82.13332"}
{"text": "In the dictionary data used this embodiment , the length of a key - candidate substring in the index ( dictionary ) is not limited .For example , for the code string 1 \" ababcab \" , there are seven trailing strings ( ababcab , babcab , abcab , bcab , cab , ab , b ) .", "label": "", "metadata": {}, "score": "82.179214"}
{"text": "8A with 500,000 XPEs , XTrie required approximately 18 MB of memory , while XFilter required 26 MB . [0115 ] .Conclusions .[ 0116 ] .From the above , it is apparent that XTrie supports the efficient filtering of streaming XML documents based on XPath expressions .", "label": "", "metadata": {}, "score": "82.574295"}
{"text": "For this text , the leading string ( abab ) of one of trailing strings ( ababab ) is another trailing string ( abab ) of the text .In this case , most characters of a key - candidate substring are used for comparison .", "label": "", "metadata": {}, "score": "82.75226"}
{"text": "An invention according to a 62 . sup.nd illustrative implementation is a data processing system of the 53 . sup.rd illustrative implementation wherein the pairs in the index and the pairs in the text are integrated .An invention according to a 63 . sup.rd illustrative implementation is a data retrieval system of the 49 . sup.th illustrative implementation wherein the pairs in the index and the pairs in the text are integrated .", "label": "", "metadata": {}, "score": "82.96666"}
{"text": "It is an object of this invention to provide a data retrieval system and a data retrieval method which update data speedily .It is another object of this invention to provide a data retrieval system and a data retrieval method which allow us to retrieve data from a simply - structured data or with a simple procedure .", "label": "", "metadata": {}, "score": "83.23526"}
{"text": "It is an object of this invention to provide a data retrieval system and a data retrieval method which update data speedily .It is another object of this invention to provide a data retrieval system and a data retrieval method which allow us to retrieve data from a simply - structured data or with a simple procedure .", "label": "", "metadata": {}, "score": "83.23526"}
{"text": "This position 805 contains the substring \" Cap \" and additionally references document 0 as a document that contains the substring \" Pepsi Cola Bottle Cap . \" At position 806 which roughly corresponds to node 6 referenced as 707 is the substring \" Opener . \"", "label": "", "metadata": {}, "score": "84.58266"}
{"text": "This position 805 contains the substring \" Cap \" and additionally references document 0 as a document that contains the substring \" Pepsi Cola Bottle Cap . \" At position 806 which roughly corresponds to node 6 referenced as 707 is the substring \" Opener . \"", "label": "", "metadata": {}, "score": "84.58266"}
{"text": "More experimental results are given in ( Altinel , et al . , supra ) .[0114 ] .Memory usage of both XTrie and XFilter are also compared ; the experimental results indicate that XTrie is more space efficient .", "label": "", "metadata": {}, "score": "84.9461"}
{"text": "Performing double rotation ( zig - zig ) on the binary tree 31 in FIG .45 results in the binary tree 31 shown in FIG .46 .Performing double rotation ( zig - zag ) on the binary tree 31 in FIG .", "label": "", "metadata": {}, "score": "84.95381"}
{"text": "Performing double rotation ( zig - zig ) on the binary tree 31 in FIG .45 results in the binary tree 31 shown in FIG .46 .Performing double rotation ( zig - zag ) on the binary tree 31 in FIG .", "label": "", "metadata": {}, "score": "84.95381"}
{"text": "[ 0086 ] .This section will be concluded by briefly describing an optimized variant of XTrie , which will be referred to as \" Lazy Xtrie .\"Thus , Lazy XTrie minimizes the number of unnecessary index probes at the expense of a slightly higher cost for each probe due to the additional processing required to check for matchings of the ancestor substrings of the matched leaf substring .", "label": "", "metadata": {}, "score": "85.28731"}
{"text": "And an invention according to a 54 .According to the data processing system of the 53 . sup.rd illustrative implementation and the data processing method of the 54 .An invention according to a 55 . sup.th illustrative implementation is a data retrieval system of the 43 . sup.rd or 49 .", "label": "", "metadata": {}, "score": "85.40495"}
{"text": "5 .At position 606 , the substring \" Bank \" is contained wherein the substring \" Pepsi Cola Coin Bank \" is contained in documents 3 and 0 .This substring \" Bank \" roughly corresponds to node 19 referenced as 514 .", "label": "", "metadata": {}, "score": "85.54752"}
{"text": "5 .At position 606 , the substring \" Bank \" is contained wherein the substring \" Pepsi Cola Coin Bank \" is contained in documents 3 and 0 .This substring \" Bank \" roughly corresponds to node 19 referenced as 514 .", "label": "", "metadata": {}, "score": "85.54752"}
{"text": "Easy To Use Patents Search & Patent Lawyer Directory .At Patents you can conduct a Patent Search , File a Patent Application , find a Patent Attorney , or search available technology through our Patent Exchange .Patents are available using simple keyword or date criteria .", "label": "", "metadata": {}, "score": "86.057785"}
{"text": "For example , an operation 203 may be executed wherein a demand data engine is executed and returns demand data to the operation 204 .Further , operations 206 and 205 are executed wherein operation 206 provides merged threshold data to the operation 205 .", "label": "", "metadata": {}, "score": "86.69658"}
{"text": "For example , an operation 203 may be executed wherein a demand data engine is executed and returns demand data to the operation 204 .Further , operations 206 and 205 are executed wherein operation 206 provides merged threshold data to the operation 205 .", "label": "", "metadata": {}, "score": "86.69658"}
{"text": "Calculation for rotation is performed as follows .Calculation for double rotation ( zig - zig ) is performed as follows .Calculation for double rotation ( zig - zag ) is performed as follows .The partial interval length may also be calculated after the net interval length of X , Y , and Z are calculated .", "label": "", "metadata": {}, "score": "86.82062"}
{"text": "Calculation for rotation is performed as follows .Calculation for double rotation ( zig - zig ) is performed as follows .Calculation for double rotation ( zig - zag ) is performed as follows .The partial interval length may also be calculated after the net interval length of X , Y , and Z are calculated .", "label": "", "metadata": {}, "score": "86.82062"}
{"text": "FIG .55 is a diagram showing the binary tree in FIG .54 to which double rotation ( zig - zag ) has been applied in the sixth embodiment of this invention ; .FIG .56 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "86.94257"}
{"text": "FIG .55 is a diagram showing the binary tree in FIG .54 to which double rotation ( zig - zag ) has been applied in the sixth embodiment of this invention ; .FIG .56 is a diagram showing the binary tree in FIG .", "label": "", "metadata": {}, "score": "86.94257"}
{"text": "A computer of any size , for example , a microcomputer , personal computer , small computer , workstation , or mainframe computer may be used .Typically , the computer has input devices such as a keyboard and a mouse , external storage units such as a hard disk , output devices such as a CRT display or a printer , and other required input / output control circuits .", "label": "", "metadata": {}, "score": "87.07074"}
{"text": "A computer of any size , for example , a microcomputer , personal computer , small computer , workstation , or mainframe computer may be used .Typically , the computer has input devices such as a keyboard and a mouse , external storage units such as a hard disk , output devices such as a CRT display or a printer , and other required input / output control circuits .", "label": "", "metadata": {}, "score": "87.07074"}
{"text": "A computer of any size , for example , a microcomputer , personal computer , small computer , workstation , or mainframe computer may be used .Typically , the computer has input devices such as a keyboard and a mouse , external storage units such as a hard disk , output devices such as a CRT display or a printer , and other required input / output control circuits .", "label": "", "metadata": {}, "score": "87.07074"}
{"text": "34 is a diagram showing the operation of the fourth embodiment of this invention ; .FIG .35 is a functional block diagram showing the configuration of the fifth embodiment of this invention ; .FIG .36 is a functional block diagram showing the configuration of the sixth embodiment of this invention ; .", "label": "", "metadata": {}, "score": "89.4804"}
{"text": "Node 5 referenced as 706 is a leaf node such that document 0 contains the substring \" Pepsi Cola Bottle Cap . \"Also , node 6 referenced as 707 is a leaf node such that documents 0 , 1 , and 4 contain the substring \" Pepsi Cola Bottle Opener . \" Compacted suffix tree 700 contains a number of other subtrees .", "label": "", "metadata": {}, "score": "89.99608"}
{"text": "Node 5 referenced as 706 is a leaf node such that document 0 contains the substring \" Pepsi Cola Bottle Cap . \"Also , node 6 referenced as 707 is a leaf node such that documents 0 , 1 , and 4 contain the substring \" Pepsi Cola Bottle Opener . \" Compacted suffix tree 700 contains a number of other subtrees .", "label": "", "metadata": {}, "score": "89.99608"}
{"text": "TABLE 19 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( Existing index )", "label": "", "metadata": {}, "score": "90.77939"}
{"text": "\" The leaf node ( e.g. , 506 ) also contains a reference to the set of documents containing item data that contain the substring \" Pepsi Cola Bottle Opener . \"Specifically , documents 4 and 0 contain this substring .", "label": "", "metadata": {}, "score": "91.59415"}
{"text": "\" The leaf node ( e.g. , 506 ) also contains a reference to the set of documents containing item data that contain the substring \" Pepsi Cola Bottle Opener . \"Specifically , documents 4 and 0 contain this substring .", "label": "", "metadata": {}, "score": "91.59415"}
{"text": "An invention according to a 24 .And an invention according to a 25 .According to the data retrieval system of the 24 . sup.th illustrative implementation and the data retrieval method of the 25 .An invention according to a 26 .", "label": "", "metadata": {}, "score": "91.873146"}
{"text": "At position 608 , the substring \" Pepsi \" is contained wherein the substring \" Pepsi \" roughly corresponds to node 4 referenced as 503 .Additionally , at position 609 , the substring \" Cola \" is shown wherein this substring roughly corresponds to node 5 referenced as 504 .", "label": "", "metadata": {}, "score": "92.09366"}
{"text": "At position 608 , the substring \" Pepsi \" is contained wherein the substring \" Pepsi \" roughly corresponds to node 4 referenced as 503 .Additionally , at position 609 , the substring \" Cola \" is shown wherein this substring roughly corresponds to node 5 referenced as 504 .", "label": "", "metadata": {}, "score": "92.09366"}
{"text": "An invention according to a 56 . sup.th illustrative implementation is a data processing system of the 45 . sup.th or 51 .According to the invention of the 56 .An invention according to a 57 . sup.th illustrative implementation is a data processing system of the 47 . sup.th or 53 .", "label": "", "metadata": {}, "score": "92.2011"}
{"text": "beta.x , and when . beta . alpha . delta . , . alpha.w is registered immediately after . beta.x .( 4 ) When . epsilon.t is immediately before .beta.x , and when . epsilon .alpha . beta . , . alpha.w is registered immediately before . beta.x .", "label": "", "metadata": {}, "score": "93.388504"}
{"text": "FIG .8 is a diagram illustrating an example hash table 800 used to store base clusters of documents .Illustrated is a position 801 that roughly corresponds to node 2 referenced as 702 .Contained within this position 801 is a substring \" Pepsi Cola . \"", "label": "", "metadata": {}, "score": "93.43944"}
{"text": "FIG .8 is a diagram illustrating an example hash table 800 used to store base clusters of documents .Illustrated is a position 801 that roughly corresponds to node 2 referenced as 702 .Contained within this position 801 is a substring \" Pepsi Cola . \"", "label": "", "metadata": {}, "score": "93.43944"}
{"text": "The substring opener associated with node 20 may be contained in documents 1 and 4 .Also connected to node 4 ( e.g. , 904 ) is a node 2 referenced as 905 and a node 8 referenced as 906 .With regard to node 2 , a substring \" Pepsi Cola \" is associated with this node 2 wherein the substring is contained in documents 0 , 1 , 2 , 3 , and 4 .", "label": "", "metadata": {}, "score": "94.45628"}
{"text": "The substring opener associated with node 20 may be contained in documents 1 and 4 .Also connected to node 4 ( e.g. , 904 ) is a node 2 referenced as 905 and a node 8 referenced as 906 .With regard to node 2 , a substring \" Pepsi Cola \" is associated with this node 2 wherein the substring is contained in documents 0 , 1 , 2 , 3 , and 4 .", "label": "", "metadata": {}, "score": "94.45628"}
{"text": "Other external storage devices ( floppy disk device , RAM card reader , magnetic tape device , optical disk device , magneto - optical ( MO ) disk device , bubble memory device , and flash memory card ) may be used .", "label": "", "metadata": {}, "score": "96.81887"}
{"text": "Other external storage devices ( floppy disk device , RAM card reader , magnetic tape device , optical disk device , magneto - optical ( MO ) disk device , bubble memory device , and flash memory card ) may be used .", "label": "", "metadata": {}, "score": "96.81887"}
{"text": "Other external storage devices ( floppy disk device , RAM card reader , magnetic tape device , optical disk device , magneto - optical ( MO ) disk device , bubble memory device , and flash memory card ) may be used .", "label": "", "metadata": {}, "score": "96.81887"}
{"text": "\" If most users clicked on \" dell laptop d410 , \" then d410 would be more relevant and the terms bags , batteries , and cases would be less relevant .And again , if , for example , we were to search for \" Persian rugs , \" a table could be generated containing a list of words with assigned weighting : .", "label": "", "metadata": {}, "score": "97.09923"}
{"text": "\" If most users clicked on \" dell laptop d410 , \" then d410 would be more relevant and the terms bags , batteries , and cases would be less relevant .And again , if , for example , we were to search for \" Persian rugs , \" a table could be generated containing a list of words with assigned weighting : .", "label": "", "metadata": {}, "score": "97.09923"}
{"text": "super . tabriz . turquoise .vintage .white . wool . xmas .In the above table , the column on the left displays the clusters when the demand data is not taken into account , while the column on the right displays the clusters when demand data is taken into account .", "label": "", "metadata": {}, "score": "97.14028"}
{"text": "super . tabriz . turquoise .vintage .white . wool . xmas .In the above table , the column on the left displays the clusters when the demand data is not taken into account , while the column on the right displays the clusters when demand data is taken into account .", "label": "", "metadata": {}, "score": "97.14028"}
{"text": "In a distributed system environment , program modules may be located in both local and remote memory - storage devices ( see below ) .The computer system 1700 may further include a video display unit 1710 ( e.g. , a Liquid Crystal Display ( LCD ) or a Cathode Ray Tube ( CRT ) ) .", "label": "", "metadata": {}, "score": "97.60637"}
{"text": "In a distributed system environment , program modules may be located in both local and remote memory - storage devices ( see below ) .The computer system 1700 may further include a video display unit 1710 ( e.g. , a Liquid Crystal Display ( LCD ) or a Cathode Ray Tube ( CRT ) ) .", "label": "", "metadata": {}, "score": "97.60637"}
{"text": "When comparing the new trailing string \" bababcab \" with \" babcab \" already registered in the index , the relation between \" ababcab \" and \" abcab \" already registered in the index is used .That is , as shown in Table 19 , when the leftmost character \" b \" is removed from the new trailing string \" bababcab \" and from \" babcab \" already registered in the index , \" 2 . ababcab \" and \" 3 . abcab \" already registered in the index are generated .", "label": "", "metadata": {}, "score": "100.16125"}
{"text": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Formula 51 !_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", "label": "", "metadata": {}, "score": "101.17173"}
{"text": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Formula 51 !_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", "label": "", "metadata": {}, "score": "101.17173"}
{"text": "In some embodiments , the demand factor indicates what buyers search for and click on based upon the search query .This factor may , for example , be applied during the filtering of noise data .Consider the following item listings : . \" STUNNING BLING SWAROVSKI CRYSTALS 4 GB 4 GB IPOD NANO \" ; . \"", "label": "", "metadata": {}, "score": "101.273026"}
{"text": "In some embodiments , the demand factor indicates what buyers search for and click on based upon the search query .This factor may , for example , be applied during the filtering of noise data .Consider the following item listings : . \" STUNNING BLING SWAROVSKI CRYSTALS 4 GB 4 GB IPOD NANO \" ; . \"", "label": "", "metadata": {}, "score": "101.273026"}
{"text": "Silver .Beautiful .Rugs .In the above table , outlines query relevance weights for the query \" Persian Rugs .\" Terms with weight less than 0.5 may be considered irrelevant .Additionally , from the above table various conclusions can be drawn .", "label": "", "metadata": {}, "score": "101.79401"}
{"text": "Silver .Beautiful .Rugs .In the above table , outlines query relevance weights for the query \" Persian Rugs .\" Terms with weight less than 0.5 may be considered irrelevant .Additionally , from the above table various conclusions can be drawn .", "label": "", "metadata": {}, "score": "101.79401"}
{"text": "Assuming an efficient market , the \" buy it now \" price may be a reasonable price for that item .Applied to the clustering context , assume we have a cluster that is solely related to \" ipod nano 4 gb black .", "label": "", "metadata": {}, "score": "103.1038"}
{"text": "Assuming an efficient market , the \" buy it now \" price may be a reasonable price for that item .Applied to the clustering context , assume we have a cluster that is solely related to \" ipod nano 4 gb black .", "label": "", "metadata": {}, "score": "103.1038"}
{"text": "Further , shown is a position 803 that roughly corresponds to node 7 referenced as 705 and , more specifically , the documents 1 and 2 that contain the substring \" Pepsi Cola Lighter . \"Additionally a position 804 is illustrated that roughly corresponds to node 4 referenced as 704 that contains the substring \" Bottle .", "label": "", "metadata": {}, "score": "103.238235"}
{"text": "Further , shown is a position 803 that roughly corresponds to node 7 referenced as 705 and , more specifically , the documents 1 and 2 that contain the substring \" Pepsi Cola Lighter . \"Additionally a position 804 is illustrated that roughly corresponds to node 4 referenced as 704 that contains the substring \" Bottle .", "label": "", "metadata": {}, "score": "103.238235"}
{"text": "Also illustrated is a node 1 referenced as 903 that roughly corresponds to nodes 713 and 810 .This node has no edges and represents , for example , the substring \" Vintage Pepsi Cola Bottle Opener \" as it may appear in , for example , document 4 .", "label": "", "metadata": {}, "score": "103.42976"}
{"text": "Also illustrated is a node 1 referenced as 903 that roughly corresponds to nodes 713 and 810 .This node has no edges and represents , for example , the substring \" Vintage Pepsi Cola Bottle Opener \" as it may appear in , for example , document 4 .", "label": "", "metadata": {}, "score": "103.42976"}
{"text": "vertline .vertline .vertline .x w y . vertline .vertline .vertline .vertline . vertline . epsilon.t . beta.x .delta.s .vertline .vertline .vertline .vertline .vertline .xi.p .gamma.y .phi.q . vertline .", "label": "", "metadata": {}, "score": "108.852425"}
{"text": "\" This subtree 507 is in turn connected to a further node 12 by an edge labeled \" Cola .\" This node 12 is in turn connected to another root node by an edge labeled \" Pepsi .\" Traversing through the subtree 507 and utilizing the node 12 and root node , the following substrings may be generated .", "label": "", "metadata": {}, "score": "109.58302"}
{"text": "\" This subtree 507 is in turn connected to a further node 12 by an edge labeled \" Cola .\" This node 12 is in turn connected to another root node by an edge labeled \" Pepsi .\" Traversing through the subtree 507 and utilizing the node 12 and root node , the following substrings may be generated .", "label": "", "metadata": {}, "score": "109.58302"}
{"text": "10191140 , 191140 , US 2004/0010752 A1 , US 2004/010752 A1 , US 20040010752 A1 , US 20040010752A1 , US 2004010752 A1 , US 2004010752A1 , US - A1 - 20040010752 , US - A1 - 2004010752 , US2004/0010752A1 , US2004/010752A1 , US20040010752 A1 , US20040010752A1 , US2004010752 A1 , US2004010752A1 .", "label": "", "metadata": {}, "score": "110.38316"}
{"text": "orlando bloom \" .Using this table , and the results contained therein , the lower a relevancy score , the more relevant a cluster is with respect to an input query Q. The above table shows the relevancy scores of some example clusters extracted for the input query \" johnny depp \" .", "label": "", "metadata": {}, "score": "113.835724"}
{"text": "orlando bloom \" .Using this table , and the results contained therein , the lower a relevancy score , the more relevant a cluster is with respect to an input query Q. The above table shows the relevancy scores of some example clusters extracted for the input query \" johnny depp \" .", "label": "", "metadata": {}, "score": "113.835724"}
{"text": "HOT ! !AMAZING GREEN PEACOCK IPOD NANO SKIN \" .The first two listings illustrate the ipod nano , while the third listing illustrates the ipod nano skin .Given these superfluous words , it may be important to identify only the relevant / important words in an item listing to the extent they can help improve the relevancy of the cluster tags and the recall of the algorithm .", "label": "", "metadata": {}, "score": "115.03629"}
{"text": "HOT ! !AMAZING GREEN PEACOCK IPOD NANO SKIN \" .The first two listings illustrate the ipod nano , while the third listing illustrates the ipod nano skin .Given these superfluous words , it may be important to identify only the relevant / important words in an item listing to the extent they can help improve the relevancy of the cluster tags and the recall of the algorithm .", "label": "", "metadata": {}, "score": "115.03629"}
{"text": "vertline .vertline .vertline . beta.x . alpha.w .gamma.y . vertline .vertline .vertline .vertline .vertline .x y . vertline .vertline .vertline .vertline ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "118.58089"}
{"text": "vertline .vertline .vertline ._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "119.19728"}
{"text": "Similarly , node 7 referenced as 705 is also a leaf node such that documents 2 and 1 contain the substring \" Pepsi Cola Lighter . \"Connected to the node 4 referenced as 704 is a further node 5 referenced as 706 wherein node 4 and node 5 are connected with an edge labeled with the substring \" Cap . \"", "label": "", "metadata": {}, "score": "122.70007"}
{"text": "Similarly , node 7 referenced as 705 is also a leaf node such that documents 2 and 1 contain the substring \" Pepsi Cola Lighter . \"Connected to the node 4 referenced as 704 is a further node 5 referenced as 706 wherein node 4 and node 5 are connected with an edge labeled with the substring \" Cap . \"", "label": "", "metadata": {}, "score": "122.70007"}
{"text": "Similarly , \" edward scissorhands \" is more relevant than the phrase \" Edward \" and \" orlando bloom \" is more relevant than the cluster \" orlando \" .Moreover , we also see that the cluster \" pirates of the Caribbean movie poster \" is very relevant to the input query \" johnny depp \" while the cluster \" wow \" carries a low relevancy score .", "label": "", "metadata": {}, "score": "129.49673"}
{"text": "Similarly , \" edward scissorhands \" is more relevant than the phrase \" Edward \" and \" orlando bloom \" is more relevant than the cluster \" orlando \" .Moreover , we also see that the cluster \" pirates of the Caribbean movie poster \" is very relevant to the input query \" johnny depp \" while the cluster \" wow \" carries a low relevancy score .", "label": "", "metadata": {}, "score": "129.49673"}
{"text": "Again , traversing through this subtree 507 and the connected node 12 and root node , the further substring of \" Pepsi Cola Lighter \" may be generated wherein this substring is contained in documents 2 and 1 as referenced by node 17 ( e.g. , 509 ) .", "label": "", "metadata": {}, "score": "130.295"}
{"text": "Again , traversing through this subtree 507 and the connected node 12 and root node , the further substring of \" Pepsi Cola Lighter \" may be generated wherein this substring is contained in documents 2 and 1 as referenced by node 17 ( e.g. , 509 ) .", "label": "", "metadata": {}, "score": "130.295"}
{"text": "Given a query q we could classify the demand data relevant to q in two ways .For example if the query q is \" johnny depp \" the demand data could be gathered by examining contained and related queries .Contained queries may be all the demand data / queries entered by users which have the query q contained in the queries .", "label": "", "metadata": {}, "score": "137.6578"}
{"text": "Given a query q we could classify the demand data relevant to q in two ways .For example if the query q is \" johnny depp \" the demand data could be gathered by examining contained and related queries .Contained queries may be all the demand data / queries entered by users which have the query q contained in the queries .", "label": "", "metadata": {}, "score": "137.6578"}
