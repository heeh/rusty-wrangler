{"text": "Second , the constituent structure of morphemes can be modified by Morphological Merger , which can effect relatively local morpheme displacements .Spell - Out inserts Vocabulary items ( phonological pieces ) into morphemes .In the unmarked case , the relation between vocabulary items and morphemes is one - to - one , but several factors may disrupt this relation ( Noyer 1997 ) , including Fission of morphemes and local displacements of Vocabulary items by Morphological Merger .", "label": "", "metadata": {}, "score": "29.177296"}
{"text": "The incorporation of one or more of the foregoing concepts is desirable in making and compressing a single FST to a size only modestly larger than simple FSMs containing only the inflected forms or only the lexical forms but without the mapping between the two representations .", "label": "", "metadata": {}, "score": "30.021154"}
{"text": "The incorporation of one or more of the foregoing concepts is desirable in making and compressing a single FST to a size only modestly larger than simple FSMs containing only the inflected forms or only the lexical forms but without the mapping between the two representations .", "label": "", "metadata": {}, "score": "30.021154"}
{"text": "See Bobaljik 1994 .The canonical use of Merger in Morphology is to express second - position effects .Embick & Noyer ( in progress ) hypothesize that where Merger involves particular Vocabulary items ( as opposed to morphemes ) , the items in question must be string - adjacent ; such cases of Merger are called Local Dislocation .", "label": "", "metadata": {}, "score": "30.448292"}
{"text": "In addition , Fission of morphemes during Spell - out in some cases allows multiple phonological pieces to correspond to single morphemes , further obscuring the morphosyntactic structure .Nevertheless , these departures are considered marked options within a grammar , and therefore are assumed to require ( substantial ) positive evidence during acquisition .", "label": "", "metadata": {}, "score": "30.89721"}
{"text": "In accordance with one aspect of the present invention , we have discovered that it is possible to map inflected forms of the same word , so - called variants , to the same canonical dictionary form or lexical representation .This applies to both regular and irregular forms .", "label": "", "metadata": {}, "score": "31.45785"}
{"text": "( b ) creating a second list of linguistic rules governing the addition of affixes to word stems to form regular word variants of said stems , .( c ) creating a first FST derived from the first list of the morpheme lexicon , .", "label": "", "metadata": {}, "score": "31.967293"}
{"text": "This will only work if the source language word and the target language word are grammatically equivalent , that is , if they share exactly the same morphological symbols for all of their inflected forms .This is the case with our example ; therefore , the entry you have to add to the bilingual dictionary is : .", "label": "", "metadata": {}, "score": "32.118683"}
{"text": "In that case , you need to specify all the grammatical symbols ( in the same order as they are specified in the monolingual dictionaries ) until you reach the symbol that differs between the source language word and the target language word .", "label": "", "metadata": {}, "score": "32.65747"}
{"text": "When this situation occurs , it is an indication that the grammar is full - blown LR(1 ) , because two or more states could not be combined , as would be the case if the grammar was LALR(1 ) or simpler .", "label": "", "metadata": {}, "score": "33.146683"}
{"text": "In Marantz 1988 : 261 Merger was generalized as follows : .Morphological Merger At any level of syntactic analysis ( d - structure , s - structure , phonological structure ) , a relation between X and Y may be replaced by ( expressed by ) the affixation of the lexical head of X to the lexical head of Y. .", "label": "", "metadata": {}, "score": "33.43918"}
{"text": "It is possible to create entries consisting of two ore more words , if these words are considered to build a single \" translation unit \" .These \" multiword units \" can also be useful when it comes to select the correct equivalent for a word inside a fixed expression .", "label": "", "metadata": {}, "score": "33.642727"}
{"text": "Send the lexical units of the pattern in the target language inside an element .Each lexical unit must be included in a element .If two or more lexical units must be generated as a multilexical unit ( only for enclitic pronouns in the present language pairs ) , they must be grouped inside a element .", "label": "", "metadata": {}, "score": "34.51663"}
{"text": "Note I. .Once an item set can be moved from the to - do list to the incomplete / done list , it is a permanent set of the grammar .The algorithm spends the majority of its time in the mergeLoop searching for an existing item set that can be merged with a newly created transition item set .", "label": "", "metadata": {}, "score": "35.08107"}
{"text": "We create the identity transducer that maps every word in the lexicon into itself ; this can be done , for example , by replacing the label on every transition in the FSM with a pair containing two instances of that label .", "label": "", "metadata": {}, "score": "35.86801"}
{"text": "We create the identity transducer that maps every word in the lexicon into itself ; this can be done , for example , by replacing the label on every transition in the FSM with a pair containing two instances of that label .", "label": "", "metadata": {}, "score": "35.86801"}
{"text": "It allows a stem to be computed from a given textual word , on the one hand , but it also allows all other variant forms for the given word 's stem to be computed .These variants can be used to expand a query to increase the likelihood that an appropriate document will be found .", "label": "", "metadata": {}, "score": "35.871758"}
{"text": "] When a lemma can be translated in two or more different ways , one has to be chosen ( the most general , the most frequent , etc . ) .You can tell Apertium that a certain word has to be understood ( analyzed ) but not generated , as it is not the translation of any source - language lemma .", "label": "", "metadata": {}, "score": "36.0719"}
{"text": "Thus , a query word is expanded to the set of all its variants , and these are disjunctively compared with all the words in the database to determine a match .A modified version of the procedure in FIG .7A can also be implemented : the stem for a query word is computed once , and that is compared to the stem ( computed using the look - up algorithm ) of each of the words in the document database .", "label": "", "metadata": {}, "score": "36.164055"}
{"text": "Thus , a query word is expanded to the set of all its variants , and these are disjunctively compared with all the words in the database to determine a match .A modified version of the procedure in FIG .7A can also be implemented : the stem for a query word is computed once , and that is compared to the stem ( computed using the look - up algorithm ) of each of the words in the document database .", "label": "", "metadata": {}, "score": "36.164055"}
{"text": "The difficulty of migrating the grammar into the recognition program is determining which type of action to apply .We will illustrate this difficulty with three examples which generate three types of indeterminacy .The first example is a grammar for expressions using only addition : .", "label": "", "metadata": {}, "score": "36.30407"}
{"text": "Two factors thus distinguish DM from process - only theories of morphology .First , since Readjustment can affect only individual Vocabulary items and not strings of these , it is predicted that ' process ' morphology is always a kind of allomorphy ( see also Lieber 1981 ) .", "label": "", "metadata": {}, "score": "36.555138"}
{"text": "Here , also , the difficulty lies in the non - determinism of the rules which prevents choosing between shifting and reducing .We are going to illustrate the inner workings of bottom - up parsing and its failures by considering those pervasive arithmetic expressions in postfix and prefix notation .", "label": "", "metadata": {}, "score": "36.952072"}
{"text": "The algorithm also differs from the classical LALR(k ) parser generation algorithm by Aho and Ullman , because it is not limited to LALR(k ) grammars but is capable of handling the complete universe of LR(k ) grammars .Rather than synthesizing the look - ahead symbols for a given item , each item and its specific look - ahead symbol are processed together , providing the same capabilities of a canonical LR(k ) parser generator .", "label": "", "metadata": {}, "score": "37.04987"}
{"text": "( f ) combining the second FST with a third FST derived from a list of identity pairs of a language , .( h ) storing the single FST produced in step ( g ) as part of the desired database .", "label": "", "metadata": {}, "score": "37.06842"}
{"text": "( a ) constructing a first FST defining one or more rules of the language , .( b ) constructing a second FST mapping stems to lexical variants , .( c ) computing the composition of the second FST with the first FST to produce a new single third FST that merges the first and second FSTs .", "label": "", "metadata": {}, "score": "37.53281"}
{"text": "The second criteria for merging two item sets is that the result of merging them can not result in any reduce / reduce conflicts .The reduction items in example sets i6 and i11 are identical and thus do not cause a conflict .", "label": "", "metadata": {}, "score": "37.59453"}
{"text": "These two entries are equivalent .As has been explained before , monolingual dictionaries are read LR for the analysis of a text and RL for the generation .In paradigms , the left and right strings are never identical , since the right side must contain the grammatical symbols that will go through all the modules of the system .", "label": "", "metadata": {}, "score": "37.61174"}
{"text": "On the other hand , if the old item set has not been marked as complete yet , all of the items from the new set must be merged into it , including all closure ( non - kernel shift ) items .", "label": "", "metadata": {}, "score": "37.650307"}
{"text": "This way , the queue of the lemma is placed after the enclitic pronoun .If you want to add a new transfer rule , you have to follow these steps : .Specify which pattern you want to detect .Bear in mind that words are processed only once by a rule , and that rules are applied left to right and choosing the longest match .", "label": "", "metadata": {}, "score": "37.82363"}
{"text": "This algorithm differs from the classical LR(k ) parser generation algorithm by Knuth .The algorithm performs the merging as it goes , producing the same collection of states that would result if the entire canonical LR(k ) item sets were generated and then a final pass was made to merge all similar states .", "label": "", "metadata": {}, "score": "37.90323"}
{"text": "This is really two questions , depending on what is meant by a ' piece of a word . 'In DM any given expression acquires at least two structural descriptions during its derivation .In a morphophonological description , an expression 's phonological pieces ( its Vocabulary items ) and their constituent structure are displayed .", "label": "", "metadata": {}, "score": "38.061928"}
{"text": "Because of the great many tasks which the Lexicon was supposed to perform , the terms ' lexical ' and ' lexicalized ' are in fact ambiguous ( Aronoff 1994 ) .Because the Lexicon was supposed to be a storehouse for sound - meaning correspondences , if an expression is said to be ' lexicalized ' the intended meaning may be that the expression is listed with a specialized meaning .", "label": "", "metadata": {}, "score": "38.087334"}
{"text": "However , Noyer 1998 discusses cases where feature - changing readjustments seem necessary .It is proposed that such cases always involve a change from the more marked value of a feature to the less marked value and never vice versa .", "label": "", "metadata": {}, "score": "38.363533"}
{"text": "After the algorithm completes , the done list contains all of the item sets generated for the grammar .These item sets can then be transformed into states for the DFA parser engine .This algorithm works for any LR(k ) grammar , for any k , i.e. , it works for any fixed size set of look - ahead symbols .", "label": "", "metadata": {}, "score": "38.42316"}
{"text": "This controversial distinction has no explicit status in DM .However , DM does distinguish between f - morphemes and l - morphemes ( not all f - morphemes would normally be considered ' inflectional ' however ) as well as between syntactic and non - syntactic ( dissociated ) morphemes .", "label": "", "metadata": {}, "score": "38.557426"}
{"text": "You need to edit this file if you want to add or change transfer rules .Rules have a pattern and an action part .The pattern specifies which sequences of lexical forms have to be detected and processed .The action describes the verifications and transformations that need to be done on its constituents .", "label": "", "metadata": {}, "score": "38.60768"}
{"text": "What kind of language would be possible in a process - based morphology but impossible in DM ?Since process - morphology can in principle apply to any string , regardless of its morphological derivation , it is predicted that a language could mark the category Plural by deletion of a final syllable , regardless of whether that syllable consisted of one or several discrete phonological pieces .", "label": "", "metadata": {}, "score": "38.66687"}
{"text": "9 illustrates how to convert an FST to an FSM ; .FIG .10 is a simple FST mapping between words and stems plus part - of - speech and morphological affix tags ; .FIGS .11A and 11B show how character - based FSTs can share more initial substring transistions than string - based FSTs .", "label": "", "metadata": {}, "score": "38.87867"}
{"text": "9 illustrates how to convert an FST to an FSM ; .FIG .10 is a simple FST mapping between words and stems plus part - of - speech and morphological affix tags ; .FIGS .11A and 11B show how character - based FSTs can share more initial substring transistions than string - based FSTs .", "label": "", "metadata": {}, "score": "38.87867"}
{"text": "Syntactic Hierarchical Structure All the Way Down entails that elements within syntax and within morphology enter into the same types of constituent structures ( such as can be diagrammed through binary branching trees ) .DM is piece - based in the sense that the elements of both syntax and of morphology are understood as discrete instead of as ( the results of ) morphophonological processes .", "label": "", "metadata": {}, "score": "38.9815"}
{"text": "A computerized language processing device , comprising : .A data structure stored on a computer readable medium used in a computerized device executing a language processing application program , . said data structure representing stem - variant relations and variant - parts of speech - affix relations as tags of a language , said data structure comprising a single combined finite state transducer ( FST ) , . said single FST comprising the merger of a first FST derived from a first list of irregular word stem - variant pairs constituting a morpheme lexicon and of a second FST derived from at least a second list of linguistic rules , .", "label": "", "metadata": {}, "score": "39.160645"}
{"text": "Finally , this technique is not linguistically general .Entirely different algorithms would have to be written for each natural language , and even the general strategy of such algorithms must change to handle the properties of prefixing and infixing languages .", "label": "", "metadata": {}, "score": "39.207245"}
{"text": "To be written .Generating a new Apertium system from modified data .If you make changes to any of the linguistic data files of Apertium ( the dictionaries , the transfer rules , the tagger file or corpora or the postgeneration dictionaries ) , the changes will not be applied until you recompile the modules .", "label": "", "metadata": {}, "score": "39.3255"}
{"text": "Merger has different consequences depending upon the level of representation it occurs at .Where Merger applies in syntax proper it is the equivalent of Head Movement , adjoining a zero - level projection to a governing zero - level projection ( Baker 1988 ) .", "label": "", "metadata": {}, "score": "39.39046"}
{"text": "A bilingual dictionary does not usually have paradigms , only lemmas .An entry contains only the lemma in both languages and the first grammatical symbol ( the lexical category ) of each one .Once the \" side \" of each language has been agreed in a system , it has to be observed all through the dictionaries so that the translation works .", "label": "", "metadata": {}, "score": "39.43448"}
{"text": "In exceptional cases you will need to create a new paradigm for a certain word .You can look at the structure of other paradigms and create one accordingly .For a more detailed description of paradigms and word entries in the dictionaries , refer to section 3.1.2 of the system documentation ( at present only in Spanish ) .", "label": "", "metadata": {}, "score": "39.58927"}
{"text": "In accordance with still a further aspect of the invention , an FST is provided that is configured to associate words with affix and parts - of - speech tags as well as with stems , referred to herein as a morphological analyzer .", "label": "", "metadata": {}, "score": "39.675003"}
{"text": "Parsing .Let 's look now at an actual example of how a bottom - up LR(k ) parser works .Using the partial grammar shown in Example 3 , it is fed an input stream composed of the following terminal symbols : .", "label": "", "metadata": {}, "score": "39.72999"}
{"text": "The entry in the bilingual dictionary must be as follows : .A more difficult problem arises when two words have different grammatical symbols and the grammatical information of the source language word is not enough to determine the gender ( masculine or feminine ) or the number ( singular or plural ) of the target language word .", "label": "", "metadata": {}, "score": "39.8551"}
{"text": "For example , -m can be inserted only on a verb to which t- ' 2 ' has already been attached .Thus features conditioning the insertion of a Vocabulary item come in two types .A Vocabulary item primarily expresses the non - parenthesized features in its entry , but it secondarily expresses the parenthesized features ( or any features belonging to other morphemes which are required for insertion of the item ) .", "label": "", "metadata": {}, "score": "39.88697"}
{"text": "The merged FST in accordance with the invention can be created in a number of different ways providing a very flexible system applicable to different kinds of languages .It can include , for example , irregular forms without having to redo or modify existing databases .", "label": "", "metadata": {}, "score": "39.91075"}
{"text": "Combine the Rule system of item 2 with outstanding irregular forms which can simply be listed as a finite list ( FIG .3D ) .There may be hundreds of such FSTs to contend with and it is difficult to implement correctly and efficiently a system that properly interprets all of them as a group .", "label": "", "metadata": {}, "score": "39.96252"}
{"text": "Combine the Rule system of item 2 with outstanding irregular forms which can simply be listed as a finite list ( FIG .3D ) .There may be hundreds of such FSTs to contend with and it is difficult to implement correctly and efficiently a system that properly interprets all of them as a group .", "label": "", "metadata": {}, "score": "39.96252"}
{"text": "For convenience , the items in the newer set ( i11 ) are added to the older set ( i6 ) , resulting in the following combined item set : .Example 9C - Merged Item Set . i6 .goto('+ ' ) from i2 , i4 . , ' , ' ] .", "label": "", "metadata": {}, "score": "40.048264"}
{"text": "Since -en and -s are not plausibly related phonologically , they must constitute two Vocabulary items in competition .Morphophonological allomorphy occurs where a single Vocabulary item has various phonologically similar underlying forms , but where the similarity is not such that Phonology can be directly responsible for the variation .", "label": "", "metadata": {}, "score": "40.20719"}
{"text": "Converting Item Sets into Parser States .Once the LR(k ) item sets for a grammar have been constructed , the next step is to convert them into parser states .There is a direct one - to - one mapping between item sets and parser states .", "label": "", "metadata": {}, "score": "40.23222"}
{"text": "In early work in DM , Halle 1992 proposed a distinction between concrete morphemes , whose phonological expression was fixed , and abstract morphemes , whose phonological expression was delayed until after syntax .Canonical DM however endorses Late Insertion of all phonological expression , so Halle 's earlier concrete vs. abstract distinction has been modified in recent work .", "label": "", "metadata": {}, "score": "40.24469"}
{"text": "For example , the Lexicon representative of a language can comprise : .If there are only a finite number of stem / variant pairs in the language , they can simply be listed .( FIG .3A ) .The listing can include ( FIG .", "label": "", "metadata": {}, "score": "40.25005"}
{"text": "For example , the Lexicon representative of a language can comprise : .If there are only a finite number of stem / variant pairs in the language , they can simply be listed .( FIG .3A ) .The listing can include ( FIG .", "label": "", "metadata": {}, "score": "40.25005"}
{"text": "3D ) .The resulting FST is now restricted to apply only to forms in the lexicon .The single merged FST is especially significant because the composition of a source lexicon with an arbitrary number of rule transducers makes it possible for a simple look - down algorithm to enumerate in a systematic way all the well - formed word forms of a language .", "label": "", "metadata": {}, "score": "40.47162"}
{"text": "3D ) .The resulting FST is now restricted to apply only to forms in the lexicon .The single merged FST is especially significant because the composition of a source lexicon with an arbitrary number of rule transducers makes it possible for a simple look - down algorithm to enumerate in a systematic way all the well - formed word forms of a language .", "label": "", "metadata": {}, "score": "40.47162"}
{"text": "New York .Karttunen , L. , K. Koskenniemi , and R.M. Kaplan .A compiler for Two level Phonological Rules .In Dalrymple , M. et al .Tools for Morphological Analysis .Center for the Study of Language and Information .", "label": "", "metadata": {}, "score": "40.638134"}
{"text": "Insertion does not take place if the Vocabulary item contains features not present in the morpheme .Where several Vocabulary items meet the conditions for insertion , the item matching the greatest number of features specified in the terminal morpheme must be chosen . '", "label": "", "metadata": {}, "score": "40.65714"}
{"text": "Thus , the FSTs of the present invention can be converted to equivalent FSMs , and the compacting techniques and algorithms described in the related case can be applied to them .This is an important benefit of the approach taken in the present invention .", "label": "", "metadata": {}, "score": "40.68885"}
{"text": "Thus , the FSTs of the present invention can be converted to equivalent FSMs , and the compacting techniques and algorithms described in the related case can be applied to them .This is an important benefit of the approach taken in the present invention .", "label": "", "metadata": {}, "score": "40.68885"}
{"text": "Halle & Marantz 1993 suggest that such conflicts are resolved by extrinsic ordering : one Vocabulary item is simply stipulated as the winner .Alternatively , Noyer 1997 proposes that such conflicts can always be resolved by appeal to a Universal Hierarchy of Features ( cf . also Lumsden 1987 , 1992 , Zwicky 1977 and Silverstein 1976 ) .", "label": "", "metadata": {}, "score": "40.7322"}
{"text": "// Clean up .end .+ INCOMPLETE .Practical LR(k ) Parsing .The classic LR(k ) parsing algorithm describes the configuration of a parser at any given moment during a parse .This is a tuple of two parts , one being the current contents of the parser stack and the other part being the current input symbol stream .", "label": "", "metadata": {}, "score": "40.851936"}
{"text": "Following the teachings in the bracketed references , these can be cascaded and combined or merged into a single FST 15 by a well - known composition algorithm for FSTs .An advantage is that the calculus of FSTs provides for merging transducers no matter how the FSTs are created .", "label": "", "metadata": {}, "score": "40.86733"}
{"text": "Following the teachings in the bracketed references , these can be cascaded and combined or merged into a single FST 15 by a well - known composition algorithm for FSTs .An advantage is that the calculus of FSTs provides for merging transducers no matter how the FSTs are created .", "label": "", "metadata": {}, "score": "40.86733"}
{"text": "In this particular example , there is exactly one more state generated for the LR(1 ) parser than would be generated for an LALR(1 ) parser .Another observation to be made about merging item sets is the case in which the existing old set has been marked as complete , i.e. , transition ( goto ) sets have already been generated for the shift items in the set .", "label": "", "metadata": {}, "score": "40.893723"}
{"text": "Notice how many fewer occurrences of the characters a and r there are in FIG .11A vs. FIG . 11B.Character - based sharing can drastically reduce the size of a full - language transducer .Both types of transducers are more efficient for analysis than systems of the type described in reference [ 5 ] which in effect represent morphological information as annotations on states and not as arc labels .", "label": "", "metadata": {}, "score": "40.978096"}
{"text": "Notice how many fewer occurrences of the characters a and r there are in FIG .11A vs. FIG . 11B.Character - based sharing can drastically reduce the size of a full - language transducer .Both types of transducers are more efficient for analysis than systems of the type described in reference [ 5 ] which in effect represent morphological information as annotations on states and not as arc labels .", "label": "", "metadata": {}, "score": "40.978096"}
{"text": "Example 9A - Generated Transition Item Set . i6 .goto('+ ' ) from i2 . , ' , ' ] .Also assume that other item set is generated during the course of constructing the item sets for the grammar : .", "label": "", "metadata": {}, "score": "41.00895"}
{"text": "( b ) inputting to the FST of step ( a ) a stream of characters derived from the document text .The method of claim 8 , further comprising : .( c ) composing the normalizing FST of step ( a ) with a stemming FST to produce a merged FST , .", "label": "", "metadata": {}, "score": "41.02002"}
{"text": "Accuracy suffers without a complete treatment of exceptional behavior , to the point where some researchers have concluded that stemming can not significantly improve recall without substantially reducing precision .Third , this is a one - way approach .It is good for mapping from words to stems , but can not generate all the variant forms from a given stem .", "label": "", "metadata": {}, "score": "41.046547"}
{"text": "A Compiler for Two level Phonological Rules .In Dalrymple , M. et al .Tools for Morphological Analysis .Center for the Study of Language and Information .Stanford University .Palo Alto .Karttunen , L. , K. Koskenniemi , and R. M. Kaplan .", "label": "", "metadata": {}, "score": "41.081177"}
{"text": "In particular , references [ 2 ] , [ 3 ] , [ 4 ] , [ 6 ] and [ 8 ] are specifically incorporated herein by reference .A feature of our invention is to construct and use in a text indexing and retrieval system a stored database comprising a finite - state transducer to represent all possible stem - variant relations of the system language .", "label": "", "metadata": {}, "score": "41.098732"}
{"text": "In particular , references [ 2 ] , [ 3 ] , [ 4 ] , [ 6 ] and [ 8 ] are specifically incorporated herein by reference .A feature of our invention is to construct and use in a text indexing and retrieval system a stored database comprising a finite - state transducer to represent all possible stem - variant relations of the system language .", "label": "", "metadata": {}, "score": "41.098732"}
{"text": "The transducer thus encodes one additional fact that is not explicitly represented in the rule : lexical N 's are realized as n in all other cases .Examples of other typical rules that would actually be used for English can be found in reference [ 3].", "label": "", "metadata": {}, "score": "41.13144"}
{"text": "The transducer thus encodes one additional fact that is not explicitly represented in the rule : lexical N 's are realized as n in all other cases .Examples of other typical rules that would actually be used for English can be found in reference [ 3].", "label": "", "metadata": {}, "score": "41.13144"}
{"text": "There is no need to describe these machines in any great detail here , since the reader who seeks more details can access directly the incorporated , referenced , related case .FIG .5 shows an example of an FST created to generate stems or lexical forms from a surface form based on a rule .", "label": "", "metadata": {}, "score": "41.247627"}
{"text": "There is no need to describe these machines in any great detail here , since the reader who seeks more details can access directly the incorporated , referenced , related case .FIG .5 shows an example of an FST created to generate stems or lexical forms from a surface form based on a rule .", "label": "", "metadata": {}, "score": "41.247627"}
{"text": "This solution is explained in reference [ 3 ] and is based on the teachings in reference [ 6].The former shows how it is possible to combine a plurality of FSTs into a single FST .This is illustrated in FIG .", "label": "", "metadata": {}, "score": "41.462254"}
{"text": "This solution is explained in reference [ 3 ] and is based on the teachings in reference [ 6].The former shows how it is possible to combine a plurality of FSTs into a single FST .This is illustrated in FIG .", "label": "", "metadata": {}, "score": "41.462254"}
{"text": "If you have successfully added general - purpose lexical data to any of the Apertium language pairs , please consider contributing it to the project so that we can offer a better toolbox to the community .You can e - mail your data ( in three XML files , one for each monolingual dictionary and another one for the bilingual dictionary ) to the following addresses : .", "label": "", "metadata": {}, "score": "41.491142"}
{"text": "According to another aspect of the present invention , the single FST of modest size is the result of a combination of composition and intersection of the smaller FSTs created to fulfill the needs of the language .As a result of the above discoveries , a number of important benefits ensue representing other aspects of the invention .", "label": "", "metadata": {}, "score": "41.535305"}
{"text": "The example on page ? ? illustrates this interaction and describes the different phases of compilation .Contextual Grammars .Types generated by ocamlyacc process languages produced by so - called context - free grammars .A parser for such a grammar does not depend on previously processed syntactic values to process the next lexeme .", "label": "", "metadata": {}, "score": "41.54013"}
{"text": "Both are simply one module , Syntax .See also Marantz 1997a .How does Spell - Out work ?Spell - Out , also called Vocabulary Insertion , works differently depending on what type of morpheme is being spelled out , f - morphemes or l - morphemes .", "label": "", "metadata": {}, "score": "41.554535"}
{"text": "If DM is ' piece - based ' how is ' process ' morphology handled ?DM is piece - based inasmuch as Vocabulary items are considered discrete collections of phonological material and not ( the result of ) phonological processes ( as in Anderson 1992 ) .", "label": "", "metadata": {}, "score": "41.590523"}
{"text": "( See also Note C above . )Note H. .After an item set is complete ( i.e. , after all of its reduction items have been marked and all of its shift items have gotos assigned to them ) , it can be compressed , which removes redundant items from it .", "label": "", "metadata": {}, "score": "41.60464"}
{"text": "i8 .cores : . i9 .cores : .However , merging these two sets would result in the following combined set : .Example 11D - Merged LR(1 ) Item Sets .i8 .Therefore , these two item sets can not be safely merged and still produce a usable LR(1 ) parser state .", "label": "", "metadata": {}, "score": "41.608803"}
{"text": "combining the first and second FSTs to form the single FST used by the application program to retrieve a regular or irregular stem or variant based on a given variant or stem , respectively .The method of claim 16 wherein the step of constructing the first FST comprises constructing the first FST to be restricted to stems which are allowable in the language .", "label": "", "metadata": {}, "score": "41.63168"}
{"text": "Once you have added the word to one monolingual dictionary , you have to do the same to the other monolingual dictionary of the translation pair ( in our example , the Catalan monolingual dictionary ) using the same structure .The result would be : .", "label": "", "metadata": {}, "score": "41.637672"}
{"text": "Thus , if the user enters a query with the word \" arriving \" , this can be treated as matching text passages that contain any of the words \" arrive \" , \" arrives \" , etc .This would have the important effect of improving recall without sacrificing precision .", "label": "", "metadata": {}, "score": "41.66655"}
{"text": "Syntactic and Semantic Analysis .A parser for a grammar parses an input stream of tokens ( terminal symbols ) , attempting to recognize syntactic constructs defined by the grammar .Each time that it finds a sequence of symbols matching one of the grammar rules , it is said to recognize a production rule of the grammar .", "label": "", "metadata": {}, "score": "41.668083"}
{"text": "The insertion of zero in the specific environment bleeds the insertion of -e because , under normal circumstances , only a single Vocabulary Item may be inserted into a morpheme .Note that the Vocabulary items above are not specially stipulated to be disjunctive except insofar as they compete for insertion at the same morpheme .", "label": "", "metadata": {}, "score": "41.66838"}
{"text": "F - morphemes are defined as morphemes for which there is no choice as to Vocabulary insertion .In othe words , f - morphemes are those whose content suffices to determine a unique phonological expression .The spell - out of an f - morpheme is said to be deterministic .", "label": "", "metadata": {}, "score": "41.690384"}
{"text": "Specifically , there is the problem of how to deal with the type of terminal symbols versus the type of nonterminal symbols .For an implementation that uses only one stack for both kinds of symbols , this means that both terminals and nonterminals must be represented by the same structure or object data type .", "label": "", "metadata": {}, "score": "41.74748"}
{"text": "This grammar is dual to that of prefix expressions : it is necessary to wait until the end of each analysis to know which rule has been used , but then one knows exactly what to do .In fact , the bottom - up analysis of such expressions resembles quite closely a stack - based evaluation mechanism .", "label": "", "metadata": {}, "score": "41.81649"}
{"text": "Catalan monolingual dictionary : .Spanish - Catalan bilingual dictionary : .It can be the case that a lemma is a multiword in one language and a single word in the other language .In the monolingual dictionaries , each entry will be created according to its type .", "label": "", "metadata": {}, "score": "41.83956"}
{"text": "In DM , the term morpheme properly refers to a syntactic ( or morphological ) terminal node and its content , not to the phonological expression of that terminal , which is provided as part of a Vocabulary item .Morphemes are thus the atoms of morphosyntactic representation .", "label": "", "metadata": {}, "score": "41.907658"}
{"text": "It is important to note that redundant items can only be removed from item sets that have been marked as completed .Removing redundant items from an incomplete item set destroys useful information about the set that is required for later merging operations .", "label": "", "metadata": {}, "score": "42.006496"}
{"text": "6A. The resultant lexical transducer 70 is the desired single merged FST 70 , which is a map defined logically by the composition of the lexicon with the intersection of the rule transducers .The code in annexed Appendix A represents one way of implementing the preferred method illustrated in FIG .", "label": "", "metadata": {}, "score": "42.022354"}
{"text": "With this command you can detect generation errors due to an incorrect entry in the target language monolingual dictionary or to a divergence between the output of the bilingual dictionary ( the output of the previous module ) and the entry in the monolingual dictionary .", "label": "", "metadata": {}, "score": "42.111298"}
{"text": "The method of claim 2 further comprising combining the database with a third FST representing irregular word stem - variant pairs for the language .A method for making a database stored upon a computer readable medium used with a computer for information retrieval or text indexing , the method comprising the steps : .", "label": "", "metadata": {}, "score": "42.11231"}
{"text": "No .06/814,416 , whose contents are hereby incorporated by reference , describes various techniques for encoding FSM data structures for more compact storage .Those techniques are based upon tying the information in the FSM data structures to the transition between states rather than to the states themselves .", "label": "", "metadata": {}, "score": "42.377457"}
{"text": "No .06/814,416 , whose contents are hereby incorporated by reference , describes various techniques for encoding FSM data structures for more compact storage .Those techniques are based upon tying the information in the FSM data structures to the transition between states rather than to the states themselves .", "label": "", "metadata": {}, "score": "42.377457"}
{"text": "6A. The resultant lexical transducer 70 is the desired single merged FST 70 , which is a map defined logically by the composition of the lexicon with the intersection of the rule transducers .The code in the annexed Appendix represents one way of implementing the preferred method illustrated in FIG .", "label": "", "metadata": {}, "score": "42.40603"}
{"text": "The term LR(k ) means a parse using a Left - to - right scan with Right - most derivation requiring k symbols of look - ahead .( This will all be explained later . )Practically all computer languages are LR(1 ) grammars or simpler .", "label": "", "metadata": {}, "score": "42.47342"}
{"text": "Halle 1992 construes Spell - Out as the rewriting of a place - holder ' Q ' in a morpheme as phonological material .This operation is normally understood as cyclic , such that more deeply embedded morphemes are spell - out first .", "label": "", "metadata": {}, "score": "42.536644"}
{"text": "It uses an explicit stack mechanism like the one already described for the parsing of Basic programs .The choice of parsing type is significant , as top - down analysis may or may not be possible given the form of the grammar used to specify the language .", "label": "", "metadata": {}, "score": "42.5376"}
{"text": "To our surprise , we have discovered that a single merged finite state transducer can be constructed that provides the desired mapping and that is of reasonable size and that provides a reasonable response time to queries .The surprise is that the single FST , representing the combination of possibly hundreds or thousands of smaller FSTs each with its own series of states , would have been expected to produce an FST of gigantic size which would be impractical if not impossible to use .", "label": "", "metadata": {}, "score": "42.599373"}
{"text": "Two item sets can be merged if they have identical LR(0 ) item cores .The LR(0 ) core of an item is the item without its look - ahead symbol .( Such items are generated during the course of constructing item sets for an LR(0 ) parser for a given grammar , which is a parser that makes its state transitions without using any look - ahead symbols . )", "label": "", "metadata": {}, "score": "42.70183"}
{"text": "The concept of the invention is also applicable to composing a normalizing FST with a stemming FST into a single transducer that maps a stream of punctuated characters in text into a corresponding sequence of stems .In accordance with still a further aspect of the invention , an FST is provided that is configured to associate words with affix and parts - of - speech tags as well as with stems , referred to herein as a morphological analyzer .", "label": "", "metadata": {}, "score": "42.715706"}
{"text": "This will retrieve only those lexical entries that include the word bright in their English gloss field ( possibly in a phrase , such as a bright light .The search can be constrained in the opposite way by insisting that further characters precede and/or follow the search string .", "label": "", "metadata": {}, "score": "42.771355"}
{"text": "( 2 )A list is provided , 20 at a time , of all lexical items in the dictionary that satisfy all these constraints .( 3 )The user selects an item from the list , and the available data on that item is displayed as a dictionary entry .", "label": "", "metadata": {}, "score": "42.86793"}
{"text": "( 2 )A list is provided , 20 at a time , of all lexical items in the dictionary that satisfy all these constraints .( 3 )The user selects an item from the list , and the available data on that item is displayed as a dictionary entry .", "label": "", "metadata": {}, "score": "42.86793"}
{"text": "This is determined by comparing their item cores , which are : .Example 9B - Item Cores .i6 .cores : . i11 .cores : .( Items having the same rule and marker position but with different look - ahead symbols have the same core , only one of which needs to be considered . )", "label": "", "metadata": {}, "score": "42.880096"}
{"text": "The techniques described apply generally across the languages of the world and are not just limited to simple suffixing languages like English .Although the resulting transducers can have many states and transitions or arcs , they can be compacted by finite - state compression algorithms so that they can be used effectively in resource - limited applications .", "label": "", "metadata": {}, "score": "42.952972"}
{"text": "When an FST encoding the stem / variant relations has been created , it can be used directly as the known tail - cropping algorithms are used [ 2 ] , namely , to stem both query and text - words prior to matching .", "label": "", "metadata": {}, "score": "42.98207"}
{"text": "When an FST encoding the stem / variant relations has been created , it can be used directly as the known tail - cropping algorithms are used [ 2 ] , namely , to stem both query and text - words prior to matching .", "label": "", "metadata": {}, "score": "42.98207"}
{"text": "How is DM different from other theories of the architecture of grammar ?Although there are numerous hypotheses and directions in current DM research , three core properties define the theory : Late Insertion , Underspecification , and Syntactic Hierarchical Structure All the Way Down .", "label": "", "metadata": {}, "score": "43.06476"}
{"text": "This is what is meant by the k in the term LR(k ) parser - the next k input symbols are used as look - ahead symbols for each state , and these k symbols determine the next state to transition to .", "label": "", "metadata": {}, "score": "43.13182"}
{"text": "It can include , for example , irregular forms without having to redo or modify existing databases .The system of the invention is not limited to one mode of operation .It allows a stem to be computed from a given textual word , on the one hand , but it also allows all other variant forms for the given word 's stem to be computed .", "label": "", "metadata": {}, "score": "43.19583"}
{"text": "If your browser supports frames , you will find it much more convenient to use the frame - based query procedure .Otherwise , the following procedures will permit you to access the online dictionaries .The dictionaries differ among each other in some respects , but the basic retrieval strategies are the same .", "label": "", "metadata": {}, "score": "43.262352"}
{"text": "4 illustrates combining of FSTs into a merged FST ; .FIG .5 illustrates a two - level rule FST ; .FIGS .6A and 6B are block diagrams illustrating the construction of a merged FST in accordance with the invention ; .", "label": "", "metadata": {}, "score": "43.26264"}
{"text": "4 illustrates combining of FSTs into a merged FST ; .FIG .5 illustrates a two - level rule FST ; .FIGS .6A and 6B are block diagrams illustrating the construction of a merged FST in accordance with the invention ; .", "label": "", "metadata": {}, "score": "43.26264"}
{"text": "The data structure of claim 20 , wherein the second FST was produced by using composition and intersecting algorithms to combine the third and fourth FSTs .( a ) inputting a query containing a valid word in the language requesting identification of any related words in the database or of a document containing such words or of the query word 's part of speech , .", "label": "", "metadata": {}, "score": "43.31917"}
{"text": "The present invention solves a number of problems in using stems ( canonical indicators of word meanings ) in full - text retrieval of natural language documents , and thus permits recall to be improved without sacrificing precision .In accordance with one aspect of the present invention , we have discovered that it is possible to map inflected forms of the same word , so - called variants , to the same canonical dictionary form or lexical representation .", "label": "", "metadata": {}, "score": "43.359932"}
{"text": "For example : . r1 .Expr : Factor .Such rules are called single productions , since they define a production with only a single RHS symbol .Lexical Analysis .The parser reads streams of symbols and acts on them , recognizing grammatical constructs defined by the rules of the grammar .", "label": "", "metadata": {}, "score": "43.53802"}
{"text": "It is possible that a new item set will be merged into an incomplete existing item set , in which case none of the shift items will have their actions established yet .Eventually , when the merged item set is processed in Phase 2 , it will have the actions of all of its shift items established .", "label": "", "metadata": {}, "score": "43.551346"}
{"text": "For example , they can be used in devices for verb conjugation and deconjugation that people might use for reference and teaching , particularly of languages that are more inflected than English .As another example , they can also be used in a look - up step prior to parsing natural - language sentences in database query systems .", "label": "", "metadata": {}, "score": "43.554085"}
{"text": "For example , they can be used in devices for verb conjugation and deconjugation that people might use for reference and teaching , particularly of languages that are more inflected than English .As another example , they can also be used in a look - up step prior to parsing natural - language sentences in database query systems .", "label": "", "metadata": {}, "score": "43.554085"}
{"text": "7D. FIG .7E illustrates how the transducer might first be applied to a database of document texts to build a stem - index whose entries can then be matched against the stems of particular query - words .Similar blocks are referenced with the same reference numeral .", "label": "", "metadata": {}, "score": "43.584538"}
{"text": "7D. FIG .7E illustrates how the transducer might first be applied to a database of document texts to build a stem - index whose entries can then be matched against the stems of particular query - words .Similar blocks are referenced with the same reference numeral .", "label": "", "metadata": {}, "score": "43.584538"}
{"text": "In other words DM unequivocally rejects the Lexicalist Hypothesis .The jobs assigned to the Lexicon component in earlier theories are distributed through various other components .For linguists committed to the Lexicalist Hypothesis , this aspect of DM may be the most difficult to understand or to accept , but it is nevertheless a central tenet of the theory .", "label": "", "metadata": {}, "score": "43.763107"}
{"text": "For example , entering .able # would help to retrieve lexical entries that correspond to a morphologically defined subset of English adjectives , while avoiding entries whose meaning is defined using the verb able .Just what counts as a \" word \" varies among the fields .", "label": "", "metadata": {}, "score": "43.786"}
{"text": "Specifically , the different ' parts of speech ' can be defined as a single l - morpheme type , called Root ( Pesetsky 1995 ) , in certain local relations with category - defining f - morphemes .Thus , the same Vocabulary item may appear in different morphological categories depending on the syntactic context that the item 's l - morpheme ( or Root ) appears in .", "label": "", "metadata": {}, "score": "43.82051"}
{"text": "7B , but in some cases the composed transducer may be too large to be practical .In all cases , the ability of the FST to deal systematically with stems and variants produces much improved results in identification of documents containing related words .", "label": "", "metadata": {}, "score": "43.929604"}
{"text": "7B , but in some cases the composed transducer may be too large to be practical .In all cases , the ability of the FST to deal systematically with stems and variants produces much improved results in identification of documents containing related words .", "label": "", "metadata": {}, "score": "43.929604"}
{"text": "Some of the items being merged already existed in the set .Since item set i8 was merged into set i2 , all of the transitions ( gotos ) to set i8 must be fixed to make transitions to i2 instead .", "label": "", "metadata": {}, "score": "43.94404"}
{"text": "For example , if person features dominate number features which in turn dominate gender features , then the Impoverishment ( delinking ) of number entails the delinking of gender as well : .Noyer 1997 rejects the use of geometries of this sort as too restrictive , and proposes instead that Impoverishments are better understood as feature - cooccurrence restrictions or filters of the type employed by Calabrese 1995 for phonological segment inventories .", "label": "", "metadata": {}, "score": "44.02798"}
{"text": "Further objects include systems of the type described above that can be implemented with moderate - sized databases providing shorter response times than known systems .Still another object of the invention is a system capable of other types of automatic text processing applications .", "label": "", "metadata": {}, "score": "44.113083"}
{"text": "A method for making a database stored on a computer readable medium used by an information retrieval and text indexing application program executed on a computer system , the method comprising : . constructing a first FST derived from identity pairs of a language representing allowable stems of the language ; . constructing a second FST representing regular rules of the language that map stems to their surface variants ; and .", "label": "", "metadata": {}, "score": "44.197266"}
{"text": "An item represents one of the steps in the recognition of a particular rule of a grammar .An item consists of the following components : .+ -----+----+-- RHS symbols .+ - LHS symbol + - look - ahead symbol .", "label": "", "metadata": {}, "score": "44.237556"}
{"text": "The use of feature geometries in DM remains an unresolved issue at this time , but Feature Hierarchies , whether geometric or not , ensure that normally more marked feature values persist in contexts of neutralization .Does Impoverishment ever involve rules that change morphosyntactic feature values ?", "label": "", "metadata": {}, "score": "44.361313"}
{"text": "In Local Dislocation , a zero - level element trades its relation of adjacency to a following constituent with a relation of affixation to the linear head ( peripheral zero - element ) of that constituent .Local Dislocation has also received considerable attention outside of DM from researchers working in Autolexical Syntax ( Sadock 1991 ) .", "label": "", "metadata": {}, "score": "44.37492"}
{"text": "This situation arises within the item set because such a grammar allows nested if statements .This means that it is possible for an ELSE keyword symbol to follow a THEN Stmt sequence , as shown in the following example : .", "label": "", "metadata": {}, "score": "44.38626"}
{"text": "Consider the hypothetical grammar : .Example 11A - A Simple LR(1 ) Grammar . r1 .S : a A d r2 .S : a B e r3 .S : b A e r4 .S : b B d r5 .", "label": "", "metadata": {}, "score": "44.392952"}
{"text": "The usual grammar for arithmetical expressions on page ? ? is not directly suitable for top - down analysis : it does not satisfy any of the above - stated criteria .To be able to use top - down parsing , we must reformulate the grammar so as to suppress left - recursion and non - determinism in the rules .", "label": "", "metadata": {}, "score": "44.393982"}
{"text": "In that case , the symbol \" GD \" ( for \" gender to be determined \" ) is used instead of the gender symbol .The word 's gender will be determined by the structural transfer module , by means of a transfer rule ( a rule that detects the gender of the preceding noun in this particular case ) .", "label": "", "metadata": {}, "score": "44.44279"}
{"text": "The non - redundant shift items that have not been eliminated have their look - ahead symbols replaced with a ' # ' mark to indicate that they are no longer needed at this point in the parser construction process .( They are still needed in the reduction items , however . )", "label": "", "metadata": {}, "score": "44.600746"}
{"text": "Department of General Linguistics .University of Helsinki .[ 6 ] Karttunen , L. , K. Koskenmemi , and R. M. Kaplan .A Compiler for Two - level Phonological Rules .In Dalrymple , M. et al .Tools for Morphological Analysis .", "label": "", "metadata": {}, "score": "44.65049"}
{"text": "If the user inputs \" arriving \" , the FST will output \" arrive \" in a look - up ( recognition or stemming ) operation .In this way , a single FST can easily be created to map between lower surface level words and their upper lexical representations .", "label": "", "metadata": {}, "score": "44.7091"}
{"text": "If the user inputs \" arriving \" , the FST will output \" arrive \" in a look - up ( recognition or stemming ) operation .In this way , a single FST can easily be created to map between lower surface level words and their upper lexical representations .", "label": "", "metadata": {}, "score": "44.7091"}
{"text": "Spanish - Catalan bilingual dictionary : .The same principles and actions described for basic entries ( gender and number change , direction restrictions , etc . ) apply to all kinds of multiwords .For a more detailed description of multiword units , refer to section 3.1.2.5 of the system documentation ( at present only in Spanish ) .", "label": "", "metadata": {}, "score": "44.749287"}
{"text": "This distinction corresponds ( approximately ) to the distinction between primary and secondary exponence ( Carstairs 1987 ) .A paradigm is a collection of related words ; in some theories certain such collections have a privileged status and can be referred to by statements of the grammar .", "label": "", "metadata": {}, "score": "44.825394"}
{"text": "2 illustrates how a two - level FST operates to map an inflected word to its lexical representation .In this case , it shows a simple FST that maps \" arrive \" , the lexical representation or stem , to \" arriving \" , one of its textural variants at the surface level .", "label": "", "metadata": {}, "score": "44.857063"}
{"text": "Consequently , some of the descriptions might not be purely accurate or correct when viewed from a formal academic perspective .Language parsing is generally divided into two categories : top - down parsing and bottom - up parsing .Top - down parsing generally refers to the parsing and recognition of LL(k ) grammars , and such parsers are typically implemented using a technique known as recursive - descent parsing .", "label": "", "metadata": {}, "score": "45.057755"}
{"text": "To parse the words in L , we must remember what has already been found before letter C to verify that we find exactly the same thing afterwards .Here is a solution for this problem based on ' ' visiting ' ' a stream .", "label": "", "metadata": {}, "score": "45.084366"}
{"text": "In this case , this is a formal error ( a missing XML tag , a tag that is not allowed in a certain context , etc . ) .You just have to go to the line number indicated by the error message , correct the error and compile again .", "label": "", "metadata": {}, "score": "45.113453"}
{"text": "It is based on the use of FSTs .Compact FSTs are desirable because of reduced storage requirements and increased speed .This greatly increases the flexibility of the invention and its applications to existing databases .A typical existing database would likely have a word index , with values indicating document locations for those words , but not a stem index .", "label": "", "metadata": {}, "score": "45.137093"}
{"text": "It is based on the use of FSTs .Compact FSTs are desirable because of reduced storage requirements and increased speed .This greatly increases the flexibility of the invention and its applications to existing databases .A typical existing database would likely have a word index , with values indicating document locations for those words , but not a stem index .", "label": "", "metadata": {}, "score": "45.137093"}
{"text": "For example , if you want to add the word \" genoma \" , you need to find an appropriate paradigm for a noun whose gender is masculine and forms the plural with the addition of an -s .This will be the paradigm \" abismo__n \" in our present dictionaries .", "label": "", "metadata": {}, "score": "45.186943"}
{"text": "What are Vocabulary items ?A Vocabulary item is , properly speaking , a relation between a phonological string or ' piece ' and information about where that piece may be inserted .Vocabulary items provide the set of phonological signals available in a language for the expression of abstract morphemes .", "label": "", "metadata": {}, "score": "45.292915"}
{"text": "Users who are primarily interested in indexing and retrieving text passages from documents according to their meanings may not want the variants of a common stem to be distinguished .Thus , if the user enters a query with the word \" arriving \" , this can be treated as matching text passages that contain any of the words \" arrive \" , \" arrives \" , etc .", "label": "", "metadata": {}, "score": "45.305412"}
{"text": "At the end of the action part of the rule , the resulting lexical forms in the target language are sent out so that they are processed by the next modules in the translation system .A transfer rules file contains four sections with definitions of elements used in the rules , and a fifth section where the actual rules are defined .", "label": "", "metadata": {}, "score": "45.307724"}
{"text": "Word entries consist of a lemma ( that is , the word as you would find it in a typical paper dictionary ) plus grammatical information ; paradigms contain the inflection data of all lemmas in the dictionary .( The element lm is optional and some other dictionaries may not contain it . )", "label": "", "metadata": {}, "score": "45.31241"}
{"text": "i8 i2 ) .A similar thing happens to item set i9 , i10 , i11 , and i17 , which are merged into sets i3 , i4 , i5 , and i6 , respectively .At the end of the algorithm , the to - do list is empty , all item sets have been marked as complete , and the done list contains the following item sets : .", "label": "", "metadata": {}, "score": "45.3267"}
{"text": "LR(1 ) items are constructed from grammar rules in a similar fashion to the way LR(0 ) are constructed , except that they also have one look - ahead symbol .For example : .Example 5B - LR(1 ) Item .", "label": "", "metadata": {}, "score": "45.395992"}
{"text": "( a ) inputting a query containing a valid word in the language requesting identification of any related words in the database or of a document containing such words , .( b ) operating the FST upward by traversing a branch of the FST via the lower string of the pair to obtain the query word 's stem or stems and then scanning the database looking for words with a matching stem , or .", "label": "", "metadata": {}, "score": "45.415596"}
{"text": "The rules detect patterns ( sequences ) of source text lexical forms and apply to them the corresponding transformations .If two patterns have the same length , the rule that applies is the one defined in the first place .The structural transfer module ( generated from the structural transfer rules file ) calls the lexical transfer module ( generated from the bilingual dictionary ) all through the process to determine the target language equivalents of the source language lexical forms .", "label": "", "metadata": {}, "score": "45.438095"}
{"text": "Eventually the configuration indicates that the parser has reached the state with an accept action and with no more look - ahead input symbols , signaling the end of a successful parse : .State and Symbol Stacks .The original theory assumes , in a typically mathematical fashion , that the state numbers , terminal symbols , and nonterminal symbols shifted onto the stack can assume any type or value within the confines of the given grammar .", "label": "", "metadata": {}, "score": "45.478214"}
{"text": "Early work in DM was focused primarily on the spell - out of f - morphemes .In such cases sets of Vocabulary items compete for insertion , subject to the Subset Principle ( Halle 1997 ) .Subset Principle . '", "label": "", "metadata": {}, "score": "45.54814"}
{"text": "The following is an example of a rule which detects the sequence determiner -- noun : .In the Apertium es - ca , es - gl and es - pt systems , there are agreement macroinstructions defined for one , two , three or four lexical units ( f_concord1 , f_concord2 , f_concord3 , f_concord4 ) .", "label": "", "metadata": {}, "score": "45.68653"}
{"text": "Department of General Linguistics .University of Helsinki .[ 6 ] Karttunen , L. , K. Koskenniemi , and R. M. Kaplan .A Compiler for Two - level Phonological Rules .In Dalrymple , M. et al .Tools for Morphological Analysis .", "label": "", "metadata": {}, "score": "45.710224"}
{"text": "Example 6B - Generated Closure Items .Factor ' + ' num , ' ( ' ] .Most of these items are redundant ( which will be explained below ) and will be eliminated from the set at a later point in the parser construction process .", "label": "", "metadata": {}, "score": "45.796036"}
{"text": "[ 2 ] Selecting an entry to display .After submitting your query , the frame at the upper right of the page will be filled with a table of lexical items in the dictionary that are consistent with the constraints you have entered .", "label": "", "metadata": {}, "score": "45.80617"}
{"text": "2 illustrates how a two - level FST operates to map an inflected word to its lexical representation .In this case , it shows a simple FST that maps \" arrive \" , the lexical representation or stem , to \" arriving \" , one of its textual variants at the surface level .", "label": "", "metadata": {}, "score": "45.869953"}
{"text": "After submitting your query , a new browser window is created that the frame at the upper right of the will be filled with a table of lexical items in the dictionary that are consistent with the constraints you have entered .", "label": "", "metadata": {}, "score": "46.019005"}
{"text": "Kaplan , R. M. and M. Kay .Phonological rules and finite - state transducers [ Abstract].Linguistic Society of American Meeting Handbook .Fifty - sixth Annual Meeting , Dec. 27 - 30 , 1981 .New York .", "label": "", "metadata": {}, "score": "46.08637"}
{"text": "It is good for mapping from words to stems , but can not generate all the variant forms from a given stem .Thus , it is limited in its applicability to situations where the document database can be preprocessed for indexing ( which would have to be redone whenever improvements are made to the stemmer ) or where the time - penalty for stemming on the fly is not prohibitive .", "label": "", "metadata": {}, "score": "46.262543"}
{"text": "Item 2 is the next progression , moving the marker to the right of the first symbol ( ' ( ' ) , representing a point where the first symbol has been successfully recognized by the parse .Similarly , items 3 and 4 are the next stages in the recognition of the grammar rule by the parse , moving the marker over the next symbols in the RHS of the rule , left to right , one at a time .", "label": "", "metadata": {}, "score": "46.290596"}
{"text": "Those seeking simple \" generators \" for complete or partial sets of combinations or permutations will find simple functions below ( \" Odometer - style Generators \" ) .Those needing to do more than that will want to look at the slightly more complex \" Index Mapping \" functions , which can be used to generate sets but also provide additional capabilities .", "label": "", "metadata": {}, "score": "46.33943"}
{"text": "( See also Note G below . )Note D. .Merging an item set into an existing item set involves moving all of the items from the new set into the existing set , discarding any duplicate items .Reduction items will already have their actions set , but shift items from the new set must have their actions set to be the same as corresponding shift items in the existing set which shift the same symbol .", "label": "", "metadata": {}, "score": "46.34211"}
{"text": "then and if .then . else .Let 's imagine the following grammar : .Stack .We can not decide whether the first elements in the stack relate to conditional ( R1 ) , in which case it must be reduced , or to the first Instr in rule ( R2 ) , in which case it must be shifted .", "label": "", "metadata": {}, "score": "46.347664"}
{"text": "We also use a LINK array - at any stage , each item is \" linked \" with either its left - hand or right - hand neighbour .At each iteration , we look for what are caled \" mobile \" items ( items we are allowed to move , ie . swap ) .", "label": "", "metadata": {}, "score": "46.34889"}
{"text": "Note also that whitespace characters ( spaces and tabs ) and newlines are mostly irrelevant , and only serve to separate the characters of each symbol and punctuation mark .These should be used to make the grammar definition easier for humans to read .", "label": "", "metadata": {}, "score": "46.35507"}
{"text": "The parser machine ( DFA ) deals only with syntactic elements and has no knowledge of such higher - level concepts .LR(k ) Parser Construction .+ INCOMPLETE , need into paragraphs .Preliminary Concepts .The construction of a parser for an LR(k ) grammar involves generating transition tables for a DFA .", "label": "", "metadata": {}, "score": "46.396362"}
{"text": "For a group of items having the same rule and marker position , and differing only by their look - ahead symbols , all but one of the items is redundant .Thus all but one of the items can be eliminated from the set without removing any useful information from the set .", "label": "", "metadata": {}, "score": "46.541283"}
{"text": "Therefore , a rule that has a verb in its pattern must send the lexical forms like in the following two examples : .The first rule detects a verb and places the queue in the correct place , after all the grammatical symbols .", "label": "", "metadata": {}, "score": "46.564034"}
{"text": "The files that you can find in these directories are described next .Adding words to monolingual and bilingual dictionaries .When extending or adapting Apertium , the most likely operation that will be performed will be to extend its dictionaries .", "label": "", "metadata": {}, "score": "46.57541"}
{"text": "If the lexicon is to be composed with rules that are combined by intersection , the natural order of operations would be to form the FST for the intersection of the rules , and them compose it with the lexicon identity transducer .", "label": "", "metadata": {}, "score": "46.708664"}
{"text": "If the lexicon is to be composed with rules that are combined by intersection , the natural order of operations would be to form the FST for the intersection of the rules , and them compose it with the lexicon identity transducer .", "label": "", "metadata": {}, "score": "46.708664"}
{"text": "These are linguistic errors , which can be detected and corrected with the tips given in this chapter .The following information is for Linux users , since Apertium works for the moment only with this OS .You just have to type the right commands in the terminal using a pipeline structure so that the standard output of one is used as the standard input for the next one .", "label": "", "metadata": {}, "score": "46.784565"}
{"text": "The term idiom is used to refer to any expression ( even a single word or subpart of a word ) whose meaning is not wholly the predictable from its morphosyntactic structural description ( Marantz 1995 , 1997a ) .F - morphemes are typically not idioms , but l - morphemes are always idioms .", "label": "", "metadata": {}, "score": "46.796234"}
{"text": "Transitions and Gotos .Once the closure of an item set has been constructed , the next step is to generate transitions for the items of the set .A transition is the progression of the parsing operation that occurs when the parser recognizes the next input symbol and shifts ( or pushes ) it onto its internal symbol stack .", "label": "", "metadata": {}, "score": "46.82015"}
{"text": "Note also that the resulting merged set has been labeled as being a transition from both set i2 and set i4 , since set i2 generated i6 and set i4 generated i9 .This means that the items in set i4 that formerly transitioned to i9 have to be updated to transition instead to i6 ( in the same way that was done in Example 8C above ) : .", "label": "", "metadata": {}, "score": "46.822002"}
{"text": "Such symbols stand for syntactic terms of the language .For example , a Basic program is composed of lines ( and thus we have the term Line ) , a line may contain and Expression , etc . .A set of so - called production rules .", "label": "", "metadata": {}, "score": "46.875298"}
{"text": "A single FST can readily be constructed that will provide exactly this capability , simply by composing a stemming transducer with its inverse .The inverse of an FST can be created by the well - known technique of simply exchanging the upper and lower symbols of each transition label .", "label": "", "metadata": {}, "score": "46.95085"}
{"text": "A single FST can readily be constructed that will provide exactly this capability , simply by composing a stemming transducer with its inverse .The inverse of an FST can be created by the well - known technique of simply exchanging the upper and lower symbols of each transition label .", "label": "", "metadata": {}, "score": "46.95085"}
{"text": "However , we have weaker results establishing the equivalence between certain classes of grammars and somewhat richer automata : pushdown automata .We do not want to enter into the details of such results , nor give an exact definition of what an automaton is .", "label": "", "metadata": {}, "score": "46.95833"}
{"text": "( Use the \" Back \" key on your browser to see earlier groups of 20 . )The table of matching lexical items will remain in the upper right frame until you issue another search , or until you go to view the next group of 20 .", "label": "", "metadata": {}, "score": "47.015602"}
{"text": "( Use the \" Back \" key on your browser to see earlier groups of 20 . )The table of matching lexical items will remain in the upper right frame until you issue another search , or until you go to view the next group of 20 .", "label": "", "metadata": {}, "score": "47.015602"}
{"text": "+ INCOMPLETE .Item Set Merging .During the process of connstructing item sets for a grammar , transition item sets are generated ( as discussed above ) .Recall that a transition item set is constructed by generating one or more new transition kernel items , by shifting the same symbol from one or more items in the generating set .", "label": "", "metadata": {}, "score": "47.032692"}
{"text": "But programs are composed of simpler elements than symbols .Generally , a sequence of input symbols is fed into a parser as a stream of characters , usually stored in a simple text file .Lexical analysis is the process of reading an input character stream and separating and grouping the characters together into distinct lexical units .", "label": "", "metadata": {}, "score": "47.104855"}
{"text": "The problem with using top - down parsing is that it forces us to use a grammar which is very restricted in its form .Moreover , when the object language is naturally described with a left - recursive grammar ( as in the case of infix expressions ) it is not always trivial to find an equivalent grammar ( i.e. one defining the same language ) that satisfies the requirements of top - down parsing .", "label": "", "metadata": {}, "score": "47.11046"}
{"text": "The item sets in the done list are then compared to this item set for possible merging .This set has the same kernel item cores as item set i2 , which are : .Since there are no reduce / reduce conflicts between item sets i2 and i8 , the two sets can be merged .", "label": "", "metadata": {}, "score": "47.269123"}
{"text": "Abstract .The present invention solves a number of problems in using stems ( canonical indicators of word meanings ) in full - text retrieval of natural language documents , and thus permits recall to be improved without sacrificing precision .It uses various arrangements of finite - state transducers to accurately encode a number of desirable ways of mapping back and forth between words and stems , taking into account both systematic aspects of a language 's morphological rule system and also the word - by - word irregularities that also occur .", "label": "", "metadata": {}, "score": "47.279446"}
{"text": "Moreover , the ordinary capture problem can be solved with gensym or even cooler feature , automatic gensyms ( look at the documentation of the syntax - quote reader macro if you want to know more ) .Speaking as a non - expert , Clojure macros seem to fare pretty well with respect to the hygiene issue .", "label": "", "metadata": {}, "score": "47.29856"}
{"text": "A mechanism to introduce identifiers , i.e. a mechanism to break hygiene , is needed if you want to define binding forms .Such identifiers can then be introduced in macros and made visible to expanded code .In order to understand the mechanism , you must always remember that identifiers in Scheme - in the technical sense of objects recognized by the identifier ? predicate - are not just raw symbols , they are syntax objects with lexical information attached to them .", "label": "", "metadata": {}, "score": "47.36124"}
{"text": "The lexical representation can include information about the part - of - speech , case , gender , number , and other morphological properties of the variant form .This information can be encoded in the lexical representation in the form of symbolic tags that form arc labels in the transducer in the same manner as ordinary letters do .", "label": "", "metadata": {}, "score": "47.4141"}
{"text": "The lexical representation can include information about the part - of - speech , case , gender , number , and other morphological properties of the variant form .This information can be encoded in the lexical representation in the form of symbolic tags that form arc labels in the transducer in the same manner as ordinary letters do .", "label": "", "metadata": {}, "score": "47.4141"}
{"text": "Koskenniemi , K. Two Level Morphology .A General Computational Model for Word Form Recognition and Production .Department of General Linguistics .University of Helsinki .Performance and Architectural Issues for String Matching Isenman , M. , et al . , IEEE Transactions on Computers , vol .", "label": "", "metadata": {}, "score": "47.440117"}
{"text": "Phonological rules and finite - state transducers [ Abstract].Linguistic Society of American Meeting Handbook .Fifty - sixth Annual Meeting , Dec. 27 - 30 , 1981 .New York .[5 ] Koskenniemi , K. Two - level Morphology .", "label": "", "metadata": {}, "score": "47.452538"}
{"text": "Phonological rules and finite - state transducers [ Abstract].Linguistic Society of American Meeting Handbook .Fifty - sixth Annual Meeting , Dec. 27 - 30 , 1981 .New York .[5 ] Koskenniemi , K. Two - level Morphology .", "label": "", "metadata": {}, "score": "47.452538"}
{"text": "In DM the distinction between two types of phonology -- ' lexical ' and ' postlexical ' -- is abandoned .All phonology occurs in a single post - syntactic module .While Lexical Phonology and Morphology produced many important insights , DM denies that these results require an architecture of grammar which divides phonology into a pre - syntactic and post - syntactic module .", "label": "", "metadata": {}, "score": "47.51278"}
{"text": "Ambiguous Grammars .Most typical programming languages use grammars that are ambiguous .This means that they when they are implemented as pure LR(k ) parsers , they contain grammar conflicts .Such conflicts come in two varieties : shift / reduce conflicts and reduce / reduce conflicts .", "label": "", "metadata": {}, "score": "47.51619"}
{"text": "Theories endorsing Separation are unattractive for exactly the same reasons as above : when unconstrained , they fail to make any interesting predictions about the degree to which syntactico - semantic and phonological form can diverge .See Embick 1997 , 1998a , 1998b .", "label": "", "metadata": {}, "score": "47.591843"}
{"text": "All reduction items are marked by setting their actions to the appropriate grammar reduce rule and look - ahead symbol .Doing this insures that any possible reduce / reduce conflicts will be detected when attempting to merge the item set with another existing ( complete ) item set .", "label": "", "metadata": {}, "score": "47.617546"}
{"text": "The second instance of a grammar generating a conflict between shifting and reducing has the same type of ambiguity : an implicit parenthesizing .But contrary to the previous case , the choice between shifting and reducing modifies the meaning of the parsed expression .", "label": "", "metadata": {}, "score": "47.629784"}
{"text": "In grammatical fields , punctuation includes only colons , hyphens , and parentheses .Nonetheless , it is possible to search for strings including punctuation , word - delimiting or not , in any field .It is possible to enter constraints on multiple fields .", "label": "", "metadata": {}, "score": "47.692894"}
{"text": "The method of claim 4 further comprising creating a third list of stem - affix pairs and creating the third FST by mapping the stem - affix pairs in the third list into themselves .The method of normalizing text in a document , comprising : .", "label": "", "metadata": {}, "score": "47.74791"}
{"text": "The query as just described is designed to retrieve all lexical entries that have the string right in the English gloss field of the database , whether or not more characters precede or follow it .For example , it will also retrieve a word meaning ' bright ' or ' rightly ' .", "label": "", "metadata": {}, "score": "47.766914"}
{"text": "( R1 ) .E1 + E1 .( R2 ) .( R3 ) .Here again , an expression may be produced in two ways .There are two right - hand derivations of .This problem has already been cited for Basic expressions ( see page ? ? )", "label": "", "metadata": {}, "score": "47.818264"}
{"text": "It takes more involved checking to determine if the token sequence makes sense at a higher , semantic level .To illustrate , consider the following sequence of Java tokens : .While this particular sequence of tokens is syntactically correct ( forming a Java expression ) , it is semantically incorrect because the types of the operands do not match the operators .", "label": "", "metadata": {}, "score": "47.886444"}
{"text": "This solves the problem of representing terminal symbols ( lexical tokens ) as arbitrarily complex data types , but there is another related problem concerning nonterminal symbols .Nonterminal Stack .Nonterminal symbols represent production rules of the grammar matching sequences of zero or more input tokens .", "label": "", "metadata": {}, "score": "47.902603"}
{"text": "6B. This method avoids computing an unmanageably large intermediate structure 64 while still producing a final result of tractable size .In this example , the set of rule transducers 61 . . .63 are simultaneously intersected and composed with the lexicon fsm 65 , to produce the desired lexical transducer 70 .", "label": "", "metadata": {}, "score": "47.94449"}
{"text": "6B. This method avoids computing an unmanageably large intermediate structure 64 while still producing a final result of tractable size .In this example , the set of rule transducers 61 . . .63 are simultaneously intersected and composed with the lexicon fsm 65 , to produce the desired lexical transducer 70 .", "label": "", "metadata": {}, "score": "47.94449"}
{"text": "Here are the combinations of 3 from 5 in lexicographical order : .Code : .As you can see , it 's really just the natural numerical sort order , based on the leftmost fields having precedence .Permutations also have a natural lexicographical ( sequence ) order .", "label": "", "metadata": {}, "score": "48.11362"}
{"text": "IMPORTANT :Every time a set of modifications is made to any of the dictionaries , the modules have to be recompiled .Type make in the directory where the linguistic data are saved ( apertium - es - ca , apertium - es - gl or what may be applicable ) so that the system generates the new binary files .", "label": "", "metadata": {}, "score": "48.311493"}
{"text": "This is true because all of the remaining items from the new set are non - kernel shift ( closure ) items that do not add any useful information to the merged set .Reduction items always need to be added to the merged set because they are used to convert the item set into a parser state .", "label": "", "metadata": {}, "score": "48.35023"}
{"text": "num from Factor . '+ ' from Factor .+ INCOMPLETE .First Set Generation Algorithm .The look - ahead symbols for LR(k ) items are generated from first sets generated from the symbols of the grammar .An LR(k ) parser with k - symbol look - ahead requires first k symbol sets .", "label": "", "metadata": {}, "score": "48.356857"}
{"text": "An immediate consequence is that undeniably suppletive pairs like go / went or bad / worse must actually represent the spelling of f - morphemes .The class of f - morphemes is as a result considerably enriched , but since the class of f - morphemes is circumscribed by Universal Grammar , it is also predicted that true suppletion should be limited to universal syntactico - semantic categories .", "label": "", "metadata": {}, "score": "48.38794"}
{"text": "Still another object of the invention is a system capable of other types of automatic text processing applications .Still further objects include improved databases for use in systems of the type described , and improved methods for constructing such databases .", "label": "", "metadata": {}, "score": "48.431095"}
{"text": "Programmers must supply a lexical analyzer class that implements the Lexer YACC / M library class .The crucial method is getToken ( ) , which is responsible for reading the next token from the input stream and returning an integer token code or zero if no more tokens are available .", "label": "", "metadata": {}, "score": "48.45465"}
{"text": "What is Separationism ?Separationism characterizes theories of morphology in which the mechanisms for producing the form of syntactico - semantically complex expressions are separated from , and not necessarily in a simple correspondence with , the mechanisms which produce the form ( ' spelling ' ) of the correponding phonological expressions .", "label": "", "metadata": {}, "score": "48.4743"}
{"text": "In order to go back from a displayed dictionary entry to the list of entries meeting the search criteria , close the window with the displayed dictionary entry .To go back from a list of entries meeting the search criteria to the query page , to submit a new query , close the window with the list of entries meeting the last search criteria .", "label": "", "metadata": {}, "score": "48.534157"}
{"text": "Which Vocabulary item wins if the features of two Vocabulary items competing for insertion into the same morpheme are not in a subset / superset relation ?In some cases it would be possible to insert two ( or more ) Vocabulary items into the same morpheme , and the Subset Principle does not determine the winner .", "label": "", "metadata": {}, "score": "48.53578"}
{"text": "10 .We call a transducer configured to associate words with affix and part - of - speech tags as well as with stems a \" morphological analysis transducer \" or \" morphological analyzer \" .These transducers differ from ordinary stemming transducers only in the extra tag information included in the upper - side strings ; they can be constructed , manipulated , compressed , and applied by exactly the same techniques and algorithms .", "label": "", "metadata": {}, "score": "48.600998"}
{"text": "10 .We call a transducer configured to associate words with affix and part - of - speech tags as well as with stems a \" morphological analysis transducer \" or \" morphological analyzer \" .These transducers differ from ordinary stemming transducers only in the extra tag information included in the upper - side strings ; they can be constructed , manipulated , compressed , and applied by exactly the same techniques and algorithms .", "label": "", "metadata": {}, "score": "48.600998"}
{"text": "If no more than 20 lexical items conform to your constraints , all of these items are listed ; otherwise , only 20 matching items are displayed at a time .If more than 20 entries match your constraints , the total number that match is displayed at the bottom of the list .", "label": "", "metadata": {}, "score": "48.636368"}
{"text": "If no more than 20 lexical items conform to your constraints , all of these items are listed ; otherwise , only 20 matching items are displayed at a time .If more than 20 entries match your constraints , the total number that match is displayed at the bottom of the list .", "label": "", "metadata": {}, "score": "48.636368"}
{"text": "B : c .In the process of constructing item sets for this grammar , the following two sets are generated : .Example 11B - LR(1 ) Item Sets .i8 .These two item sets have identical kernel item cores , which are : .", "label": "", "metadata": {}, "score": "48.723797"}
{"text": "LF does not express or represent meaning ; LF is merely a level of representation which exhibits certain meaning - related structural relations , such as quantifier scope .See Marantz 1995 .Do theta - roles figure in DM ?Most work in DM does not recognize a set of discrete thematic roles .", "label": "", "metadata": {}, "score": "48.768585"}
{"text": "Various rules can be applied to resolve this situation .One simple solution is to produce both of the stems , and process each as if it were the only stem , at worst increasing the number of documents identified .One rule we can follow is to always chose the shortest stem .", "label": "", "metadata": {}, "score": "48.84394"}
{"text": "Various rules can be applied to resolve this situation .One simple solution is to produce both of the stems , and process each as if it were the only stem , at worst increasing the number of documents identified .One rule we can follow is to always chose the shortest stem .", "label": "", "metadata": {}, "score": "48.84394"}
{"text": "4 and 5 of the paper .A sample two - level rule in words : Lexical N is realized as surface m if and only if it is followed by a p on the lexical side ( regardless of how that p itself is realized ) .", "label": "", "metadata": {}, "score": "48.845276"}
{"text": "4 and 5 of the paper .A sample two - level rule in words : Lexical N is realized as surface m if and only if it is followed by a p on the lexical side ( regardless of how that p itself is realized ) .", "label": "", "metadata": {}, "score": "48.845276"}
{"text": "( 3 ) An alternative to this second strategy is illustrated in FIG .7C. In this case , all stem variants are produced 82c by the look - up algorithm operating on a single FST created by composing the merged FST with its inverse .", "label": "", "metadata": {}, "score": "48.872177"}
{"text": "( 3 ) An alternative to this second strategy is illustrated in FIG .7C. In this case , all stem variants are produced 82c by the look - up algorithm operating on a single FST created by composing the merged FST with its inverse .", "label": "", "metadata": {}, "score": "48.872177"}
{"text": "LR(k ) grammars can handle all of these forms of recursive rules .The only limitation on recursive productions for LR(k ) grammars is that for a given rule in which the LHS symbol appears in the RHS , there must be more than one symbol in the RHS .", "label": "", "metadata": {}, "score": "48.976166"}
{"text": "The syntactic assembly rules are defined by grammar rules .This formalism was originally developed in the field of linguistics , and has proven immensely useful to language - theoretical mathematicians and computer scientists in that field .We have already seen on page ? ? an instance of a grammar for the Basic language .", "label": "", "metadata": {}, "score": "49.02987"}
{"text": "When certain features are deleted , the insertion of Vocabulary items requiring those features for insertion can not occur , and a less specified item will be inserted instead .Halle & Marantz termed this the Retreat to the General Case .", "label": "", "metadata": {}, "score": "49.039337"}
{"text": "Also note that the production rules appear in the reverse order that they occur during the parsing actions above .At this point in the discussion , the details about how the parser knows when to push a symbol and when to reduce a production rule have not been explained .", "label": "", "metadata": {}, "score": "49.071594"}
{"text": "Example 7A - Transition Item Generation . i2 .+ ' num , ' ) ' ] .This item set was reached by shifting a Factor symbol , as indicated by the marker being positioned to the right of that symbol in each of the items in the set .", "label": "", "metadata": {}, "score": "49.204903"}
{"text": "The first component is referenced by $ 1 , the second by $ 2 , etc . .Warning .Lexical units .Grammar rules make reference to lexical units , the terminals or terminal symbols in the rules .One ( or several ) lexemes are declared in the following fashion : .", "label": "", "metadata": {}, "score": "49.30033"}
{"text": "Each lexical form ( lemma plus morphological analysis ) is presented as a possible analysis of the word casa .The tagger output .To know the output of the tagger for a source language text , type the following in the terminal ( example for the Catalan - Spanish direction ) : . prob .", "label": "", "metadata": {}, "score": "49.303017"}
{"text": "Although the resulting transducers can have many states and transitions or arcs , they can be compacted by finite - state compression algorithms so that they can be used effectively in resource - limited applications .A computerized information retrieval or text indexing device , comprising : .", "label": "", "metadata": {}, "score": "49.37276"}
{"text": "You have to move to the directory where the linguistic data are saved and type the commands explained below .The morphological analyser output To know how a word is analysed by the translator , type the following in the terminal ( example for the Catalan word gener ) : . automorf.bin .", "label": "", "metadata": {}, "score": "49.405205"}
{"text": "Redundant items are those that do not contribute any useful distinguishing information about the item set that is not already known from other items in the set .The result is more efficient use of memory space and faster item set comparisons during phase 1 .", "label": "", "metadata": {}, "score": "49.492218"}
{"text": "Example 5C - LR(2 ) Item .Expr ' ) ' , ' + ' num ] .Thus an LR(k ) item has k look - ahead symbols .Item Sets .As was stated above , the construction of parser states for a grammar involves first constructing LR(k ) item sets from the grammar , and then converting these sets into parser states .", "label": "", "metadata": {}, "score": "49.49989"}
{"text": "Second , this approach requires special mechanisms to deal with irregular inflection and derivation .Accuracy suffers without a complete treatment of exceptional behavior , to the point where some researchers have concluded that stemming can not significantly improve recall without substantially reducing precision .", "label": "", "metadata": {}, "score": "49.54652"}
{"text": "Function infix_of is an example ; it takes a prefix expression and returns its equivalent infix expression .A Less Simple Case .Parsing using streams is predictive .It imposes two conditions on grammars .There must be no left - recursive rules in the grammar .", "label": "", "metadata": {}, "score": "49.551727"}
{"text": "No kind of agreement or contract is created between you and the developers .If you have any doubt , or you plan to make a massive contribution , contact Mikel L. Forcada .Adding structural transfer ( grammar ) rules .", "label": "", "metadata": {}, "score": "49.58535"}
{"text": "All of the nonterminal symbols in a grammar are defined by one or more rules , and occur as the left - hand - side ( LHS ) symbol of these rules .Nonterminal symbols do not comprise input to a parser but are only used internally by the parser to represent the progress of a parse .", "label": "", "metadata": {}, "score": "49.588135"}
{"text": "( R1 ) .E0 + E0 .( R2 ) .The indeterminacy in this grammar stems from rule ( R2 ) .Let 's suppose the following situation : .Stack .[ E0 + E0 ... ] .In such a case , it is impossible to determine whether we have to shift and push the + or to reduce using ( R2 ) both E0 's and the + in the stack .", "label": "", "metadata": {}, "score": "49.60647"}
{"text": "This assumption must now be demonstrated to be true with some degree of analytical rigor .Loose Ends .The Honalee Algorithm , as far as the author knows , is the first LR(k ) parser construction algorithm of its kind .", "label": "", "metadata": {}, "score": "49.624817"}
{"text": "Sequences of symbols given as input to a parser are composed entirely of terminal symbols from the grammar .Terminal symbols are also called lexical tokens ( which will be explained in more detail below ) .The grammar of Example 1 contains the following terminal symbols : .", "label": "", "metadata": {}, "score": "49.705547"}
{"text": "( r2 ) $ any reduce 2 .LR(k ) Parsing Algorithm .The following pseudo - code is the fundamental LR(k ) parser algorithm .It assumes the existence of a parser state stack capable of holding state numbers , as well as a value stack capable of holding parsing symbols .", "label": "", "metadata": {}, "score": "49.78482"}
{"text": "( a ) constructing a first FST defining one or more rules of the language , .( b ) constructing a second FST defining one or more other rules of the language , .( c ) constructing a third FST derived from a list of identity stem - affix pairs of the language or defining one or more rules of the language other than the rules defined by the first and second FSTS , and .", "label": "", "metadata": {}, "score": "49.90389"}
{"text": "By creating a MAPPING function ( CombinationToIndex ) that assigns an INDEX value to each combination or permutation according to its position in the full list , we can represent individual combinations by simple numbers .With an inverse function ( IndexToCombination ) that returns the combination for a given index value , we can then generate any subset of all possible combinations from a given starting point like this : .", "label": "", "metadata": {}, "score": "50.077225"}
{"text": "For the translation \" RL \" you need to create two entries , one for the adjective in feminine and another one for the adjective in masculine .The same principle applies when it is not possible to determine the number ( singular or plural ) of the target word for the same reasons mentioned above .", "label": "", "metadata": {}, "score": "50.090134"}
{"text": "num , ' ) ' ] .Items 1 and 2 of this set produce the following new transition set by shifting symbol ' + ' : .Example 8B - New Transition Item Set . i9 .goto('+ ' ) from i4 .", "label": "", "metadata": {}, "score": "50.101547"}
{"text": "i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) .One possibility when displaying this as a state is to list only the item cores of the set .This means that the cores of items 4 and 5 , and items 6 and 7 , and items 8 and 9 would be combined and shown on a single line : .", "label": "", "metadata": {}, "score": "50.215923"}
{"text": "Palo Alto .Karttunen , L. , K. Koskenniemi , and R.M. Kaplan .A compiler for Two - level Phonological Rules .In Dalrymple , M. et al .Tools for Morphological Analysis .Center for the Study of Language and Information .", "label": "", "metadata": {}, "score": "50.295254"}
{"text": "If a sequence of symbols from a grammar is fed into a machine that implements a parser for that grammar , the machine can determine whether or not the input symbols form a valid sentence of the grammar .If the sequence is valid , the parser accepts the input sentence without error , otherwise the parser may detect one or more syntax errors in the input sequence .", "label": "", "metadata": {}, "score": "50.317673"}
{"text": "The Encyclopedia contains Encyclopedia entries ; these relate Vocabulary items ( sometimes in the context of other Vocabulary items ) to meanings .In other words , the Encyclopedia is the list of idioms in a language .If Vocabulary insertion does not occur until after syntax , and Vocabulary is not present at LF , how is the meaning of expressions determined ?", "label": "", "metadata": {}, "score": "50.469475"}
{"text": "3D ) in the following way .If I is a transducer derived from a finite list of irregular pairs ( e.g. ) , and R is a transducer derived from regular rules ( that erroneously includes ) , we can properly merge the two sources of information .", "label": "", "metadata": {}, "score": "50.52826"}
{"text": "3D ) in the following way .If I is a transducer derived from a finite list of irregular pairs ( e.g. ) , and R is a transducer derived from regular rules ( that erroneously includes ) , we can properly merge the two sources of information .", "label": "", "metadata": {}, "score": "50.52826"}
{"text": "And , as a further fringe benefit , the FST will do a better stemming job , and can guarantee that every stem produced is a complete English word .The procedures illustrated in FIGS .7A , 7B , and C can also be applied to a document database for which no word index exists .", "label": "", "metadata": {}, "score": "50.533623"}
{"text": "The lexical entry is printed in \" dictionary format \" in a newly created browser window .By default , all available data types are printed .This is indicated by a check in the small box to the right of the query box for each data type , on the query page .", "label": "", "metadata": {}, "score": "50.581623"}
{"text": "It works for the translation in both directions : from Spanish to Catalan and from Catalan to Spanish .In the case of the Spanish - Galician pair , the following bilingual entry in the Spanish - Galician bilingual dictionary ( apertium - es - gl . es - gl ) will translate all the inflected forms for the equivalent words genoma / xenoma in both directions , that is , from Spanish to Galician and from Galician to Spanish : .", "label": "", "metadata": {}, "score": "50.619198"}
{"text": "The symbol ' a here is being promoted to a bona fide identifier , by adding to it the lexical context associated to the macro name .You can check that the identifier a is really introduced as follows : .For that purpose I have added an identifier - append utility in my ( aps lang ) library , defined as follow : . ; ; take an identifier and return a new one with an appended suffix ( define ( identifier - append i d .", "label": "", "metadata": {}, "score": "50.629845"}
{"text": "In other words , syntactic categories are purely abstract , having no phonological content .Only after syntax are phonological expressions , called Vocabulary Items , inserted in a process called Spell - Out .Underspecification of Vocabulary items means that phonological expressions need not be fully specified for the syntactic positions where they can be inserted .", "label": "", "metadata": {}, "score": "50.66016"}
{"text": "This is represented with a special $ other action : .$ other error .If this happens , the parser issues an appropriate error message and may optionally perform some kind of error recovery action .Combining all of the pieces above that are displayed for the conversion of item set i0 into a complete parser state yields the following output , which neatly summarizes the shift , goto , and error actions for the state : .", "label": "", "metadata": {}, "score": "50.667103"}
{"text": "( d ) operating the FST upward by traversing a branch of the FST via the lower string of the pair to obtain an identification of the query word 's part - of - speech .The method of claim 22 wherein , if a match is found , outputting the match or an identification of a document containing the match .", "label": "", "metadata": {}, "score": "50.73797"}
{"text": "4 into a single rules FST .It will also be understood that many known algorithms exist for minimizing states in finite automata , which include FSMs and FSTs .These should be used to further reduce the size of the resultant data structure .", "label": "", "metadata": {}, "score": "50.759747"}
{"text": "4 into a single rules FST .It will also be understood that many known algorithms exist for minimizing states in finite automata , which include FSMs and FSTs .These should be used to further reduce the size of the resultant data structure .", "label": "", "metadata": {}, "score": "50.759747"}
{"text": "The internal structure of expressions is not always a product of syntactic operations .In DM structure can be produced both in syntax and after syntax in a component called Morphology ( see How are the pieces of words put together ? )", "label": "", "metadata": {}, "score": "50.759827"}
{"text": "The symbol being shifted governs which state the parser makes a transition to , based on rules of the grammar .When an item set ( representing a parsing state ) makes a transition to another item set , ... .+ INCOMPLETE .", "label": "", "metadata": {}, "score": "50.767494"}
{"text": "This in turn implies that tokens are the same type as ( or a derived subtype of ) parse tree nodes .This constraint does not always lead to a satisfactory implementation solution .The approach taken by YACC / M is to split the parser symbol stack into two separate stacks , one for terminal symbols ( tokens ) and another for nonterminal ( LHS ) symbols .", "label": "", "metadata": {}, "score": "50.810974"}
{"text": "The major problem of syntax - case is a cosmetic one : it looks very complex and cumbersome to use , but that can be easily solved by providing a nicer API - which I did with sweeet - macros .Actually I have been able to use sweet - macros for twenty episodes without explaining the intricacies of the hygienic expansion .", "label": "", "metadata": {}, "score": "50.828278"}
{"text": "Description of language - pair data currently available .At present Apertium has linguistic data for three language pairs : Spanish - Catalan , Spanish - Galician and Spanish - Portuguese .These linguistic data include mainly dictionaries ( monolingual and bilingual ) , structural transfer rules that perform grammatical and other transformations between the two languages involved , and lexical data for the part - of - speech tagger , which is in charge of the disambiguation of the source language text .", "label": "", "metadata": {}, "score": "50.829918"}
{"text": "An LALR(1 ) parser does not carry along enough information about how it arrived at the merged state i8+i9 , so it can not decide whether to reduce an A or a B LHS symbol .A canonical LR(1 ) parser , on the other hand , carries along enough information because it will enter either state i8 or i9 depending on the previous input symbols , and can therefore safely decide whether to reduce an A or a B .", "label": "", "metadata": {}, "score": "50.859184"}
{"text": "The left - most k symbols of this list are the current look - ahead symbols for the LR(k ) parser .In this example , the current look - ahead symbol for an LR(1 ) parser is the one symbol ' + ' .", "label": "", "metadata": {}, "score": "50.919388"}
{"text": "Item sets are identical if they contain the same kernel items .If this occurs , the algorithm discards the newly generated transition set and uses the previously existing set in its place .Sometimes the newly generated transition set is almost identical to another existing item set , but contains kernel items with different look - ahead symbols .", "label": "", "metadata": {}, "score": "50.969944"}
{"text": "Such an analyzer is useful not only for text retrieval but also for other types of automatic text processing applications .The present invention will be better understood from the detailed description given herein below in conjunction with the accompanying drawings , which give by way of illustration only and not by limitation , preferred embodiments in accordance with the present invention .", "label": "", "metadata": {}, "score": "50.978172"}
{"text": "Such an analyzer is useful not only for text retrieval but also for other types of automatic text processing applications .The present invention will be better understood from the detailed description given herein below in conjunction with the accompanying drawings , which give by way of illustration only and not by limitation , preferred embodiments in accordance with the present invention .", "label": "", "metadata": {}, "score": "50.978172"}
{"text": "goto('+ ' ) from i4 . , ' , ' ] .The newly generated transition set i11 is similar to , but not exactly the same , as the previously generated set i9 .Since the sets are not identical , set i9 can not simply be used in place of i11 .", "label": "", "metadata": {}, "score": "51.039974"}
{"text": "Attributes have to be defined using their corresponding grammatical symbols and can not have asterisks ; its name must be unique .The following are the definitions for the attributes \" a_det \" ( for determiners ) and \" gen \" ( gender ) : . : Here the macroinstructions are defined , which contain sequences of code that are frequently used in the rules ; this way , linguists do not need to write the same actions repeatedly .", "label": "", "metadata": {}, "score": "51.052624"}
{"text": "The same process of creating transition item sets and kernel items is performed for all of the items in the current set .All of the new transition item sets that are generated from item set i0 are : . i1 .", "label": "", "metadata": {}, "score": "51.10299"}
{"text": "To know how a word , phrase or sentence is translated into the target language and processed by structural transfer rules , type the following in the terminal : . bin ca - es .autobil.bin .Analysing how a word or phrase is output by this module can help you detect errors in the bilingual dictionary or in the structural transfer rules .", "label": "", "metadata": {}, "score": "51.123898"}
{"text": "This change affects these items : . i3 .Factor , ' ) ' ]( Factor , .i8 i2 ) .Factor ' + ' num , ' ) ' ]( Factor , .i8 i2 ) .Factor ' + ' num , ' + ' ]", "label": "", "metadata": {}, "score": "51.170494"}
{"text": "These items are part of a transition set which is generated from the set currently under consideration .In this newly generated item set , the marker is advanced over the ' + ' symbol to create the following new items : .", "label": "", "metadata": {}, "score": "51.219357"}
{"text": "Errors due to structurual transfer rules vary a lot depending on the actions performed by the rules .The morphological generator output .To know how a word is generated by the system , type the following in the terminal : . bin ca - es .", "label": "", "metadata": {}, "score": "51.22651"}
{"text": "The start symbol identifies a complete translation unit ( program ) in our language , and the corresponding production rule is used as the starting point for parsing . where ( R1 ) ( R2 ) ( R3 ) and ( R4 ) are the names given to our rules .", "label": "", "metadata": {}, "score": "51.30936"}
{"text": "And , as a further fringe benefit , the FST will do a better stemming job , and can guarantee that every stem produced is a complete English word .The procedures illustrated in FIGS . 7 A , B , C can also be applied to a document database for which no word index exists .", "label": "", "metadata": {}, "score": "51.432587"}
{"text": "Finite - state transduction of related word forms for text indexing and retrieval US 5594641 A .Abstract .The present invention solves a number of problems in using stems ( canonical indicators of word meanings ) in full - text retrieval of natural language documents , and thus permits recall to be improved without sacrificing precision .", "label": "", "metadata": {}, "score": "51.43477"}
{"text": "The result of the function returned by parse_w1 is simply the character string containing the parsed lexical unit .Function parse_w2 takes as argument a list built by parse_w1 to compose each of its elements into a single parsing function : .", "label": "", "metadata": {}, "score": "51.44613"}
{"text": "Thus , given the stem \" arrive \" , one can get all the various forms ( generation ) , or given one of the variant forms ( arrival ) , one can get its stem ( arrive ) .If a given word may be a form of more than one stem ( e.g. \" found \" as the past tense of \" find \" or the present of \" found \" ) , then the two correct stems will be provided .", "label": "", "metadata": {}, "score": "51.557255"}
{"text": "Thus , given the stem \" arrive \" , one can get all the various forms ( generation ) , or given one of the variant forms ( arrival ) , one can get its stem ( arrive ) .If a given word may be a form of more than one stem ( e.g. \" found \" as the past tense of \" find \" or the present of \" found \" ) , then the two correct stems will be provided .", "label": "", "metadata": {}, "score": "51.557255"}
{"text": "An action can be something like adding a new identifier to the compiler 's symbol table , setting an attribute of an identifier , generating intermediate code , issuing an error message , and so forth .Actions generally perform some kind of semantic analysis , which involves checking that the input stream of tokens makes sense .", "label": "", "metadata": {}, "score": "51.568886"}
{"text": "Good boys and good girls ' .By hypothesis , Prosodic Inversion ( Halpern 1995 ) is a distinct species of Merger at the level of PF , and differs from Local Dislocation in that the affected elements are prosodic categories rather than morphological ones .", "label": "", "metadata": {}, "score": "51.587906"}
{"text": "Of course , words are sent out always in the target language ; source language lexical forms may be needed inside of a rule , when testing its attributes or characteristics .- part : indicates which part of the lexical form is referred to in the ' clip ' .", "label": "", "metadata": {}, "score": "51.64441"}
{"text": "The lexical entry is printed in \" dictionary format \" in the bottom right frame of the query page .By default , all available data types are printed .This is indicated by a check in the small box to the right of the query box for each data type , in the leftmost frame .", "label": "", "metadata": {}, "score": "51.64923"}
{"text": "In a fissioned morpheme , Vocabulary items are no longer in competition for a single position - of - exponence , i.e. for the position of the morpheme itself .Rather , an additional position - of - exponence is automatically made available whenever a Vocabulary item is inserted ( see Halle 1997 for a slightly different view ) .", "label": "", "metadata": {}, "score": "51.715412"}
{"text": "Item set i0 now has all of its reduction and shift actions filled in , and is marked complete : .Completed Item Set - i0 .i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) .", "label": "", "metadata": {}, "score": "51.72969"}
{"text": "This illustrates that two Vocabulary items can be disjunctive not by competing for the same position - of - exponence , but rather by competing for the discharge of the same feature .Such cases are termed Discontinuous Bleeding .Some features in the above Vocabulary item list are in parentheses .", "label": "", "metadata": {}, "score": "51.735054"}
{"text": "In the Apertium es - ca , es - gl and es - pt , simple agreement operations ( gender and number agreement ) are easy to perform in a rule by means of a macroinstruction .To perform other operations , you will need to use more complicated elements ; for a more detailed description of the language used to create rules , refer to the section 3.4.2 of the system documentation ( at present only in Spanish ) .", "label": "", "metadata": {}, "score": "51.799904"}
{"text": "A grammar is also composed of rules ( also known as syntax rules ) , which define how sequences of symbols can be strung together to form valid sentences .The grammar of Example 1 contains the following rules : .Example 3 - Simple Grammar Rules .", "label": "", "metadata": {}, "score": "51.8335"}
{"text": "Top - down Parsing .These two ways to proceed constitute two types of analysis : top - down parsing ( right - to - left ) and bottom - up parsing ( left - to - right ) .The latter is easily realizable with lexeme streams using module Stream .", "label": "", "metadata": {}, "score": "51.8421"}
{"text": "10 is a significantly more compact tool for morphological analysis and generation than the sort of transducer described in reference [ 12].The latter uses strings rather than characters as arc labels .This vastly increases the size of the alphabet compared to our character - based transducer , and requires much more complex matching in the corresponding look - up and look - down operations .", "label": "", "metadata": {}, "score": "51.852768"}
{"text": "10 is a significantly more compact tool for morphological analysis and generation than the sort of transducer described in reference [ 12].The latter uses strings rather than characters as arc labels .This vastly increases the size of the alphabet compared to our character - based transducer , and requires much more complex matching in the corresponding look - up and look - down operations .", "label": "", "metadata": {}, "score": "51.852768"}
{"text": "The most common programming languages are LALR(1 ) grammars , which are a proper subset of LR(1 ) grammars .Grammars .A grammar is simply a set of symbols and rules that define a particular language .More precisely , the symbols and rules define valid sentences of the grammar .", "label": "", "metadata": {}, "score": "51.982292"}
{"text": "[Note : The system performs only part - of - speech disambiguation for homograph words , that is , for ambiguous words that can be analyzed as more than one lexical form , like vino in Spanish , that can mean both \" wine \" and \" he / she came \" .", "label": "", "metadata": {}, "score": "51.999657"}
{"text": "Example 7C - Transition Item Generation . i2 .+ ' num , ' + ' ] ( ' + ' , i6 ) .+ ' num , ' ) ' ] ( ' + ' , i6 ) .Sometimes in the course of generating a new transition item set T by shifting symbol s from set G , the new set T will have an identical set of items as another set P which has already been generated .", "label": "", "metadata": {}, "score": "52.04985"}
{"text": "Suppose you are working with the Spanish - Catalan pair .In this case , you have to add : .You will need to go to the directory containing the XML dictionaries ( for the Spanish - Catalan pair , this is apertium - es - ca ) and open with a text editor or a specialized XML editor the three dictionary files mentioned : apertium - es - ca .", "label": "", "metadata": {}, "score": "52.05577"}
{"text": "However , stemming in the context of text indexing and retrieval has proven difficult to implement well , even for morphologically simple languages like English . use \" tail - cropping \" algorithms to map words into canonical forms such as stems .", "label": "", "metadata": {}, "score": "52.186794"}
{"text": "This simple optimization can speed up the merging algorithm by an order of magnitude or so .Consider , for example , the following item set , which contains one kernel item and several non - kernel closure items : .Example 10A - Item Set .", "label": "", "metadata": {}, "score": "52.234375"}
{"text": "A transition item inherits the same look - ahead symbol from the item that generates it .Thus item i6.1 has the same look - ahead symbol ( ' + ' ) as item i2.1 from which it was generated , and the same relationship holds for items i6.2 and i2.2 .", "label": "", "metadata": {}, "score": "52.255737"}
{"text": "The list of cover symbols available for a given language are provided in the frame that spans the top of the page from which the dictionary for that language is accessed ; scroll down to review these symbols .Cover symbols are provided to facilitate some searches .", "label": "", "metadata": {}, "score": "52.34021"}
{"text": "The checkbox is a toggle : if it is checked , clicking on it will remove the check ; if it is not checked , clicking on it will place a check within it .If the box is checked , data of that type will be displayed for the lexical entries ; if it is not checked , data of that type will not be displayed .", "label": "", "metadata": {}, "score": "52.343403"}
{"text": "The checkbox is a toggle : if it is checked , clicking on it will remove the check ; if it is not checked , clicking on it will place a check within it .If the box is checked , data of that type will be displayed for the lexical entries ; if it is not checked , data of that type will not be displayed .", "label": "", "metadata": {}, "score": "52.343403"}
{"text": "Proceedings of the Third Conference on Applied Natural Language Processing .Trento , Italy , April 1992 .# # SPC1 # # .Kaplan , R.M. Phonological rules and finite - state transducers [ Abstract].Linguistic Society of American Meeting Handbook .", "label": "", "metadata": {}, "score": "52.37561"}
{"text": "Reduce / Reduce Conflicts .Reduce / reduce conflicts are more difficult to resolve .These conflicts occur within states that have two different reduction actions for the same look - ahead symbol .+ INCOMPLETE .Resulting Parser States .Converting all of the item sets of the example grammar produces the following parser states : .", "label": "", "metadata": {}, "score": "52.384995"}
{"text": "num , ' ) ' ] .But set i9 is identical to the previously generated set i6 .That being the case , i9 is discarded and all of the transitions out of set i4 going to i9 are changed to go to i6 instead : .", "label": "", "metadata": {}, "score": "52.385494"}
{"text": "Factor : ' + ' Factor r5 .Factor :Factor ' + ' num Nonterminal Symbols n1 .Expr n2 .Factor .This grammar is composed of four terminal symbols , two nonterminal symbols , and five production rules .", "label": "", "metadata": {}, "score": "52.436573"}
{"text": "The following pseudo - code is an algorithm for constructing the first symbol sets for all of the nonterminals in an LR(1 ) grammar .// LR(1 )First Set Generation Algorithm . begin .// Initialize . step 1 .Add all of the nonterminals of the grammar to the nonterminals queue ; . loop : . while queue is not empty , .", "label": "", "metadata": {}, "score": "52.53932"}
{"text": "The content of a frame remains when you issue commands from it and go on to work with the results of your commands in other frames , so you can readily work back and forth between frames .[ 1 ] Enter constraints .", "label": "", "metadata": {}, "score": "52.634865"}
{"text": "7A-7E illustrate algorithms describing the different modes in which the system of the invention can operate ; .FIGS .8A and 8B illustrate , respectively , the use of a normalizing FST and a merged FST in the treatment of a character stream in accordance with the invention ; .", "label": "", "metadata": {}, "score": "52.67651"}
{"text": "7A-7E illustrate algorithms describing the different modes in which the system of the invention can operate ; .FIGS .8A and 8B illustrate , respectively , the use of a normalizing FST and a merged FST in the treatment of a character stream in accordance with the invention ; .", "label": "", "metadata": {}, "score": "52.67651"}
{"text": "However , it should be emphasized that the extent to which Local Dislocation and Prosodic Inversion are distinct devices in the mapping to PF remains controversial .Impoverishment , first proposed in Bonet 1991 , is an operation on the contents of morphemes prior to Spell - Out .", "label": "", "metadata": {}, "score": "52.858543"}
{"text": "Find the mobile item with the highest item value .Swap item J with its neighbour , either J-1 or J+1 , depending on LINK(J ) .Note that we swap both the ITEM and LINK values .We simply repeat this sequence until there are no mobile items at all , which means we have reached the end of the sequence .", "label": "", "metadata": {}, "score": "52.859955"}
{"text": "[ ] [ ] .There are in this case no morphological symbols , and the word appears inflected .The post - generator output .bin ca - es .autopgen.bin .The Apertium output .You can put all the modules of the system in the pipeline structure and see how a source language text goes through all the modules and gets translated into the target language .", "label": "", "metadata": {}, "score": "52.900787"}
{"text": "As a result of the above discoveries , a number of important benefits ensue representing other aspects of the invention .The techniques described apply generally across the languages of the world and are not just limited to simple suffixing languages like English .", "label": "", "metadata": {}, "score": "53.00797"}
{"text": "If changes were made to the tagger file or to the corpora used to train the tagger , you will need also to retrain the tagger .In the same directory mentioned above , after typing make , type make train in order to perform the retraining .", "label": "", "metadata": {}, "score": "53.119526"}
{"text": "The affixes are added in an order determined by the Feature Hierarchy .Hence t- ' 2 ' is added first , then -n ' plural ' , and finally -t ' feminine . 'In a form like n - dawa ' we cure ' there is but one affix .", "label": "", "metadata": {}, "score": "53.164528"}
{"text": "This means that the parser expects to see no more input tokens once the goal symbol has been recognized .The initial item set ( i0 ) is further constructed by adding all of the closure items to it .Closure items are generated from the items that already exist in the set which have their marker to the left of all of their RHS symbols .", "label": "", "metadata": {}, "score": "53.1743"}
{"text": "In practice , it makes for shorter and less confusing listings if only the kernel item cores are shown .Such non - kernel items really do not contribute much to the understanding of the state , especially if there are large numbers of them , and they tend to clutter the listing with a lot of redundant items .", "label": "", "metadata": {}, "score": "53.19986"}
{"text": "In most cases , a word is a string delimited by blanks or punctuation .In grammatical fields , punctuation includes only colons , hyphens , and parentheses .Nonetheless , it is possible to search for strings including punctuation , word - delimiting or not , in any field .", "label": "", "metadata": {}, "score": "53.230705"}
{"text": "LR(k ) item sets generally contain a lot of redundant items , which are items that do not contribute any additional information about the set that is not already contributed by other items in the set .+ INCOMPLETE .Reduction items are never redundant because they and their look - ahead symbols are used to determine whether or not to reduce on that symbol when converting the item set into a parser state .", "label": "", "metadata": {}, "score": "53.263645"}
{"text": "Description .RELATED APPLICATION .A commonly - assigned U.S. application Ser .No .06/814,146 , now abandoned , filed Dec. 27 , 1985 , entitled \" ENCODING FSM DATA STRUCTURES \" , and continuation cases , U.S. Ser .Nos .", "label": "", "metadata": {}, "score": "53.33732"}
{"text": "A set of rules in a grammar applies to all strings in the alphabet of the language , whether or not they are , or ever could be , real stems .It is desirable to restrict the rules so that they only apply to the items listed in a specific dictionary or lexicon .", "label": "", "metadata": {}, "score": "53.376137"}
{"text": "A set of rules in a grammar applies to all strings in the alphabet of the language , whether or not they are , or ever could be , real stems .It is desirable to restrict the rules so that they only apply to the items listed in a specific dictionary or lexicon .", "label": "", "metadata": {}, "score": "53.376137"}
{"text": "M. A Finite - State Mophological Processor for Spanish .Proceedings of the 13th International Conference on Computational Linguistics .Vol .University of Helsinki .Helsinki .[ 13 ] Cutting , D. , J. Kupiec , J. Pedersen , P. Sibun .", "label": "", "metadata": {}, "score": "53.391487"}
{"text": "M. A Finite - State Mophological Processor for Spanish .Proceedings of the 13th International Conference on Computational Linguistics .Vol .University of Helsinki .Helsinki .[ 13 ] Cutting , D. , J. Kupiec , J. Pedersen , P. Sibun .", "label": "", "metadata": {}, "score": "53.391487"}
{"text": "+ ' num , ' + ' ] ( ' + ' , . i9 i6 ) .+ ' num , ' ) ' ] ( ' + ' , . i9 i6 ) .It must be noted that when comparing the cores of two item sets , it is necessary to compare only the cores of kernel items , and non - kernel items can be safely ignored .", "label": "", "metadata": {}, "score": "53.392086"}
{"text": "The \" back \" key will not take you back to a prior page ; to do this , you must close the window containing the current result .[ 1 ] Enter constraints .On the first , access screen there appears a list of all of the data types that can be used to search the dictionary .", "label": "", "metadata": {}, "score": "53.40927"}
{"text": "Factor ( r1 ) .Factor + num ( r5 ) .num ( r3 ) .This diagram shows the derivation of each nonterminal symbol encountered in the parse of the input tokens .The terminal symbols are underlined , which graphically illustrates why they are called terminal symbols - they occur at the terminal leaf nodes of the derivation tree .", "label": "", "metadata": {}, "score": "53.592613"}
{"text": "The addition of the look - ahead symbol ( i.e. , the ' + ' symbol in the items above ) represents the fact that at the point in the parse represented by an item , the current input symbol is expected to be that particular look - ahead symbol .", "label": "", "metadata": {}, "score": "53.618923"}
{"text": "Search time is directly proportional to both the number of cover symbols used and to the number of ordinary symbols each cover symbol replaces .It is not recommended to use more than one cover symbol , across all query boxes put together .", "label": "", "metadata": {}, "score": "53.67457"}
{"text": "The idea is to start with an empty stack , then obtain a stack which contains only the start symbol once the input is used up .The input lexical unit is underlined .The end of input is noted with a $ sign .", "label": "", "metadata": {}, "score": "53.699432"}
{"text": "Cover symbols are provided to facilitate some searches .However , they should be used sparingly : they substantially slow a search .Search time is directly proportional to both the number of cover symbols used and to the number of ordinary symbols each cover symbol replaces .", "label": "", "metadata": {}, "score": "53.72694"}
{"text": "Syntactic clitics .Finally , the term ' clitic ' is sometimes used to describe syntactically mobile heads , typically Determiners , such as certain Romance pronominals on some accounts .In such cases the dependency relation or special behavior is a syntactic property of a morpheme ( syntactic category ) .", "label": "", "metadata": {}, "score": "53.73784"}
{"text": "for each shItem in comeFrom , [ Note F ] .if shItem.action is goto(T , set ) , . end for ; .// Discard the new set , replace with merged gSet .break mergeLoop ; . else . mark the grammar as not LALR ; [ Note E ] .", "label": "", "metadata": {}, "score": "53.812263"}
{"text": "The Honalee algorithm works by merging item sets ( states ) as they are constructed , whereas the canonical LR(k ) construction algorithm works by constructing all of the item sets ( states ) first and then merging those that can be merged afterwards .", "label": "", "metadata": {}, "score": "53.913025"}
{"text": "The pretransfer output .This module applies some changes to multiwords ( move the lemma queue of a multiword with inner inflection just after the lemma head ) .To know its output , type : .Since gener is not a multiword in the dictionaries , this module does not alter its input .", "label": "", "metadata": {}, "score": "53.92452"}
{"text": "So in actual practice , the parser stack is usually implemented as two separate stacks , one for state numbers and the other for symbols .Classic YACC , for instance , implements the parser stack in this fashion .Terminal Stack .", "label": "", "metadata": {}, "score": "53.97776"}
{"text": "Expr : ' ( ' Expr ' ) ' .The items resemble the rule from which they are constructed , with a few additions ., has been inserted between symbols in the right hand side ( RHS ) of the rule .", "label": "", "metadata": {}, "score": "53.998512"}
{"text": "Impoverishment thus guarantees that both the Vocabulary items t and zero can not be inserted , since both require explicit reference to a value for [ \u00b1neuter].Insertion of the general case , namely -e , follows automatically .In Bonet 's original proposal ( 1991 ) and in several subsequent works ( Harley 1994 , Harris 1997a , Ritter & Harley 1998 ) , morphosyntactic features are arranged in a feature geometry much like phonological features , and Impoverishment is represented as delinking .", "label": "", "metadata": {}, "score": "54.01559"}
{"text": "To submit the query , click on the \" Submit \" button , which appears above and below the list of searchable data types .The query as just described is designed to retrieve all lexical entries that have the string right in the English gloss field of the database , whether or not more characters precede or follow it .", "label": "", "metadata": {}, "score": "54.021133"}
{"text": "Each list contains all of the sets with identical kernel cores ( as well as other sets that happen to have the same hash value ) , which is much quicker to search for a merging set than the entire done list .", "label": "", "metadata": {}, "score": "54.10416"}
{"text": "We introduce two new terminals : T ( for terms ) , and F ( for factors ) , which gives : .( R3 ) .F .( R4 ) .F . integer .( R5 ) .The third example concerns conditional instructions in programming languages .", "label": "", "metadata": {}, "score": "54.11252"}
{"text": "Dictionaries currently available for online access .Online access currently requires that your browser support frames , which provide the most convenient means of accessing the data .Non - frames versions will be available shortly .You may search the following dictionary databases : The present invention solves a number of problems in using stems ( canonical indicators of word meanings ) in full - text retrieval of natural language documents , and thus permits recall to be improved without sacrificing precision .", "label": "", "metadata": {}, "score": "54.13596"}
{"text": "LR(k ) Parsing Theory .Background .The following is a simplified explanation of LR(k ) bottom - up parsing theory .Some of the concepts and terminology are presented in simplified form so that it is more easily understood by novices .", "label": "", "metadata": {}, "score": "54.183235"}
{"text": "These states are constructed from item sets , which are in turn derived from the grammar itself .Items .The process of constructing parser states for a grammar involves the construction of item sets , which are simply sets of items .", "label": "", "metadata": {}, "score": "54.313175"}
{"text": "However , we have also observed that when it can be constructed 64 and it is then composed ( indicated by the circle symbol ) with the lexicon 65 , the final result 66 is quite manageable in size .This is because many states and transitions in the intersection are never traversed when the FST is applied to just the specific list of words in the lexicon , and they are removed in the composition procedure .", "label": "", "metadata": {}, "score": "54.386497"}
{"text": "However , we have also observed that when it can be constructed 64 and it is then composed ( indicated by the circle symbol ) with the lexicon 65 , the final result 66 is quite manageable in size .This is because many states and transitions in the intersection are never traversed when the FST is applied to just the specific list of words in the lexicon , and they are removed in the composition procedure .", "label": "", "metadata": {}, "score": "54.386497"}
{"text": "Adding data for the lexical categorial disambiguator ( part - of - speech tagger ) .To be written .Retraining the lexical categorial disambiguator .To be written .Detecting errors .It is easy to make errors when adding new words or transfer rules to the Apertium system .", "label": "", "metadata": {}, "score": "54.41654"}
{"text": "The data structure of claim 12 , wherein the second FST was produced by using composition and intersecting algorithms to combine the third and fourth FSTs .The data structure of claim 11 , wherein the merger was carried out by computing the identity transducer for the complement of the domain of the first FST , precomposing the identity transducer with the second FST , and then unioning the result with the first FST .", "label": "", "metadata": {}, "score": "54.426266"}
{"text": "No new transition sets can be generated from this set because it does not contain any shift items .+ INCOMPLETE .+ REDO The processing of every item set is not shown , but there are two item sets that should be noted : item sets i ? ? ?", "label": "", "metadata": {}, "score": "54.471794"}
{"text": "Thus , rules or algorithms are written that strip off any of the systematically varying suffix letters to map every word to the longest prefix common to all variants .Without special mechanisms to deal with exceptions , this strategy would also convert all the forms of \" swim \" back to \" sw \" , since that is the longest invariant prefix .", "label": "", "metadata": {}, "score": "54.479343"}
{"text": "The device of claim 1 , further comprising memory means , said database being stored in said memory means .The device of claim 1 , wherein the FST is compressed .A data structure stored on a computer readable medium used in a computerized device executing an information retrieval or text indexing application program , . said data structure representing stem - variant relations of a language , said data structure comprising a single combined finite state transducer ( FST ) , . said single FST mapping stems of words obeying the linguistic rules to variants of said stems except where the word is an irregular word in the morpheme lexicon and is overridden by the latter , .", "label": "", "metadata": {}, "score": "54.613396"}
{"text": "The base word indicating the common element of meanings for all such variants is often called the stem , and the morphological analysis process of determining the stem from a variant form is often called stemming .The process of going the other way , from a stem to all its variant forms , is often called synthesis or generation .", "label": "", "metadata": {}, "score": "54.672916"}
{"text": "This is why in Scheme the macro expansion is not literally inserted in the original code , and a lot of magic takes place to avoid name clashes .In practice , the implementation of Scheme macros takes care of distinguishing the introduced identifiers with some specific mechanism ( it could be based on marking the names , or on explicit renaming ) .", "label": "", "metadata": {}, "score": "54.692577"}
{"text": "Therefore there is no technical reason why hygienic macros are not widespread in the whole Lisp world , just a matter of different opinions on the importance of the problem and the different tradeoffs .I believe that eventually all Lisp dialects will start using hygienic macros , but that could take decades , because of inertia and backward - compatibility concerns .", "label": "", "metadata": {}, "score": "54.772095"}
{"text": "+ INCOMPLETE .Extra Whatever ? ?+ MOVE Each terminal symbol has a precedence associated with it , which is its rank relative to the other terminal symbols , and is used to resolve any syntactic conflicts in the grammar .", "label": "", "metadata": {}, "score": "54.787346"}
{"text": "Its attributes mean the following : . - pos : refers to the position of the lexical form in the pattern .\" 1 \" is the first lexical form ( the determiner ) and \" 2 \" the second one ( the noun ) .", "label": "", "metadata": {}, "score": "54.80816"}
{"text": "There are much better ways to define records in Scheme , as we will see in part VI of these Adventures .Anyway , def - book works as follows .Given a single identifier name and two values it introduces three identifiers in the current lexical scope : name ( bound to a vector containing the two values ) , name - title ( bound to the first value ) and name - author ( bound to the second value ) .", "label": "", "metadata": {}, "score": "54.845436"}
{"text": "We will see , however , that not everything is possible with them , either .Bottom - up Parsing .On page ? ? , we introduced intuitively the actions of bottom - up parsing : shift and reduce .With each of these actions the state of the stack is modified .", "label": "", "metadata": {}, "score": "54.862507"}
{"text": "In the drawings : .FIG .1 is a block diagram of one form of a system incorporating the invention ; .FIG .2 is a sample FST mapping between stems and variants ; .FIGS .3A-3D are examples of lexicons representing languages ; .", "label": "", "metadata": {}, "score": "54.952538"}
{"text": "In the drawings : .FIG .1 is a block diagram of one form of a system incorporating the invention ; .FIG .2 is a sample FST mapping between stems and variants ; .FIGS .3A-3D are examples of lexicons representing languages ; .", "label": "", "metadata": {}, "score": "54.952538"}
{"text": "( 2 ) As shown in FIG .7B , pre - stem the query word by applying the look - up algorithm 82b , then use the FST again 86 , this time using the look - down algorithm to generate all the variants of that stem .", "label": "", "metadata": {}, "score": "54.9919"}
{"text": "( 2 ) As shown in FIG .7B , pre - stem the query word by applying the look - up algorithm 82b , then use the FST again 86 , this time using the look - down algorithm to generate all the variants of that stem .", "label": "", "metadata": {}, "score": "54.9919"}
{"text": "Indeed , a mathematical result tells us that all sets ( of words ) defined by means of a regular expression formalism can also be defined by another formalism : deterministic finite automata .And these latter are easy to explain as programs taking as input a sequence of characters .", "label": "", "metadata": {}, "score": "55.096382"}
{"text": "Do n't we have too many functional projections already ?In the early 1990s some linguists looked on with apprehension at the ' explosion ' of INFL and the proposal of more and more new syntactic projections .In DM , because dissociated morphemes can be inserted after Syntax , not every morpheme corresponds to a syntactic terminal .", "label": "", "metadata": {}, "score": "55.111362"}
{"text": "Using the FST of the invention is by operating the system of FIG .1 .During execution , the FST is processed or traversed for stemming or generating as described .Those skilled in the art will have no difficulty implementing the invention in the light of the teachings herein .", "label": "", "metadata": {}, "score": "55.146896"}
{"text": "i0 .Factor ' + ' num , ' + ' ] .The next step in phase 1 is to mark all of the reduction items in the set .Set i0 has no reduction items , so nothing is done .", "label": "", "metadata": {}, "score": "55.14745"}
{"text": "Eventually , though , the error will be detected by the parser .The parser may perform other reduction actions , but eventually it will reach a state requiring a shift action .It is in this eventual state that no shift action for the current ( erroneous ) look - ahead symbol will be found and the parser will declare a syntax error .", "label": "", "metadata": {}, "score": "55.244377"}
{"text": "x17 i6 ) .x17 i6 ) .x13 .x14 .i9 .x15 .goto(num ) from i6 .i10 .x16 . goto ( ' ) ' ) from i7 .x17 .Item sets with names like ' .", "label": "", "metadata": {}, "score": "55.262093"}
{"text": "According to this aspect of the invention , the mapping is obtained by means of a finite state transducer ( FST ) .To our surprise , we have discovered that a single merged finite state transducer can be constructed that provides the desired mapping and that is of reasonable size and that provides a reasonable response time to queries .", "label": "", "metadata": {}, "score": "55.32919"}
{"text": "When the parser reaches this particular point during a parse , it has successfully recognized the rule from which the item was generated ( rule r2 in this case ) .+ MOVE THIS PARA .At this point , the parser reduces the rule , replacing the symbols on the parser stack representing the three RHS symbols of the rule ( ' ( ' , Expr , and ' ) ' ) with the single LHS symbol of the rule ( Expr ) .", "label": "", "metadata": {}, "score": "55.386597"}
{"text": "These symbols , also known as lexical tokens ( or just tokens ) , are passed to the parser .The parser , in turn , performs syntactic analysis on the stream of input tokens .For example , consider the following stream of characters from a sample Java program .", "label": "", "metadata": {}, "score": "55.415302"}
{"text": "In other words , if one or more kernel items in an old set have the same core as one or more kernel items in another new set , then the closure items generated from these kernel items will all have the same cores as well .", "label": "", "metadata": {}, "score": "55.421417"}
{"text": "The parser uses only the terminal symbol number of a token , which does not need to be anything more complicated than a simple integer value .However , any user - defined semantic actions taken by the parser usually need more information about each token , hence the need to allow terminal symbols to be represented by user - defined structures or object types .", "label": "", "metadata": {}, "score": "55.46997"}
{"text": "- - From this augmented grammar rule , an initial item is constructed , which is the first item to be added to the initial item set ( which is named i0 ): .i0 .The initial item represents the progress of the parse at the very start of reading an stream of input symbols ( tokens ) .", "label": "", "metadata": {}, "score": "55.478325"}
{"text": "Code : .Sub GenPermutations(ByVal N As Long ) ' ' \" Johnson - Trotter \" VB6 implementation by MathImagics ( Dec 2004 ) ' Each permutation is obtained from the previous by ' swapping just ONE pair of adjacent items . '", "label": "", "metadata": {}, "score": "55.503677"}
{"text": "For example , both Spanish forms cantaran or cantasen should be analyzed as cantar , verb , subjunctive imperfect , 3rd person plural , but when generating Spanish text , one has to decide which one will be generated .Monolingual dictionaries are read in two directions depending on its purpose : for the analysis , the reading direction is left to right ; for the generation , right to left .", "label": "", "metadata": {}, "score": "55.5485"}
{"text": "FIG .7A shows that when the surface form query word is input 81 , the look - up algorithm is applied 82 to produce from the query word its stem .Then , the new stem index can be scanned 83 for a match with the query stem .", "label": "", "metadata": {}, "score": "55.58087"}
{"text": "FIG .7A shows that when the surface form query word is input 81 , the look - up algorithm is applied 82 to produce from the query word its stem .Then , the new stem index can be scanned 83 for a match with the query stem .", "label": "", "metadata": {}, "score": "55.58087"}
{"text": "DM recognizes two different types of allomorphy : suppletive and morphophonological .Suppletive allomorphy occurs where different Vocabulary items compete for insertion into an f - morpheme .For example , Dutch nouns have ( at least ) two plural number suffixes , -en and -s .", "label": "", "metadata": {}, "score": "55.898315"}
{"text": "A commonly - assigned pending application , Ser .No .06/814,146 , filed Dec. 27 , 1985 , entitled \" ENCODING FSM DATA STRUCTURES \" , issued as U.S. Pat .No .5,450,598 and continuation cases , Ser .Nos .", "label": "", "metadata": {}, "score": "55.951626"}
{"text": "The case of cantaran or cantasen must have already been taken care of in inflection paradigms and it is unlikely to be a problem for most people extending a dictionary .In some other cases it can be necessary to introduce a restriction in the word entries of monolingual dictionaries .", "label": "", "metadata": {}, "score": "55.952293"}
{"text": "The Honalee algorithm produces all of the item sets for an LR(k ) grammar , starting with an initial item set containing an item representing an augmented grammar production .The resulting item sets are then converted into states for a deterministic finite state automaton ( DFA ) that implements a bottom - up shift - reduce LR(k ) parser for the grammar .", "label": "", "metadata": {}, "score": "55.971954"}
{"text": "Vocabulary item schema .Note that the phonological content of a Vocabulary item may any phonological string , including zero or ' null ' .The featural content or context of insertion may be similarly devoid of information : in such cases we speak of the default or elsewhere Vocabulary item .", "label": "", "metadata": {}, "score": "56.094284"}
{"text": "Rule r5 above illustrates that the LHS symbol can occur as the left - most symbol in the RHS of a rule , which is known as a left - recursive production rule .Similarly , rule r4 illustrates that the LHS symbol can occur as the right - most symbol in a rule , which is known as a right - recursive production .", "label": "", "metadata": {}, "score": "56.12852"}
{"text": "r11 .These rules define the nonterminal symbol List as being composed of either nothing or of a ' / ' symbol followed by an Items symbol .Rule r10 is an empty production since it has no symbols in its right - hand side .", "label": "", "metadata": {}, "score": "56.155937"}
{"text": "This is because expression integer + integer + integer can be produced in two ways by right - derivation .The expressions obtained by each derivation may look similar from the point of view of expression evaluation : .( integer + integer ) + integer and integer + ( integer + integer ) .", "label": "", "metadata": {}, "score": "56.21598"}
{"text": "Entirely different algorithms would have to be written for each natural language , and even the general strategy of such algorithms must change to handle the properties of prefixing and infixing languages .SUMMARY OF INVENTION .A principal object of the invention is a system of the type described which overcomes one or more of the disadvantages set forth above .", "label": "", "metadata": {}, "score": "56.296684"}
{"text": "Use of the FST of the invention is by operating the system of FIG .1 .During execution , the FST is processed or traversed for stemming or generating as described .Those skilled in the art will have no difficulty implementing the invention in the light of the teachings herein .", "label": "", "metadata": {}, "score": "56.32186"}
{"text": "Dissociated Morphemes .First , morphemes such as ' passive ' or ' case ' ( in some instances , see Marantz 1991 ) which , by hypothesis , do not figure in syntax proper , can be inserted after syntax but before Spell - Out .", "label": "", "metadata": {}, "score": "56.38552"}
{"text": "Example 8A - Another Transition Generating Item Set . i4 .+ ' num , ' + ' ] ( ' + ' , i9 ) .+ ' num , ' ) ' ] ( ' + ' , i9 ) .", "label": "", "metadata": {}, "score": "56.461864"}
{"text": "Two item sets can be merged if they have the same item cores .Note that if two item sets have identical kernel items ( not just the same kernel item cores ) , then they are identical sets and thus one of them is completely redundant , i.e. , a duplicate of the other .", "label": "", "metadata": {}, "score": "56.569008"}
{"text": "// Attempt to merge the new item set with an existing set .mergeLoop : . for each gSet in doneList , [ Note I ] .if set and gSet can be merged , [ Note C ] .( set and gSet have identical kernel item cores and .", "label": "", "metadata": {}, "score": "56.582527"}
{"text": "Fission was originally proposed in Noyer 1997 to account for situations in which a single morpheme may correspond to more than one Vocabulary item .In the normal situation , only one Vocabulary item may be inserted into any given morpheme .", "label": "", "metadata": {}, "score": "56.642662"}
{"text": "Finite - state transducers ( FSTs ) are well - known devices for encoding sets of ordered - pairs of strings .In general , an FST can be used to represent any \" regular relation \" , which includes not only finite lists of ordered string - pairs as in this example , but also certain kinds of infinite collections of ordered pairs .", "label": "", "metadata": {}, "score": "56.710243"}
{"text": "Finite - state transducers ( FSTs ) are well - known devices for encoding sets of ordered - pairs of strings .In general , an FST can be used to represent any \" regular relation \" , which includes not only finite lists of ordered string - pairs as in this example , but also certain kinds of infinite collections of ordered pairs .", "label": "", "metadata": {}, "score": "56.710243"}
{"text": "This is done by placing two periods adjacent to the side(s ) of the search string required to have non - blank characters adjacent .For example , entering .able # would help to retrieve lexical entries that correspond to a semantically defined subset of English adjectives , while avoiding entries whose meaning is defined using the verb able .", "label": "", "metadata": {}, "score": "56.71469"}
{"text": "For example , consider the nonterminal symbol Factor from the grammar in example 1 above .Examining the grammar rules makes it fairly obvious that the first terminal symbols that any derivation of Factor can possibly start with are the following terminals : . num from r3 . '", "label": "", "metadata": {}, "score": "56.772774"}
{"text": "goto('+ ' ) from i2 .num , ' + ' ] .num , ' ) ' ] .Item 1 from set i2 above ( item i2.1 ) generates the new item 1 in the new set i6 ( item i6.1 ) , and similarly , item i2.2 generates the new item i6.2 .", "label": "", "metadata": {}, "score": "56.81019"}
{"text": "This is the same as using the \" apertium - translator \" shell script provided by the Apertium package : . ca - es .( The point indicates the directory where the linguistic data are saved . )Of course , instead of typing all the presented commands every time you need to test a translation , you can create shell scripts for every action and use them to test the output of each module .", "label": "", "metadata": {}, "score": "56.816044"}
{"text": "Personally I have made my mind up and I am in the pro - hygiene camp now .I should admit that for a long time I have been in the opposite camp , preferring the simplicity of define - macro over the complexity of syntax - case .", "label": "", "metadata": {}, "score": "56.860943"}
{"text": "Semantic actions .Semantic actions are pieces of Objective CAML code executed when the parser reduces the rule they are associated with .The body of a semantic action may reference the components of the right - hand term of the rule .", "label": "", "metadata": {}, "score": "56.868633"}
{"text": "To do this , type lexeme should be known to both .This type is defined in the files with extensions .mli and . ml generated by ocamlyacc from the declaration of the token s in the matching file with extension . mly .", "label": "", "metadata": {}, "score": "56.87761"}
{"text": "Example 1 - A Simple Grammar .Terminal Symbols t1 .num t2 . '( ' t3 . ' ) ' t4 . '+ ' Rules r1 .Expr : Factor r2 .Expr : ' ( ' Expr ' ) ' r3 .", "label": "", "metadata": {}, "score": "56.902046"}
{"text": "( def - syntax ( define - a x ) # ' ( define a x ) ) .( define - a x ) apparently expand to ( define a x ) , so you may find the following surprising : .", "label": "", "metadata": {}, "score": "56.927338"}
{"text": "Now , with the new merged FST 95 , inputting a stream of characters representing document text would result in their mapping into a corresponding sequence of stems 97 in a one - step operation .LIST OF REFERENCES .[ 1 ] \" Introduction to Automata Theory , Languages and Computations \" , by Hopcraft and Ullman , published by Addison - Wesley in 1979 , particularly pages 64 - 76 .", "label": "", "metadata": {}, "score": "56.98346"}
{"text": "Now , with the new merged FST 95 , inputting a stream of characters representing document text would result in their mapping into a corresponding sequence of stems 97 in a one - step operation .LIST OF REFERENCES .[ 1 ] \" Introduction to Automata Theory , Languages and Computations \" , by Hopcraft and Ullman , published by Addison - Wesley in 1979 , particularly pages 64 - 76 .", "label": "", "metadata": {}, "score": "56.98346"}
{"text": "Factor ' + ' num , ' ( ' ] .No closure items can be generated from items 5 or 6 .At this point , the next closure item is generated from item 7 , but it is already present in the item set , so it is not added again : .", "label": "", "metadata": {}, "score": "57.15556"}
{"text": "Fortunately , shift / reduce conflicts like this are solved fairly easily .Note that the parser should , in fact , prefer to shift the ELSE symbol instead of reducing by rule 24 .This is the most general solution to shift / reduce conflicts , to prefer shifting over reducing .", "label": "", "metadata": {}, "score": "57.193798"}
{"text": "The reason for its speed advantage is that it always produces the next permutation by making just one positional swap , and it has a very clever method of deciding which pair should be swapped at each iteration .The permutations of order 4 in JTS order are : .", "label": "", "metadata": {}, "score": "57.206036"}
{"text": "Example 2B - Simple Grammar Nonterminal Symbols . n1 .Expr n2 .Factor .Programmers never see or use these nonterminal symbols directly , but they are used internally by the parser .For example , whenever an Expr is recognized by the parser , the Expr nonterminal symbol is used to represent that recognition internally within the parser 's state tables .", "label": "", "metadata": {}, "score": "57.20675"}
{"text": "Rules having no semantic actions are assigned a default action that assigns $ 1 to $ $ , provided that there is at least one RHS symbol in the rule .This is usually the most reasonable action to take for single productions .", "label": "", "metadata": {}, "score": "57.35877"}
{"text": "Factor ' + ' num , ' ) ' ]( Factor , . x8 i2 ) .Factor ' + ' num , ' + ' ]( Factor , . x8 i2 ) . i4 .goto(num ) from i0,i3,i5 . , ' ) ' ] ( ' ) ' , r3 ) M : x10 . i5 .", "label": "", "metadata": {}, "score": "57.503284"}
{"text": "Each data type is labelled : \" lexical entry \" , \" grammatical class \" , \" Spanish gloss(es ) \" , \" English gloss(es ) \" , etc .Below the label is white query box in which the user can enter a constraint on that data type .", "label": "", "metadata": {}, "score": "57.56581"}
{"text": "The main loop repeats as long as there are transition item sets in the to - do list or there are incomplete sets in the done list .done list : i0 c i1 i2 i3 i4 i5 .Phase 2 of the algorithm picks up the next incomplete item set from the done list , which is i1 : . i1 .", "label": "", "metadata": {}, "score": "57.71631"}
{"text": "This configuration shows that states s0 and s2 have been visited and shifted onto the stack , along with their corresponding symbols ' ( ' , num , and ' + ' , respectively .The current state is the right - most element of the parser stack , which in this example is state s7 .", "label": "", "metadata": {}, "score": "57.873528"}
{"text": "+ INCOMPLETE .Example XX ? -Redundant Items .Factor , ' + ' ]( Factor , - ) R .Factor , ' ( ' ]( Factor , - ) R .num , num ] ( num , - ) .", "label": "", "metadata": {}, "score": "57.91896"}
{"text": "BACKGROUND OF INVENTION .This invention relates to computerized information retrieval devices or systems , for text indexing and retrieval , databases for use in such information retrieval devices , and methods for making such databases .All natural languages allow for common elements of meaning to be systematically represented by words that appear in different forms in free text .", "label": "", "metadata": {}, "score": "57.969513"}
{"text": "This is because the rules in which a particular symbol appears in the LHS define that symbol as a nonterminal symbol .Terminal symbols , in constrast , never appear as LHS symbols .As the rules for Expr and Factor above ( rules r2 , r4 , and r5 ) illustrate , a given LHS symbol can appear as a RHS symbol in one or more of its own definitions .", "label": "", "metadata": {}, "score": "57.988155"}
{"text": "Together they would travel on a boat with shifting stacks Jackie kept a look - ahead for Puff 's reduction acts .Noble scripts and programs would bow when ' ere they ran And semantic acts would set their flags when Puff derived his scan .", "label": "", "metadata": {}, "score": "58.062534"}
{"text": "The done list is currently empty , so there are no other items sets that could be merged with the current one .The final step of phase 1 is to move the current item set to the end of the done list .", "label": "", "metadata": {}, "score": "58.172623"}
{"text": "The result of composing a normalizing transducer with a stemming transducer is a single transducer that maps the stream of punctuated characters in text into a corresponding sequence of stems .Section C of the Source Code Appendix contains is a two - level rule system from which a normalizing FST transducer 90 ( FIG .", "label": "", "metadata": {}, "score": "58.18212"}
{"text": "In the interest of uniformity , we do not advise this procedure .Precedence , associativity .We have seen that many bottom - up parsing conflicts arise from implicit operator association rules or precedence conflicts between operators .To handle these conflicts , we may declare default associativity rules ( left - to - right or non - associative ) for operators as well as precedence rules .", "label": "", "metadata": {}, "score": "58.279953"}
{"text": "Shift / reduce conflicts are the most commonly encountered type of grammatical ambiguity , and are generally easily solved .For example , the common if - then - else programming construct is , in fact , a classic example of a shift / reduce conflict : .", "label": "", "metadata": {}, "score": "58.285355"}
{"text": "Therefore , if you want to add , for example , the Spanish multiword \" hoy en d\u00eda \" ( nowadays ) , whose equivalent in Catalan is \" avui dia \" , the entries you need to add to the different dictionaries are : .", "label": "", "metadata": {}, "score": "58.302044"}
{"text": "It is not possible to construct queries that involve logical and , or , and not .However , flexibility is increased by provision for certain cover symbols for classes of phonemes or grammatical types in the Mesoamerican language data .Cover symbols are all single capital letters ; most of them are mnemonics for their categories .", "label": "", "metadata": {}, "score": "58.327133"}
{"text": "-b name : the generated Objective CAML files are name.ml and name.mli ; .-v : create a file with extension .output contaning rule numeration , the states in the automaton recognizing the grammar and the sources of conflicts .Joint usage with ocamllex .", "label": "", "metadata": {}, "score": "58.370064"}
{"text": "The result of composing a normalizing transducer with a stemming transducer is a single transducer that maps the stream of punctuated characters in text into a corresponding sequence of stems .Section C of the Appendix contains a two - level rule system from which a normalizing FST transducer 90 ( FIG .", "label": "", "metadata": {}, "score": "58.39385"}
{"text": "Factor ' + ' num , ' + ' ] .These closure items are identical to items 7 , 8 , and 9 , which are already present in the set , so they are not added to the set .", "label": "", "metadata": {}, "score": "58.408318"}
{"text": "However , flexibility is increased by provision for certain cover symbols for classes of phonemes or grammatical types in the Mesoamerican language data .Cover symbols are all single capital letters ; most of them are mnemonics for their categories .( In contrast , ordinary symbols used for the native phonemes and grammatical tags are all lower case . )", "label": "", "metadata": {}, "score": "58.523354"}
{"text": "mli containing a parsing function and its interface .A symbol is either a terminal or a non - terminal .Sections ' ' header ' ' and ' ' trailer - and - end ' ' play the same role as in ocamllex with the only exception that the header is only visible by the rules and not by declarations .", "label": "", "metadata": {}, "score": "58.55336"}
{"text": "These two rules result in an item set with the following two items : . i37 .This item set in then converted into a parser state : .ELSE Stmt ELSE shift 38 ELSE reduce 24 ... shift(s38)/reduce(r24 ) conflict on ELSE .", "label": "", "metadata": {}, "score": "58.561123"}
{"text": "Adding direction restrictions .In the previous example we have already seen the use of direction restrictions for entries with undetermined gender or number ( \" GD \" or \" ND \" ) .Restrictions can also be used in other cases .", "label": "", "metadata": {}, "score": "58.59722"}
{"text": "RHS length table Contains the number of symbols in the RHS of each rule ; indexed by rule number .Action look - up table Contains an action , either a shift / goto state , or a reduction rule ; indexed by state number and look - ahead symbol .", "label": "", "metadata": {}, "score": "58.638046"}
{"text": "In the case you are trying to improve the XML dictionaries for the Spanish - Galician pair , you will need to go to the directory apertium - es - gl and open with a text editor or a specialized XML editor the three dictionary files apertium - es - gl .", "label": "", "metadata": {}, "score": "58.654053"}
{"text": "Below the label is white query box in which the user can enter a constraint on that data type .To enter a query , click on the white screen corresponding to the desired data type .The most typical query is a search for a word of a given meaning .", "label": "", "metadata": {}, "score": "58.65782"}
{"text": "generate all closure items for set ; . mark all reduce actions in set ; . if set can be merged with existing gSet in doneList , . merge set into gSet ; . change all goto(T , set ) transitions in comeFrom . to goto(T , gSet ) ; . else . append ( still incomplete ) set to incList ; . end phase1 ; .", "label": "", "metadata": {}, "score": "58.735"}
{"text": "We can convert an FST to an FSM by the very simple transformation illustrated in FIG .9 .The result of replacing all arcs in this way is a one - tape FSM whose odd and even transitions represent the upper and lower sides of the original FST transitions , respectively .", "label": "", "metadata": {}, "score": "58.7371"}
{"text": "We can convert an FST to an FSM by the very simple transformation illustrated in FIG .9 .The result of replacing all arcs in this way is a one - tape FSM whose odd and even transitions represent the upper and lower sides of the original FST transitions , respectively .", "label": "", "metadata": {}, "score": "58.7371"}
{"text": "Traditionally it is often thought that there is a gradient between suppletion and other types of more phonologically regular allomorphy , and that no reasonable grounds can be given for how to divide the two or if they should be divided at all .", "label": "", "metadata": {}, "score": "58.787025"}
{"text": "For the rule presented below , the categories \" det \" and \" nom \" ( determiner and noun ) need to be defined here .Categories are defined specifying the grammatical symbols that the lexical forms have .An asterisk indicates that one or more grammatical symbols follow the ones specified .", "label": "", "metadata": {}, "score": "58.82759"}
{"text": "S C , t ] ; .// Create new transition items for all items shifting S .for each shItem in set , .S J , u ] , . add k to newSet ; . end if ; . end for ; .", "label": "", "metadata": {}, "score": "58.838318"}
{"text": "In Catalan , on the other hand , the noun has a different inflection for the singular and for the plural ( un gratacel , dos gratacels ) .In this case the symbol used is \" ND \" ( \" number to be determined \" ) and the entries should be like this : .", "label": "", "metadata": {}, "score": "58.855995"}
{"text": "Note F. .After merging a new transition item set with an existing set , the shift ( goto ) actions that transitioned from the previously completed set must be changed to transition instead to the merged set .Once this is done , the new transition item set can be discarded , and the merged set is used in its place .", "label": "", "metadata": {}, "score": "58.867577"}
{"text": "Initially , the stack is empty when the DFA starts in its initial state .As the parser consumes input symbols ( tokens ) and makes transitions from state to state , it pushes and pops symbols onto its stack .At any point during the parsing operation , the contents of the stack reflect the input symbols that have been consumed and recognized so far .", "label": "", "metadata": {}, "score": "58.92054"}
{"text": "Had we not restricted the import , the lexical context of # ' here would have been the entire rnrs set of identifiers .We can use dummy - ctxt to expand a macro into a minimal context .Here is an example of a trivial macro expanding into such minimal context : .", "label": "", "metadata": {}, "score": "59.031532"}
{"text": "The device of claim 3 , wherein the second transducer was produced using composition and intersecting algorithms to combine the third and fourth transducers .The device of claim 1 , wherein the FST comprises branches of only stem / variant pairs .", "label": "", "metadata": {}, "score": "59.06771"}
{"text": "Proceedings of the 13th International Conference on Computational Lingustics .vol .University of Helsinki .Tzoukermann , E. and M. Y. Liberman .M. A Finite - State Morphological Processor for Spanish .Proceedings of the 13th International Conference on Computational Lingustics .", "label": "", "metadata": {}, "score": "59.145958"}
{"text": "The non - kernel closure items of this set can be ignored for the purposes of examining the kernel item core of the set , which is simply : .Impossible Item Set Merges .There are situations in which two item sets have identical kernel item cores but still can not be merged , because merging items from both sets would produce reduce / reduce conflicts .", "label": "", "metadata": {}, "score": "59.16295"}
{"text": "In that case , once you have added the new Spanish word \" genoma \" to the Spanish monolingual dictionary ( apertium - es - gl .es.dix ) , you have to add the equivalent Galician word \" xenoma \" to the Galician monolingual dictionary ( apertium - es - gl . gl.dix ) , that is : .", "label": "", "metadata": {}, "score": "59.20668"}
{"text": "Similarly , the first symbol set for nonterminal Expr contains the symbol ' ( ' ( from rule r2 ) and all of the first symbols for nonterminal Factor as well ( from rule r1 ) .This gives the following set of terminal symbols : . '", "label": "", "metadata": {}, "score": "59.374905"}
{"text": "Finally , I spend some word on non - hygienic macro systems versus hygienic systems .Breaking hygiene .In the previous episode I said that hygienic macros are good , since they solve the variable capture problem .However , purely hygienic macros introduce a problem of their own , since they make it impossible to introduce variables at all .", "label": "", "metadata": {}, "score": "59.514782"}
{"text": "Thus an LR(1 ) parser uses one symbol of look - ahead , which means that the parser keeps track of , or looks ahead at , one token read by the lexer at any point during a parse .An LR(2 ) parser uses two look - ahead symbols , and so forth for all useful values of k .", "label": "", "metadata": {}, "score": "59.57743"}
{"text": "Symbols .A grammar is composed of one or more symbols , which define the various words and punctuation allowed by the grammar .The symbols of a grammar come in two flavors : terminal symbols and nonterminal symbols .Terminal symbols are the primitive words and punctuation defined by the grammar .", "label": "", "metadata": {}, "score": "59.5828"}
{"text": "Likewise , no closure items can be generated from items 8 , 9 , 11 , or 12 .Items 10 and 13 generate the following closure items , but they too are already present in the item set : .Factor , ' + ' ] .", "label": "", "metadata": {}, "score": "59.79506"}
{"text": "( m ) expand to 43 since in the lexical context where the macro is invoked x is bound to 43 .However , this behavior is quite surprising , and most likely not what it is wanted .This is actually another example of the free - symbol capture problem .", "label": "", "metadata": {}, "score": "59.847084"}
{"text": "only kernel and reduce items from set need to be . merged into gSet ; . else .all non - duplicate items from set need to be . merged into gSet ; .( optional ) set any shift / goto actions on symbol s . to the same gotos existing in gSet items ; .", "label": "", "metadata": {}, "score": "59.85416"}
{"text": "( Note that that there is also a gender change in the case of \" mu\u00f1eca \" ( feminine ) and \" canell \" ( masculine ) ) .For example , the Catalan lemmas \" mot \" and \" paraula \" can be both translated into Spanish as \" palabra \" ( word ) and the entry in the bilingual dictionary should look like this : .", "label": "", "metadata": {}, "score": "59.85601"}
{"text": "First , the resulting stem strings are frequently not words of English ( sw , arriv ) .They can not be presented to a naive user who might want to confirm that his query is being interpreted in a sensible way .", "label": "", "metadata": {}, "score": "59.89681"}
{"text": "Reduction items are shown with their rule number : .+ ' num .The items that shift the same symbol are combined into a single parser table entry .Items 3 , 4 , and 5 all shift the same symbol ' + ' , thus producing the following parser action : . '", "label": "", "metadata": {}, "score": "59.910206"}
{"text": "For Spanish - Galician pair , if you want to add , for example , the Spanish multiword \" manga por hombro \" ( disarranged ) , whose equivalent in Galician is \" sen xeito nin modo \" , the entries you need to add are : .", "label": "", "metadata": {}, "score": "60.13074"}
{"text": "In the bilingual dictionary you will need to add , in this case , more than one entry with direction indications , as you must specify in which translation direction the gender remains undetermined .The entries for this adjective should be as follows : . \" LR \" means \" left to right \" , and \" RL \" , \" right to left \" .", "label": "", "metadata": {}, "score": "60.20604"}
{"text": "Picking up the action in phase 2 of the loop that pops i3 from the done list , this item set looks like this : . i3 .A new transition item set is generated from items 2 , 8 , and 9 : .", "label": "", "metadata": {}, "score": "60.215263"}
{"text": "( Factor , i8 ) .The new transition set i8 looks like this : . i8 .This new transition set gets put on the to - do list , and eventually is popped off the list in phase 1 of a subsequent iteration of the main loop .", "label": "", "metadata": {}, "score": "60.233253"}
{"text": "[ 3 ] \" Finite - state Constraints \" by Lauri Karttunen , International Conference on Current Issues in Computational Linguistics .Jun. 10 - 14 , 1991 .Universiti Sains Malaysia , Penang , Malaysia .To appear in The Last Phonological Rule : Reflections on Constraints and Derivations , ed . by John Goldsmith , University of Chicago Press .", "label": "", "metadata": {}, "score": "60.304924"}
{"text": "[ 3 ] \" Finite - state Constraints \" by Lauri Karttunen , International Conference on Current Issues in Computational Linguistics .Jun. 10 - 14 , 1991 .Universiti Sains Malaysia , Penang , Malaysia .To appear in The Last Phonological Rule : Reflections on Constraints and Derivations , ed . by John Goldsmith , University of Chicago Press .", "label": "", "metadata": {}, "score": "60.304924"}
{"text": "The canonical example for top - down parsing is the prefix notation of arithmetic expressions defined by : .Expr .In this case , knowing the first lexeme is enough to decide which production rule can be used .This immediate predictability obviates managing the parse stack explicitly by instead using the stack of recursive calls in the parser .", "label": "", "metadata": {}, "score": "60.326523"}
{"text": "Converting Reduction Actions .States with reduce actions are converted into states in a slightly different manner .Consider item set i2 that was generated above , which contains reduce actions : . i2 .When displaying this as a state , only the item cores are shown .", "label": "", "metadata": {}, "score": "60.390987"}
{"text": "Grammar .Formally , a grammar is made up of four elements : . a set of symbols called terminals .Such symbols represent the lexical units of the language ., the keywords of the language ( GOTO , PRINT , IF , THEN , . , integers ( integer units ) and variables ( variable units ) .", "label": "", "metadata": {}, "score": "60.41702"}
{"text": "In Dalrymple , M. et al .Tools for Morphological Analysis .Center for the Study of Language and Information .Stanford University .Palo Alto .Kay , Martin .Nonconcatenative Finite State Morphology .Proceedings of the 3rd Conference of the European Chapter of the Association for Computational Linguistics .", "label": "", "metadata": {}, "score": "60.483177"}
{"text": "Proceedings of the 13th International Conference on Computational Linguistics .vol .University of Helsinki .Helsinki .Using the online dictionaries .The dictionaries differ among each other in some respects , but the basic retrieval strategies are the same .", "label": "", "metadata": {}, "score": "60.504536"}
{"text": "Expr ' + ' Factor .Factor num ( 42 ) .num ( 69 ) .Since a YACC - like parser employs a single stack for symbols , this implies that terminal symbols ( tokens ) and nonterminal ( LHS ) symbols must be represented by the same object type .", "label": "", "metadata": {}, "score": "60.514763"}
{"text": "Factor ' + ' num , ' ) ' ] ( - , - ) merged .Factor ' + ' num , ' + ' ] ( - , - ) .i8 .x12 .goto(Factor ) from i5 .", "label": "", "metadata": {}, "score": "60.558784"}
{"text": "// Do a Goto transition on the nonterminal LHS symbol .end if ; . else .// No action was found for unexpected look - ahead symbol . invoke parser error handler ; .// Begin error recovery .push error symbol onto valueStack ; . look for a transition on ' error ' in the current state ; .", "label": "", "metadata": {}, "score": "60.619717"}
{"text": "The index mapping functions use Variant ( Decimal ) variables where required , which gives us access to what are effectively triple - length Longs ' ( 96-bit integers ) .These are self - contained , and use no external variables .", "label": "", "metadata": {}, "score": "60.6344"}
{"text": "Vocabulary Items .In Dutch , after syntax , a dissociated morpheme is inserted as a right - adjunct of morphemes which are conventionally labeled ' adjectives . 'The Vocabulary items above compete for insertion into this morpheme .In the specific environment of the neuter singular , zero is inserted .", "label": "", "metadata": {}, "score": "60.65561"}
{"text": "The items shifting nonterminal symbols are shown next , since these comprise the goto transitions for the state .The resulting actions are therefore displayed as : . '( ' shift 3 num shift 4 ' + ' shift 5 Expr goto 1 Factor goto 2 .", "label": "", "metadata": {}, "score": "60.717007"}
{"text": "Leaners ( Zwicky 1985a ) are Vocabulary items which can not form Phonological Words by themselves but whose morphemes have no other special displacement properties .For example , the English reduced auxiliary -s ( from is ) ' promiscuously ' attaches to any phonological host to its left ( Zwicky & Pullum 1983 ): .", "label": "", "metadata": {}, "score": "60.90529"}
{"text": "This is applied to the example grammar rule shown above by adding a semantic action : .These operands are translated into method calls to retrieve values from the terminal and nonterminal parser stacks .The method returns a nonterminal value representing the result of the semantic action , which is assigned to $ $ .", "label": "", "metadata": {}, "score": "61.07649"}
{"text": "Proceedings of the Third Conference on Applied Natural Language Processing .Trento , Italy , Apr. 1992 .Development of a Stemming Algorithm , J. B. Lovins , Mechanical Translation And Computational Linguistics , 11 , pp .22 31 , Mar. 1968 .", "label": "", "metadata": {}, "score": "61.19152"}
{"text": "Pop nonterminal X from the head of the queue ; .Step 3 .// Compute a partial first(X ) set for X .For rules with X as a LHS symbol , ' X : epsilon ' .( i.e. , rules for X with no RHS terminal symbols ) , . add epsilon to first(X ) ; .", "label": "", "metadata": {}, "score": "61.26619"}
{"text": "We now introduce the ocamlyacc tool which uses the bottom - up parsing technique and may find these conflicts .The ocamlyacc Tool .The ocamlyacc tools is built with the same principles as ocamllex : it takes as input a file describing a grammar whose rules have semantic actions attached , and returns two Objective CAML files with extensions .", "label": "", "metadata": {}, "score": "61.339504"}
{"text": "Rather , Vocabulary items accrete on the sister of the fissioned morpheme until all Vocabulary items which can be inserted have been or all features of the morpheme have been discharged .A feature is discharged when the insertion of a Vocabulary item is primarily conditioned by that feature .", "label": "", "metadata": {}, "score": "61.435997"}
{"text": "This is quite good - you can choose any K ( number of balls to pick ) for all values of N up to 99 .But you 'd normally use smaller K anyway , so that lets you increase N even further - e.g. you can model 10-from-1000 .", "label": "", "metadata": {}, "score": "61.452343"}
{"text": "6A , which indicates that a first set of rule transducers fst 1 . . .fst n 61 , 62 , 63 are intersected , as indicated by the ampersand symbol .We have observed that in practice performing this intersection can take a very large amount of time , even on a powerful workstation , and the resulting transducer is extremely large .", "label": "", "metadata": {}, "score": "61.516895"}
{"text": "6A , which indicates that a first set of rule transducers fst 1 . . .fst n 61 , 62 , 63 are intersected , as indicated by the ampersand symbol .We have observed that in practice performing this intersection can take a very large amount of time , even on a powerful workstation , and the resulting transducer is extremely large .", "label": "", "metadata": {}, "score": "61.516895"}
{"text": "// Process the next incomplete item set in the done list . if incList not empty , .// Generate new transition sets for all shift items in set .transitionLoop : . for each item in set , . if item.action not null , . skip item , continue transitionLoop ; .", "label": "", "metadata": {}, "score": "61.55941"}
{"text": "A principal object of the invention is a system of the type described which overcomes one or more of the disadvantages set forth above .Another object of the invention includes systems capable not only of text indexing and retrieval using stemming , but also systems capable of significantly enhancing responses to user queries by employing stemming .", "label": "", "metadata": {}, "score": "61.637943"}
{"text": "num t2 . '( ' t3 . ' ) ' t4 . 'This is a very simple example - real programming languages typically have a few dozen terminal symbols , including punctuation symbols and reserved keyword symbols .The Java language , for instance , has about twenty or so keywords , such as ' if ' , ' public ' , ' boolean ' , ' this ' , and so forth .", "label": "", "metadata": {}, "score": "61.712215"}
{"text": "First Sets .In order to construct item sets for a grammar , it is necessary to generate all of the closure items for a given set ( see below ) .The procedure for doing this requires knowing the first symbols for all of the nonterminal symbols in the grammar .", "label": "", "metadata": {}, "score": "61.752403"}
{"text": "Second , since processes produce allomorphs but do not directly ' discharge ' features , it is common for an allomorph to have several contexts of use .For example , in Papago the truncated verb stem allomorph has several functions , including but not limited to its use in the perfective form , and the property of perfectivity is primarily expressed in another morpheme , namely an affix on the syntactic auxiliary .", "label": "", "metadata": {}, "score": "61.786522"}
{"text": "Tzoukermann , E. and M. Y. Liberman .M. A Finite State Mophological Processor for Spanish .Proceedings of the 13th International Conference on Computational Linguistics .vol .University of Helsinki .Helsinki .Tzoukermann , E. and M. Y. Liberman .", "label": "", "metadata": {}, "score": "61.868736"}
{"text": "However , allowing the reduce to occur is allowable behavior because the symbols recognized by the parser up this point do in fact result in a valid reduction by the default rule .In the example , the current parser stack contains a Factor symbol ( because state 2 is entered by shifting a Factor symbol ) , which does indeed match LHS symbol Expr by rule 1 .", "label": "", "metadata": {}, "score": "61.934364"}
{"text": "This would be a problem even for a mainframe , yet an important segment of users employs PCs with more limited CPU and memory resources .In accordance with further features of the present invention , we describe a number of techniques that make such FSTs practical for information retrieval stemming even with a modestly priced PC with limited RAM .", "label": "", "metadata": {}, "score": "62.069695"}
{"text": "This would be a problem even for a mainframe , yet an important segment of users employs PCs with more limited CPU and memory resources .In accordance with further features of the present invention , we describe a number of techniques that make such FSTs practical for information retrieval stemming even with a modestly priced PC with limited RAM .", "label": "", "metadata": {}, "score": "62.069695"}
{"text": "Programmers provide their own implementation class for lexer token objects which implement this interface , or they can use the TokenAdapter class that is also provided with the YACC / M runtime library ( which provides basic functionality for implementing simple lexical token objects ) .", "label": "", "metadata": {}, "score": "62.10195"}
{"text": "Phase 2 now begins , which examines the first incomplete item set in the done list , which is the initial item set i0 that was just put into the list .Transition item sets are now generated for all of the shift items in the set .", "label": "", "metadata": {}, "score": "62.138283"}
{"text": "The process of going the other way , from a stem to all its variant forms , is often called synthesis or generation .Stemming can play an important role in full - text indexing and retrieval of natural language documents .", "label": "", "metadata": {}, "score": "62.229836"}
{"text": "From Catalan to Spanish , both words can be translated as \" mu\u00f1eca \" without any problem .You have to specify all these circumstances in the dictionary entries using direction restrictions ( \" LR \" meaning \" left to right \" , that is , Spanish - Catalan , and \" RL \" meaning \" right to left \" , that is , Catalan - Spanish ) .", "label": "", "metadata": {}, "score": "62.27838"}
{"text": "Number marking has no other expression than truncation .The ' Martian ' rule of plural formation is easy to express in a process - morphology : instead of adding an affix , one simply deletes the final syllable .In DM however , this language could never be generated , because processes like ' delete the final syllable ' could only be expressed as Readjustments which affect individual Vocabulary items .", "label": "", "metadata": {}, "score": "62.539227"}
{"text": "Stanford University .Palo Alto .[ 7 ] Kay , Meatin .Nonconcatenative Finite State Morphology .Proceedings of the 3rd Conference of the European Chapter of the Association for Computational Linguistics .Copenhagen 1987 .[ 8 ] Ashdown \" Minimizing Finite State Machines \" , Embedded Systems Programming , Premier 1988 , pages 57 - 66 .", "label": "", "metadata": {}, "score": "62.601173"}
{"text": "When we find an identifier we may be interested in recovering its character string .% token IDENT .Warning .After being processed by ocamlyacc all these declarations are transformed into constructors of type token .Therefore , they must start with a capital letter .", "label": "", "metadata": {}, "score": "62.62733"}
{"text": "& who : eval 3 .& message : \" unbound variable \" 4 .& irritants : ( a ) .Why is the variable a not bound to 1 ?The problem is that hygienic macros never introduce identifiers implicitly .", "label": "", "metadata": {}, "score": "62.6313"}
{"text": "This means that in practice only the core of item 1 is actually displayed : .Expr .The items that shift the same symbol are combined into a single parser table entry .Item 1 shifts symbol Expr , items 2 , 8 , and 9 shift Factor , item 3 shifts ' ( ' , items 4 and 5 shift num , and items 6 and 7 shift ' + ' .", "label": "", "metadata": {}, "score": "62.734573"}
{"text": "Item 1 shifts symbol Expr , so a new transition item set i1 is created .All of the items in set i0 that shift symbol Expr are marked , which in this case is just item 1 .New kernel items are generated in the new transition set : . i1 .", "label": "", "metadata": {}, "score": "62.886"}
{"text": "Palo Alto .Kay , Martin .Nonconcatenative Finite State Morphology .Proceedings of the 3rd Conference of the European Chapter of the Association for Computational Linguistics .Copenhagen 1987 .Koskenniemi , K. Two level Morphology .A General Computational Model for Word Form Recognition and Production .", "label": "", "metadata": {}, "score": "62.89102"}
{"text": "This is why this situation is called a shift / reduce conflict - because either action is possible , thus causing a conflict .Without any way of resolving the conflict , the parser can not decide whether to shift the ELSE symbol and proceed to state 38 , or to reduce by rule 24 when it sees the ELSE look - ahead symbol .", "label": "", "metadata": {}, "score": "62.99715"}
{"text": "Items marked with an R are redundant , and can be removed from the item set without affecting subsequent merge operations .The resulting set after redundant item elimination look like this : .Example XX ? -Redundant Items Eliminated .", "label": "", "metadata": {}, "score": "63.172764"}
{"text": "University of Helsinki .Performance and Architectural Issues for String Matching Isenman , M. , et al . , IEEE Transactions on Computers , vol .39 , No . 2 , Feb. 1990 , New York , U.S.A. .State Machines Find the Pattern , Kimbrell , R.E. , Computer Design , vol .", "label": "", "metadata": {}, "score": "63.275124"}
{"text": "14 , No.3 , pages 130 - 137 , July 1980 .[ 10 ] \" The Theory of Machinery Computation \" , K. Kohavi , Ed . , pages 189 - 196 , Academic Press , NY 1971 .[11 ] Aho and Ullman \" Principles of Compiler Design \" , Addison - Wesley , 1977 , pages 99 - 103 , 114 - 117 .", "label": "", "metadata": {}, "score": "63.30197"}
{"text": "14 , No.3 , pages 130 - 137 , July 1980 .[ 10 ] \" The Theory of Machinery Computation \" , K. Kohavi , Ed . , pages 189 - 196 , Academic Press , NY 1971 .[11 ] Aho and Ullman \" Principles of Compiler Design \" , Addison - Wesley , 1977 , pages 99 - 103 , 114 - 117 .", "label": "", "metadata": {}, "score": "63.30197"}
{"text": "// based on the current state and look - ahead symbol .if action is SHIFT , .// Shift the current look - ahead terminal symbol .push laSym onto parser termStack ; . push state 0 onto stateStack ; .", "label": "", "metadata": {}, "score": "63.487617"}
{"text": "YACC / M also allows the programmer to specify a class type for the nonterminal stack , which is implemented as an array of objects of the type specified by the % stacktype directive .If this directive is not given , the default type is simply Object .", "label": "", "metadata": {}, "score": "63.571262"}
{"text": "For example , Harley 1995 proposes that Agent is the interpretation given to any argument projected into the specifier of Event Phrase ( see alsoTravis 1994 on \" Event Phrase \" , and Kratzer 1996 for related ideas ) .Theme is the interpretation given to any argument projected as a sister of Root .", "label": "", "metadata": {}, "score": "63.77745"}
{"text": "Jun. 10 14 , 1991 .Universiti Sains Malaysia , Penang , Malaysia .To appear in The Last Phonological Rule : Reflections on Constraints and Derivations , ed . by John Goldsmith , University of Chicago Press .Introduction to Automata Theory , Languages and Computation , Holcraft and Ullman , 1979 , Addison Wesley Publishing Co. , pp .", "label": "", "metadata": {}, "score": "63.84215"}
{"text": "The hygiene problem is more serious in Lisp-1 dialects like the newborns Arc and Clojure .Arc macros behave just like define - macro and are fully unhygienic , whereas Clojure macros are rather special , being nearly hygienic .In particular Clojure macros are not affected by the free - symbol capture problem : .", "label": "", "metadata": {}, "score": "63.913742"}
{"text": "// Move the new ( still incomplete ) set to the incomplete list . if set not null ( was not merged or a duplicate ) , . append set to end of doneList ; [ Note I ] . if incList is empty , . end if ; . end phase1 ; .", "label": "", "metadata": {}, "score": "63.948376"}
{"text": "Deterministic Finite Automata ( DFA ) Parsers .It was mentioned above that a parser for a grammar can be implemented as a deterministic finite automaton ( DFA ) .An automaton is simply a machine embodying a set of states and which reads input symbols and acts on them .", "label": "", "metadata": {}, "score": "64.035934"}
{"text": "// Phase 1 .// Process item sets on the to - do list , merging them with existing .// sets or moving them to the incomplete list . phase1 : . while toDoList not empty , .generate all closure items for set ; [ Note A ] .", "label": "", "metadata": {}, "score": "64.07066"}
{"text": "The symbol \u03b5 at the end is Epsilon which acts as a NULL symbol to allow the FST to continue to process even if comparable characters are not present .See also reference [ 3].Thus , for the simple situation depicted in FIG .", "label": "", "metadata": {}, "score": "64.07628"}
{"text": "The symbol \u03b5 at the end is Epsilon which acts as a NULL symbol to allow the FST to continue to process even if comparable characters are not present .See also reference [ 3].Thus , for the simple situation depicted in FIG .", "label": "", "metadata": {}, "score": "64.07628"}
{"text": "The parse proceeds as follows , showing each step in the parsing process : .( Note that $ end is a special symbol denoting the end of the input stream . )These parsing steps and production rules trace out the following derivation tree ( also called a parse tree ): .", "label": "", "metadata": {}, "score": "64.11039"}
{"text": "The method of claim 18 wherein the step of combining comprises combining the third and fourth FSTs using intersecting composition .Description .This application is a division of application Ser .No . 07/916,576 , filed Jul. 20 , 1992 , pending .", "label": "", "metadata": {}, "score": "64.20375"}
{"text": "Rather , these Vocabulary items can be freely inserted at Spell - Out subject to conditions of licensing .Licensers are typically f - morphemes in certain structural relations to the Root where the Vocabulary item is inserted . 'Nouns ' are licensed by Determiner ; different verb classes , such as unergatives , unaccusatives , and transitives , each are licensed by different structural configurations and relations to various higher eventuality projections .", "label": "", "metadata": {}, "score": "64.25951"}
{"text": "first(X ) is complete .( and nonterminal X is no longer in the queue ) ; . end loop ; . end .Note that this algorithm works even with nonterminals having mutually recursive first symbol sets .Factor ' + ' num , ' + ' ] .", "label": "", "metadata": {}, "score": "64.30118"}
{"text": "Its gender is ( masculine - feminine ) since it is invariable in gender , that is , it can go both with masculine and feminine nouns ( hombre canadiense , mujer canadiense ) .In Catalan , on the other hand , the adjective has a different inflection for the masculine and the feminine ( home canadenc , dona canadenca ) .", "label": "", "metadata": {}, "score": "64.402306"}
{"text": "( Factor , i8 )M : x11 .Factor ' + ' num , ' + ' ]( Factor , i8 ) .i6 .goto('+ ' ) , from i2,i8 . i7 .goto(Expr ) , from i3 . x8 .", "label": "", "metadata": {}, "score": "64.428116"}
{"text": "Assume , for example , that the parser enters state 2 above with a look - ahead symbol of ' ( ' .The parser will not find a shift action for symbol ' ( ' , so it selects the default action , which is to reduce by rule 1 .", "label": "", "metadata": {}, "score": "64.54884"}
{"text": "Closure items are generated for a given set initially from the kernel items , and then from any newly generated closure items themselves , repeatedly until no more ( non - duplicate ) closure items can be added to the item set .", "label": "", "metadata": {}, "score": "64.55728"}
{"text": "Bottom - Up Parsing .The theory behind bottom - up LR(k ) parsers , also called shift - reduce parsers , was invented in 1965 by Donald Knuth ( author of the famed The Art of Programming books ) .He devised the formal symbolic mathematics behind the operation of a deterministic finite automaton , or DFA , operating as a parsing machine that reads lexical symbols from a source sentence provided as its input , and proceeds to recognize productions comprising a particular grammar .", "label": "", "metadata": {}, "score": "64.739426"}
{"text": "Clitic ' is not a primitive type in DM but rather a behavior which an element may display .Conventionally , clitics are said to ' lean ' on a ' host ' ; this sort of dependency relation of one element on another manifests itself differently depending on what the element is and where its dependency relation must be satisfied .", "label": "", "metadata": {}, "score": "64.77464"}
{"text": "The symbol on the left - hand side of a rule ( to the left of the ' : ' mark ) is called the left - hand side or LHS symbol .Similarly , the symbols that appear on the right - hand side of the rule ( to the right of the ' : ' mark ) are called the right - hand or RHS symbols .", "label": "", "metadata": {}, "score": "64.93549"}
{"text": "+ MOVE Note that multiple rules having the same LHS symbol can be combined into a single definition , but this is not required .The first two production rules could just have easily been defined like this : . which is equivalent to defining two separate rules : .", "label": "", "metadata": {}, "score": "65.05101"}
{"text": "Stanford University .Palo Alto .[ 7 ] Kay , Martin .Nonconcatenative Finite State Morphology .Proceedings of the 3rd Conference of the European Chapter of the Association for Computational Linguistics .Copenhagen 1987 .[ 8 ] Ashdown \" Minimizing Finite State Machines \" , Embedded Systems Programming , Premier 1988 , pages 57 - 66 .", "label": "", "metadata": {}, "score": "65.090866"}
{"text": "x10 i4 ) .num , ' + ' ] ( num , .x10 i4 ) .+ ' Factor , ' ) ' ] ( ' + ' , .x11 i5 ) .+ ' Factor , ' + ' ] ( ' + ' , .", "label": "", "metadata": {}, "score": "65.11165"}
{"text": "The usual way to contribute is to use CVS ; as a project member , you will be able to commit your changes to dictionaries directly .You should be aware that the data you contribute to the project , once added , will be freely distributed under the current license ( GNU General Public License or Creative Commons 2.5 attribution - sharealike - noncommercial , as indicated ) .", "label": "", "metadata": {}, "score": "65.18002"}
{"text": "The most typical query is a search for a word of a given meaning .For example , one way to enter a query to find a word meaning ' right ' is to click on the \" English gloss(es ) \" box , and then type right in the box .", "label": "", "metadata": {}, "score": "65.18198"}
{"text": "i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) i1 .Factor , ' ) ' ]( Factor , . x8 i2 ) .( ' Expr ' ) ' , ' ) ' ] ( ' ( ' , . x9 i3 ) .", "label": "", "metadata": {}, "score": "65.23938"}
{"text": "Such a rule is called degenerate , and is considered erroneous .It is also possible for rules to be specified that have no RHS symbols at all .These are called empty ( or epsilon ) productions .For example : . r10 .", "label": "", "metadata": {}, "score": "65.652245"}
{"text": "+ ' num , ' + ' ] ( ' + ' , . i9 i6 ) .+ ' num , ' ) ' ] ( ' + ' , . i9 i6 ) .num , ' + ' ] .", "label": "", "metadata": {}, "score": "65.78139"}
{"text": "English leaners are typically free clitics , according to Selkirk , but other languages exploit other options .For example , Embick 1995 shows that , depending on their syntactic provenance , Polish clitics behave phonologically as either affixal clitics ( allowing their host to undergo word - domain phonology ) , or as internal clitics ( preventing their host from undergoing word - domain phonology on its own ) .", "label": "", "metadata": {}, "score": "65.83177"}
{"text": "For l - morphemes there is a choice regarding which Vocabulary item is inserted .For example , a Root morpheme in an appropriately local relation to a Determiner might be filled by cat , dog , house , table or any other Vocabulary item we would normally call a ' noun . '", "label": "", "metadata": {}, "score": "66.18886"}
{"text": "For example , in English , the common meaning of \" arrive \" is carried by the inflectional variants \" arrived \" , \" arrives \" , and \" arriving \" ( as well as \" arrive \" itself ) , and by the derivational variant \" arrival \" .", "label": "", "metadata": {}, "score": "66.22389"}
{"text": "Since in such lexical context the built - in car is not defined , the expansion fails : .& undefined 2 .& who : eval 3 .& message : \" unbound variable \" 4 .& irritants : ( car ) .", "label": "", "metadata": {}, "score": "66.26163"}
{"text": "combinations(50,6 ) 15,890,700 ?index2combination(50 , 6 , 7945351 ) 6 , 8 , 19 , 20 , 36 , 37 .The mapping functions allow us to divide the full virtual set into a nice regular grid , and section it accordingly .", "label": "", "metadata": {}, "score": "66.28415"}
{"text": "num , ' ( ' ] ( num , - ) R .+ ' Factor , num ] ( ' + ' , - ) .+ ' Factor , ' + ' ] ( ' + ' , - ) R .", "label": "", "metadata": {}, "score": "66.31604"}
{"text": "Any answer not entirely right 's going to be marked as an error .Selkirk 1996 analyzes prosodically dependent function words as either free clitics ( adjuncts to Phonological Phrases ) , affixal clitics ( adjuncts to Phonological Words ) or internal clitics ( incorporated into Phonological Words ) .", "label": "", "metadata": {}, "score": "66.47041"}
{"text": "Proceedings of the Third Conference on Applied Natural Language Processing .Trento , Italy , April 1992 .# # SPC1 # # . \" Finite - state Constraints \" by Lauri Karttunen , International Conference on Current Issues in Computational Linguistics .", "label": "", "metadata": {}, "score": "66.49014"}
{"text": "We understand these tools are used by Lotto - style game analysers , and while we personally feel this is an exercise whose profitability ( in fiscal terms ) is extremely dubious from a purely mathematical point of view .... .nevertheless ! !", "label": "", "metadata": {}, "score": "66.51811"}
{"text": "In phase 1 of the main loop , the first item set is popped off the front of the to - do list , which is the initial item set i0 just created .Closure items are then generated for the set .", "label": "", "metadata": {}, "score": "66.62259"}
{"text": "To add a word , you will have to create an entry with the same structure .Now , you have to decide which is the lexical category of the word you want to add .The word \" c\u00f3smico \" is an adjective , like \" bonito \" .", "label": "", "metadata": {}, "score": "66.71762"}
{"text": "( first(P ) may still be incomplete at this point . )Step 6 .For all rules with X as LHS symbol , of the form ' X : P B ... ' , . if first(P ) contains epsilon , . repeat steps ( 3 ) through ( 6 ) with nonterminal B .", "label": "", "metadata": {}, "score": "66.924416"}
{"text": "The input 91 would be a stream of characters from the document text .The output 92 would be normalized lowercase text containing only the individual words to be indexed .FIG . 8B illustrates a further feature of the invention , which is how to compose 94 the normalizing FST 90 with the stemming FST 70 of FIG .", "label": "", "metadata": {}, "score": "67.024796"}
{"text": "The input 91 would be a stream of characters from the document text .The output 92 would be normalized lowercase text containing only the individual words to be indexed .FIG . 8B illustrates a further feature of the invention , which is how to compose 94 the normalizing FST 90 with the stemming FST 70 of FIG .", "label": "", "metadata": {}, "score": "67.024796"}
{"text": "Expr : Factor r2 .Expr : ' ( ' Expr ' ) ' r3 .Factor : num r4 .Factor : ' + ' Factor r5 .Factor :Factor ' + ' num .These rules specify , for instance , the sequence of symbols that constitute an Expr , which is either a Factor or another Expr enclosed within ' ( ' and ' ) ' symbols .", "label": "", "metadata": {}, "score": "67.06154"}
{"text": "-neuter ] [ + neuter ] [ -pl ] zero t [ + pl ] e e .WEAK [ -neuter ] [ + neuter ] [ -pl ] e e [ + pl ] e e .Sauerland 1995 proposes the following set of Vocabulary items : .", "label": "", "metadata": {}, "score": "67.103"}
{"text": "These characters comprise the following Java lexical tokens : . if reserved keyword .( punctuation operator .ch identifier . a ' character constant . ) punctuation operator .return reserved keyword .- - - punctuation operator .1 integer constant .", "label": "", "metadata": {}, "score": "67.563675"}
{"text": "begin // Initialize .// Main parsing loop .mainLoop : . while stateStack not empty , .// Insure that there is a look - ahead symbol .if laSym is null , .( which is $ end on end of input ) ; .", "label": "", "metadata": {}, "score": "67.66012"}
{"text": "( There also exist non - deterministic automatons ( NFAs ) , which are different in that they may have transitions from one state to another without regard to the current input symbol , called epsilon transitions .These kinds of state machines are not discussed here . )", "label": "", "metadata": {}, "score": "67.91148"}
{"text": "+ ' Factor , ' ) ' ] ( ' + ' , .x14 i5 )M : x11 .+ ' Factor , ' + ' ] ( ' + ' , .x14 i5 ) .Factor ' + ' num , $ end ] ( Factor , i8 ) .", "label": "", "metadata": {}, "score": "67.91295"}
{"text": "DM hypothesizes that in such cases there is a single basic allomorph , and the others are derived from it by a rule of Readjustment .The Readjustment in this case replaces the Rime of the final syllable of destroy with -uct .", "label": "", "metadata": {}, "score": "68.07419"}
{"text": "Odometer - style Generators .These are like odometers , you keep a table with a \" wheel \" for each element in the set .You start it at \" 1 2 3 4 5 ... \" , and then you \" rotate \" it with successive calls to a NextCombination function which advances the wheels to the next position .", "label": "", "metadata": {}, "score": "68.118706"}
{"text": "For all rules with X as LHS symbol , of the form ' X : P B ... ' .with nonterminal symbol P as the leftmost RHS symbol , . and where P is not X , . add to first(X ) all terminal symbols other than epsilon .", "label": "", "metadata": {}, "score": "68.12321"}
{"text": "+ MOVE THIS PARA .When a reduce occurs , a reduction action can be performed for the rule as well .Such an action is usually a small block of code executed by the parser just before the RHS symbols are replaced by the LHS symbol .", "label": "", "metadata": {}, "score": "68.523224"}
{"text": "x11 .num , ' ) ' ] ( - , - ) merged .num , ' + ' ] ( - , - ) .+ ' Factor , ' ) ' ] ( - , - ) merged .", "label": "", "metadata": {}, "score": "68.57632"}
{"text": "The following pseudo - code is the Honalee Algorithm for constructing item sets for an LR(k ) grammar .// The Honalee Algorithm - LR(k ) Item Set Construction ( summarized ) .create initial item set i0 ; . append i0 to end of toDoList ; .", "label": "", "metadata": {}, "score": "68.691055"}
{"text": "Mireia Ginest\u00ed : mginesti [ at ] dlsi [ dot ] ua [ dot ] es .Spanish - Portuguese data .Carme Armentano : carmentano [ at ] dlsi [ dot ] ua [ dot ] es .Spanish - Galician data .", "label": "", "metadata": {}, "score": "68.90533"}
{"text": "For example , consider the following rule : .Expr : Expr ' + ' Factor .When reduced by the parser , the semantic action associated with this rule can create a parse tree to embody the expression , such as : .", "label": "", "metadata": {}, "score": "68.958786"}
{"text": "They may be ( non - kernel ) closure items generated from the kernel items in the set if they are epsilon productions , i.e. , if they have no RHS symbols .( A closure item has its marker positioned to the left of all of its RHS symbols , and if it has no RHS symbols , it will therefore be a reduction item . )", "label": "", "metadata": {}, "score": "69.089386"}
{"text": "For a given grammar , an augmented grammar is created from the goal symbol , which is made by adding a single new rule to the grammar : .$ accept : Goal .This rule defines a special nonterminal symbol $ accept to represent the entire grammar .", "label": "", "metadata": {}, "score": "69.35161"}
{"text": "For all rules with X as LHS symbols , of the form ' X : t B ... ' , .with terminal symbol t as the leftmost RHS symbol .( where t is not epsilon ) , . add symbol t to first(X ) ; .", "label": "", "metadata": {}, "score": "69.494896"}
{"text": "Singular and plural nouns in the pseudo - language ' Martian ' .singular plural .In ' Martian ' , nominalizations can be formed from nouns stems by addition of the suffix ( -i ) and genitives with the suffix ( -ri ) .", "label": "", "metadata": {}, "score": "69.538574"}
{"text": "For these entries you need to specify the inflection paradigm just after the word that inflects .Look at the following example for the Spanish multiword \" echar de menos \" ( to miss ) , translated into Catalan as \" trobar a faltar \" : .", "label": "", "metadata": {}, "score": "69.69086"}
{"text": "( ' Expr ' ) ' , $ end ] .Item 2 generates the following closure items : .Factor ' + ' num , $ end ] .Item 6 generates the following closure items : .Factor ' + ' num , ' + ' ] .", "label": "", "metadata": {}, "score": "69.80133"}
{"text": "Understanding non - hygienic macros is important if you intend to work in the larger Lisp world .In the scheme community everybody thinks that hygiene is an essential feature and all major Scheme implementations provide hygienic macros ; nevertheless , in the rest of the world things are different .", "label": "", "metadata": {}, "score": "69.81348"}
{"text": "Step 7 .If any terminals were added to first(X ) in steps ( 3 ) through ( 6 ) .that were not already members of first(X ) , . or if first(X ) is still empty , . append nonterminal X to the tail of the queue .", "label": "", "metadata": {}, "score": "70.00491"}
{"text": "Each reduction item produces a parser table entry , reducing a particular rule on a particular look - ahead symbol .Items 1 and 2 produce the following parser actions : .$ end reduce 1 ' ) ' reduce 1 .", "label": "", "metadata": {}, "score": "70.03917"}
{"text": "( These integer values correspond to the % token definitions in the grammar specification , which define the terminal symbols of the grammar . )The special $ end symbol is usually returned as a zero or negative value , indicating that no more input tokens remain in the input stream .", "label": "", "metadata": {}, "score": "70.0652"}
{"text": "( This may have added meaning to those familiar with the Red Dragon book , or its older edition , the Green Dragon book .Okay , so it 's not great poetry - the author admits that his expertise lies in the area of programming and not in the more sublime area of poetastry . )", "label": "", "metadata": {}, "score": "70.298"}
{"text": "As described in the references , individual FSTs can be combined in two principal ways .On the left side of FIG .4 are represented a sequence of FSTs 10 , 11 , 12 , 13 , arranged in series relationship each modeling a specific Rule 1 , 2 , 3 . . .", "label": "", "metadata": {}, "score": "70.46112"}
{"text": "As described in the references , individual FSTs can be combined in two principal ways .On the left side of FIG .4 are represented a sequence of FSTs 10 , 11 , 12 , 13 , arranged in series relationship each modeling a specific Rule 1 , 2 , 3 . . .", "label": "", "metadata": {}, "score": "70.46112"}
{"text": "The search can be constrained more by entering the word boundary ( or \" pound \" ) symbol , # , at the beginning and end : # bright # .This will retrieve only those lexical entries that include the word bright in their English gloss field ( possibly in a phrase , such as a bright light .", "label": "", "metadata": {}, "score": "70.87561"}
{"text": "The rules for rotating the wheels are more complex than for an odometer ( which allows duplicate values ) , but there are wonderfully simple combinatorial algorithms for doing both Perms and Combs .The odometer approach is both concise and efficient , so it wins the \" elegance \" award , and it also can handle HUGE games ( like a million balls from a billion ! )", "label": "", "metadata": {}, "score": "71.054054"}
{"text": "( The \" exists \" condition means that an item in position 1 can only be mobile if its LINK value is 1 , and an item in position N can only be mobile if its LINK value is 0 ) .", "label": "", "metadata": {}, "score": "71.12573"}
{"text": "// Initialize .// Create the initial item set ( i0 ) .add item to set ; . append set i0 to end of toDoList ; .// Main loop .// Generate all item sets for the grammar from the initial set .", "label": "", "metadata": {}, "score": "71.14933"}
{"text": "The Spanish phrase \" el valle verde \" ( the green valley ) \" would be detected and processed by the first one , not by the second .You will need to add a rule for the pattern \" determiner - noun - adjective \" if you wish that the three lexical units are processed in the same pattern .", "label": "", "metadata": {}, "score": "71.20877"}
{"text": "$ any reduce 1 .For item sets having reduction items that reduce more than one rule , the rule that is reduced in the most number of items can be chosen as the default reduction action .If more than one rule are reduced an equal number of times , one of them is chosen arbitrarily ( a good choice is the rule with the highest precedence ) .", "label": "", "metadata": {}, "score": "71.45703"}
{"text": "transitionLoop : . for each item in set , . if item.action is not set , .S C , t ] ; .for each shItem in set , .S J , u ] , . add k to newSet ; . end for ; . append newSet to toDoList ; . end if ; . end for ; . append ( completed ) set to doneList ; . end if ; . end mainLoop ; .", "label": "", "metadata": {}, "score": "71.492676"}
{"text": "Factor , ' ) ' ] ( - , - ) .( ' Expr ' ) ' , ' ) ' ] ( - , - ) .num , ' ) ' ] ( - , - ) .num , ' + ' ] ( - , - ) .", "label": "", "metadata": {}, "score": "71.70547"}
{"text": "The automaton starts in a specific state ( the initial state ) and makes transitions from one state to another , depending on its current state and the next few input symbols .Which state it transitions to depends on the rules embodied by the machine , which are derived from the grammar rules and symbols .", "label": "", "metadata": {}, "score": "71.76969"}
{"text": "State Machines Find the Pattern , Kimbrell R. E. , Computer Design , vol .24 , No . 5 , May 1985 , Littleton , Massachusetts , U.S. .The Theory of Machinery Computation , K. Kohavi , Ed . , pp .", "label": "", "metadata": {}, "score": "72.13298"}
{"text": "e . Atom . integer .( Expr ) .Note that the use of the empty word e in the definition of NextExpr is compulsory if we want a single integer to be an expression .Our grammar allows the implementation of the following parser which is a simple translation of the production rules .", "label": "", "metadata": {}, "score": "72.26678"}
{"text": "The Spanish noun \" mu\u00f1eca \" can be translated in two different ways in Catalan depending on its meaning : \" canell \" ( wrist ) or \" nina \" ( doll ) .The context decides which translation is the correct one , but in its present state Apertium can not make such a decision ( but see below the section on multiword units for ways to circumvent this problem ) .", "label": "", "metadata": {}, "score": "72.4286"}
{"text": "ca.dix .The entries you need to create in these three dictionaries share a common structure .You may want , for example , to add the Spanish adjective \" c\u00f3smico \" , whose equivalent in Catalan is \" c\u00f2smic \" .", "label": "", "metadata": {}, "score": "72.83644"}
{"text": "The expression cows : .Morphosyntactic description : [ Root [ + plural ] ] .The morphosyntactic structure of an expression is generated by several mechanisms .Syntax , including the operation of head - movement , plays a major role in constructing morphosyntactic structures , including ' word'-internal structure .", "label": "", "metadata": {}, "score": "72.84363"}
{"text": "No .5,450,598 , filed respectively on Nov. 15 , 1988 ; Nov. 29 , 1990 ; Mar. 18 , 1992 .BACKGROUND OF INVENTION .This invention relates to computerized information retrieval devices or systems , for text indexing and retrieval , databases for use in such information retrieval devices , and methods for making such databases .", "label": "", "metadata": {}, "score": "73.20079"}
{"text": "NET Database and Reporting .NET Interface and Graphics .NET Installation / Documentation .NET General Xtreme .", "label": "", "metadata": {}, "score": "73.42474"}
{"text": "+ ' Factor , ' + ' ] ( - , - ) .Factor ' + ' num , ' ) ' ] ( - , - ) .Factor ' + ' num , ' + ' ] ( - , - ) .", "label": "", "metadata": {}, "score": "73.47468"}
{"text": "Factor ' + ' num , num ] ( Factor , - ) R .Factor ' + ' num , ' + ' ]( Factor , - ) R .Factor ' + ' num , ' ( ' ]", "label": "", "metadata": {}, "score": "73.520676"}
{"text": "Universiti Sains Malaysia , Penang , Malaysia .To appear in The Last Phonological Rule : Reflections on Constraints and Derivations , ed . by John Goldsmith , University of Chicago Press .Cutting , D. , J. Kupiec , J. Pedersen , P. Sibun .", "label": "", "metadata": {}, "score": "73.53607"}
{"text": "Net News & Articles Visual Basic .NET ( 2002 - 2015 ) , including Express editions ) .NET Knowledge Base Tutors ' Corner Code Library ASP.Net .NET Communications .NET Game Programming Managed DirectX .NET Office Automation .", "label": "", "metadata": {}, "score": "73.57568"}
{"text": "To best understand our invention , please refer to the List of References ( \" List \" ) , located at the end of this detailed description , which lists a number of references to explain many of the terms used herein .", "label": "", "metadata": {}, "score": "73.629875"}
{"text": "To best understand our invention , please refer to the List of References ( \" List \" ) , located at the end of this detailed description , which lists a number of references to explain many of the terms used herein .", "label": "", "metadata": {}, "score": "73.629875"}
{"text": "If the $ N operand designates a terminal RHS symbol , its value will reference an object of type Token .Similarly , if the operand designates a nonterminal RHS symbol , its value will reference an object of the type specified by the % stacktype directive .", "label": "", "metadata": {}, "score": "74.17619"}
{"text": "To answer these requires the index mapping functions .The first answer is about 11 million , as it turns out : .Code : .combination2index(50,6,\"11 , 14 , 23 , 27 , 47 , 49 \" ) 12,231,760 ?combination2index(50,6,\"1 , 7 , 23 , 35 , 47 , 49 \" ) 926,277 .", "label": "", "metadata": {}, "score": "74.42972"}
{"text": "A Basic line is made up of a number followed by an instruction .This is expressed in the following rule : .Line . integer Instruction .For any given term , there may be several alternative ways to form that term .", "label": "", "metadata": {}, "score": "74.89511"}
{"text": "passing it the top - most tLen symbols on termStack .and the top - most nLen symbols on nontermStack ; .// Reduce the RHS symbols , replacing them with the LHS symbol .pop tLen symbols from termStack ; . pop nLen symbols from nontermStack ; . push rule .", "label": "", "metadata": {}, "score": "75.04135"}
{"text": "Without special mechanisms to deal with exceptions , this strategy would also convert all the forms of \" swim \" back to \" sw \" , since that is the longest invariant prefix .This conventional strategy has several disadvantages .First , the resulting stem strings are frequently not words of English ( sw , arriv ) .", "label": "", "metadata": {}, "score": "75.30537"}
{"text": "else if action is REDUCE , .// Perform the parser action for the rule .if action is ACCEPT ( r0 ) , . if laSym is $ end , .// Accept .break mainLoop ; . else .// Unexpected extraneous look - ahead symbol . invoke parser error handler ; .", "label": "", "metadata": {}, "score": "75.44969"}
{"text": "University of Helsinki .Free format text : ASSIGNMENT OF ASSIGNORS INTEREST.;ASSIGNORS : CUTTING , DOUGLASS R.;HALVORSEN , PER - KRISTIAN G.;KAPLAN , RONALD M.;AND OTHERS;REEL / FRAME:006272/0122;SIGNING DATES FROM 19920813 TO 19920909 .Aug 11 , 2000 .FPAY .Fee payment .", "label": "", "metadata": {}, "score": "75.54106"}
{"text": "Foo : Foo .Such a rule is meaningless , because it does not define any way of progressing from the start of the rule to the end , i.e. , there is no way to recognize the RHS of this production rule and proceed with the parse .", "label": "", "metadata": {}, "score": "75.590385"}
{"text": "x13 i4 ) .num , ' ) ' ] ( num , .x13 i4 )M : x11 .num , ' + ' ] ( num , .x13 i4 ) .+ ' Factor , $ end ] ( ' + ' , .", "label": "", "metadata": {}, "score": "75.65534"}
{"text": "Here is an example of a lexical context which is particularly restricted : . r6rs ( library ( experimental dummy - ctxt ) ( export dummy - ctxt ) ( import ( only ( rnrs ) define syntax ) ) ( define dummy - ctxt # ' here ) ) .", "label": "", "metadata": {}, "score": "76.645386"}
{"text": "Initial Item Set .Recall that for a given grammar , there is always one goal symbol ( also called the start symbol ) .For instance , in the grammar shown in Example 1 , the goal symbol is Expr .", "label": "", "metadata": {}, "score": "76.951614"}
{"text": "The Theory of Machinery Computation , K. Kohavi , Ed . , an article entitled An n log n Algorithm for minimizing States In a Finite Automan by Hopcroft , pp .189 196 , Academic Press , NY 1971 .Tzoukermann , E. and M. Y. Liberman .", "label": "", "metadata": {}, "score": "77.11804"}
{"text": "Note G ] .// Add the new transition set to the to - do list .append newSet to end of toDoList ; . end transitionLoop ; .// Add the ( completed ) set to the done list .compress set ; [ Note H ] .", "label": "", "metadata": {}, "score": "77.178635"}
{"text": "+ ' num ' + ' shift 6 $ any reduce 1 .Default Reduction Actions .Combining multiple reduce actions into a single default action has the benefit of reducing the size of the parser tables , allowing the parser to select the default reduction action if no shift actions are found that match the current look - ahead symbol .", "label": "", "metadata": {}, "score": "77.66666"}
{"text": "This is represented by the special $ any symbol , indicating that any look - ahead symbol matches the action by default .The default reduce action is selected by the parser if no other entry matching the current look - ahead symbol is found in the state .", "label": "", "metadata": {}, "score": "77.70558"}
{"text": "IF flag2 THEN // statement 2 . statementA .ELSE .statementB ELSE // ELSE appearing after a Stmt .statementC .Upon reading the second ELSE above , the parser enters state 37 with a look - ahead symbol of ELSE .", "label": "", "metadata": {}, "score": "78.12421"}
{"text": "[ 1 ] Compilers : Principles , Techniques , and Tools .( a.k.a .the Red Dragon Book ) Aho , Sethi , and Ullman Addison - Wesley , 1986 , ISBN 0 - 201 - 10088 - 6 .Revision History .", "label": "", "metadata": {}, "score": "78.31129"}
{"text": "For example , in an l - morpheme corresponding to what would be pretheoretically called a ' noun ' there might be inserted the pieces dog , cat , fish , mouse , table etc .Because the labels noun , verb , adjective etc . are by hypothesis not present in syntax , the widely adopted hypothesis that Prosodic Domain construction should be oblivious to such distinctions ( Selkirk 1986 , Chen 1987 ) follows automatically .", "label": "", "metadata": {}, "score": "78.56496"}
{"text": "There is a very interesting alternative algorithm for permutation generating - it 's called the \" Johnson - Trotter \" method .I 'll refer to it here as JTS ( Johnson - Trotter Shuffle ) , and compare it to the method used in section 4 above ( ODO method ) .", "label": "", "metadata": {}, "score": "80.958405"}
{"text": "In the definition of define - macro I gave in episode 28 I used the name of the defined macro as lexical context .The consequence of this choice is that define - macro style macros are expanded within the lexical context of the code where the macro is invoked .", "label": "", "metadata": {}, "score": "81.10787"}
{"text": "In this room is the piano ' .By hypothesis , the positioning of the clitic can not be stated in terms of a ( morpho)syntactic constituent , since U ovoj ' in this ' does not form such a constituent .", "label": "", "metadata": {}, "score": "81.78611"}
{"text": "It also allows the contents of the token to be stored in a variable , yylval .By default , this token variable is just an integer ( of type int ) , but YACC allows the type to be any user - defined type , which is specified using the % union directive .", "label": "", "metadata": {}, "score": "82.075516"}
{"text": "The corresponding transducer shown in FIG .5 comprises a state 50 , the double circle that is both the start and a final state .If N is realized as m , the transducer moves to state 51 , a nonfinal state which requires a p as the next input .", "label": "", "metadata": {}, "score": "82.65206"}
{"text": "The corresponding transducer shown in FIG .5 comprises a state 50 , the double circle that is both the start and a final state .If N is realized as m , the transducer moves to state 51 , a nonfinal state which requires a p as the next input .", "label": "", "metadata": {}, "score": "82.65206"}
{"text": "Is it the same as the one for \" bonito \" and \" absoluto \" ?Can you say c\u00f3smic o , c\u00f3smic a , c\u00f3smic os , c\u00f3smic as ?The answer is yes , and , with all this information , you can now create the correct entry : .", "label": "", "metadata": {}, "score": "85.80331"}
{"text": "So the odometer ca n't tell you the answer to questions like this : .How many combinations are there between \" 1 , 7 , 23 , 35 , 47 , 49 \" and \" 11 , 14 , 23 , 27 , 47 , 49 \" in a 6-from-50 game ?", "label": "", "metadata": {}, "score": "86.08078"}
{"text": "Assignment .Owner name : JPMORGAN CHASE BANK , AS COLLATERAL AGENT , TEXAS .Free format text : SECURITY AGREEMENT;ASSIGNOR : XEROX CORPORATION;REEL / FRAME:015134/0476 Syntax .Thanks to lexical analysis , we can split up input streams into more structured units : lexical units .", "label": "", "metadata": {}, "score": "86.23209"}
{"text": "\u00ac\u00be ( R 2 ) .\u00ac\u00be ( R 4 ) .\u00ac\u00be ( R 3 ) .Exp .Starting from the last line containing only Exp and following the arrows upwards we read how our expression could be produced from the start rule Exp : therefore it is a well - formed sentence of the language defined by the grammar .", "label": "", "metadata": {}, "score": "86.98668"}
{"text": "Tamazight Berber Prefix Conjugation . dawa ' cure ' .singular plural .3 m i - dawa dawa - n 3f t - dawa dawa - n - t 2 m t - dawa - d t - dawa - m 2f t - dawa - d t - dawa - n - t 1 dawa - g n - dawa .", "label": "", "metadata": {}, "score": "89.67676"}
{"text": "Oh , and one last thing , concerning the name of the algorithm ( with apologies to Peter Yarrow and Leonard Tipton ) : .Puff , The Merging Dragon .Puff , the merging dragon lived by the sea And frolicked in the item mist in a land called Honalee .", "label": "", "metadata": {}, "score": "93.28063"}
{"text": "Because the Odometer method does n't require any measurement of the size of the full possible combination set , it can work with games of ridiculous size .For example , let 's play \" 10 balls from 50,000 ! ! \" setcombination 5000,10,\"12 , 34 , 56 , 123 , 456 , 789 , 1234 , 2345 , 3456 , 4567 \" ? thiscombination 12 , 34 , 56 , 123 , 456 , 789 , 1234 , 2345 , 3456 , 4567 nextcombination 5000 , 10 ? thiscombination 12 , 34 , 56 , 123 , 456 , 789 , 1234 , 2345 , 3456 , 4568 .", "label": "", "metadata": {}, "score": "95.11774"}
{"text": "Portions of this document may be used or quoted without permission from the author provided that appropriate credit is given to the author .This document may be printed and distributed without permission from the author on the condition that the authorship and copyright notices remain visible and unaltered .", "label": "", "metadata": {}, "score": "101.07706"}
{"text": "Jun 28 , 2002 .AS .Assignment .Owner name : BANK ONE , NA , AS ADMINISTRATIVE AGENT , ILLINOIS .Free format text : SECURITY INTEREST;ASSIGNOR : XEROX CORPORATION;REEL / FRAME:013153/0001 .Effective date : 20020621 .Oct 31 , 2003 .", "label": "", "metadata": {}, "score": "103.16085"}
{"text": "See Harris 1994 , 1997a and Embick 1995 for case studies .Practical LR(k ) Parser Construction .By David R. Tribble Revision 1.0 , 2004 - 12 - 12 .First , it is slightly cheaper , and secondly it has the words DON'T PANIC written in large friendly letters on the cover .", "label": "", "metadata": {}, "score": "108.46019"}
