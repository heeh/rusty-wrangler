{"text": "Your heuristic for the FoodSearchProblem goes here . . .This heuristic must be consistent to ensure correctness .First , try to come up .with an admissible heuristic ; almost all admissible heuristics will be consistent .On the other hand , . inadmissible or inconsistent heuristics may find optimal solutions , so be careful . . .", "label": "", "metadata": {}, "score": "81.46628"}
{"text": "To select an agent , use the ' -p ' option .when running pacman.py .Arguments can be passed to your agent . using ' -a ' .For example , to load a SearchAgent that uses .depth first search ( dfs ) , run the following command : .", "label": "", "metadata": {}, "score": "86.530624"}
{"text": "supplied search problem , then returns actions to follow that path . . .As a default , this agent runs DFS on a PositionSearchProblem to find location ( 1,1 ) .Options for fn include : .depthFirstSearch or dfs .", "label": "", "metadata": {}, "score": "87.94479"}
{"text": "uniformCostSearch .An agent for position search with a cost function that penalizes being in . positions on the East side of the board . . .The cost function for stepping into a position ( x , y ) is 2^x . .", "label": "", "metadata": {}, "score": "88.51294"}
{"text": "Returns successor states , the actions they require , and a cost of 1 . . .As noted in search.py : .For a given state , this should return a list of triples , .( successor , action , stepCost ) , where ' successor ' is a .", "label": "", "metadata": {}, "score": "89.43257"}
{"text": "Grid ( see game.py ) of either True or False .You can call foodGrid.asList ( ) .to get a list of food coordinates instead . . .If you want access to info like walls , capsules , etc . , you can query the problem .", "label": "", "metadata": {}, "score": "93.68589"}
{"text": "gameState : A GameState object ( pacman.py ) .costFn : A function from a search state ( tuple ) to a non - negative number .goal : A position in the gameState . \" \" \" self .getWalls ( ) self .", "label": "", "metadata": {}, "score": "94.017746"}
{"text": "( You need not worry about consistency for .this heuristic to receive full credit . ) aStarSearch ( prob , cornersHeuristic ) self .A search problem associated with finding the a path that collects all of the . food ( dots ) in a Pacman game . . .", "label": "", "metadata": {}, "score": "95.665665"}
{"text": "An agent for position search with a cost function that penalizes being in . positions on the West side of the board . . .The cost function for stepping into a position ( x , y ) is 1/2^x . .", "label": "", "metadata": {}, "score": "95.71908"}
{"text": "that will complete the problem definition . raiseNotDefined( ) # # # # # # # # # # # # # # # # # # .# Mini - contest 1 # .# # # # # # # # # # # # # # # # # # class ApproximateSearchAgent ( Agent ): \" Implement your contest entry here .", "label": "", "metadata": {}, "score": "96.012955"}
{"text": "getCostOfActions ( self .actions ) print ( ' Path found with total cost of % d in % .1f seconds ' % ( totalCost , time . time ( ) - starttime ) ) if ' _ expanded ' in dir ( problem ): print ( ' Search nodes expanded : % d ' % problem .", "label": "", "metadata": {}, "score": "96.10259"}
{"text": "\" From game.py : .The Agent will receive a GameState and must return an action from .Directions . raiseNotDefined( ) def mazeDistance ( point1 , point2 , gameState ): \" \" \" .Returns the maze distance between any two points , using the search functions .", "label": "", "metadata": {}, "score": "97.781136"}
{"text": "actions [ i ] else : return Directions .STOP class PositionSearchProblem ( search .SearchProblem ): \" \" \" .A search problem defines the state space , start state , goal test , . successor function and cost function .", "label": "", "metadata": {}, "score": "98.4396"}
{"text": "For a given state , this should return a list of triples , .( successor , action , stepCost ) , where ' successor ' is a .successor to the current state , ' action ' is the action .", "label": "", "metadata": {}, "score": "98.44967"}
{"text": "_ visitedlist . append ( state ) return successors def getCostOfActions ( self , actions ): \" \" \" .Returns the cost of a particular sequence of actions .If those actions . include an illegal move , return 999999 . \"", "label": "", "metadata": {}, "score": "98.784004"}
{"text": "This search problem finds paths through all four corners of a layout .You must select a suitable state space and successor function . \" \" \" def _ _ init _ _ ( self , startingGameState ): \" \" \" .", "label": "", "metadata": {}, "score": "98.84457"}
{"text": "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class SearchAgent ( Agent ): \" \" \" .", "label": "", "metadata": {}, "score": "100.03836"}
{"text": "getGhostPosition ( a ) for a in others if state .spreadProb / numBest .spreadProb ) / len ( legalActions ) return distribution", "label": "", "metadata": {}, "score": "100.13839"}
{"text": "Please only change the parts of the file you are asked to .Look for the lines that say .\" The parts you fill in start about 3/4 of the way down .Follow the . project description for details .", "label": "", "metadata": {}, "score": "100.199875"}
{"text": "uniformCostSearch .# This portion is incomplete .Time to write code ! # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class CornersProblem ( search .", "label": "", "metadata": {}, "score": "100.44122"}
{"text": "required to get there , and ' stepCost ' is the incremental .cost of expanding to that successor . \" NORTH , Directions .SOUTH , Directions .EAST , Directions .WEST ] : # Add a successor state to the successor list if the action is legal .", "label": "", "metadata": {}, "score": "100.532745"}
{"text": "The gameState can be any game state -- Pacman 's position . in that state is ignored . . .Example usage : mazeDistance ( ( 2,4 ) , ( 5,6 ) , gameState ) .This might be a useful helper function for your ApproximateSearchAgent . bfs ( prob ) ) # helloWorld.py # ------------- # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "102.21318"}
{"text": "Returns the cost of a particular sequence of actions .If those actions . include an illegal move , return 999999 .This is implemented for you .walls [ x ] [ y ] : return 999999 return len ( actions ) def cornersHeuristic ( state , problem ): \" \" \" .", "label": "", "metadata": {}, "score": "102.70515"}
{"text": "pacmanPosition : a tuple ( x , y ) of integers specifying Pacman 's position .foodGrid : a Grid ( see game.py ) of either True or False , specifying remaining food . \" \" \" def _ _ init _ _ ( self , startingGameState ): self .", "label": "", "metadata": {}, "score": "102.7977"}
{"text": "Here , we .choose a path to the goal .In this phase , the agent should compute the path to the . goal and store it in a local variable .All of the work is done in this method ! state : a GameState object ( pacman.py ) . \" \" \" if self .", "label": "", "metadata": {}, "score": "103.3083"}
{"text": "_ display .drawExpandedCells ( self ._ visitedlist ) # @UndefinedVariable return isGoal def getSuccessors ( self , state ): \" \" \" .Returns successor states , the actions they require , and a cost of 1 . . .", "label": "", "metadata": {}, "score": "103.59553"}
{"text": "For example , . if you only want to count the walls once and store that value , try : .Subsequent calls to this heuristic can access problem.heuristicInfo['wallCount ' ] . \"getFood ( ) .findPathToClosestDot ( currentState ) # The missing piece self .", "label": "", "metadata": {}, "score": "104.06384"}
{"text": "getFood ( ) # Store info for the PositionSearchProblem ( no need to change this ) self .getWalls ( ) self .getPacmanPosition ( ) self ._ visited , self ._ visitedlist , self .The state is Pacman 's position .", "label": "", "metadata": {}, "score": "104.06981"}
{"text": "Counter ( ) dist [ Directions .GhostAgent ): \" Chooses an action that distances the ghost from the other ghosts with probability spreadProb . \"getGhostState ( self .getLegalActions ( self .getGhostPosition ( self .getNumAgents ( ) ) if i ! index ] for a in others : assert state .", "label": "", "metadata": {}, "score": "104.13748"}
{"text": "co_varnames : print ( ' [ SearchAgent ] using function ' + fn ) self . print ( ' [ SearchAgent ] using function % s and heuristic % s ' % ( fn , heuristic ) ) # Note : this bit of Python trickery combines the search algorithm and the heuristic self . endswith ( ' Problem ' ): raise AttributeError , prob + ' is not a search problem type in SearchAgents.py . ' self .", "label": "", "metadata": {}, "score": "104.98389"}
{"text": "cost of expanding to that successor . \" NORTH , Directions .SOUTH , Directions .EAST , Directions .costFn ( nextState ) successors . append ( ( nextState , action , cost ) ) # Bookkeeping for display purposes self .", "label": "", "metadata": {}, "score": "105.120995"}
{"text": "The class definition above , AnyFoodSearchProblem(PositionSearchProblem ) , . inherits the methods of the PositionSearchProblem . . .You can use this search problem to help you fill in .the findPathToClosestDot method . \" \" def _ _ init _ _ ( self , gameState ): \" Stores information from the gameState .", "label": "", "metadata": {}, "score": "106.67408"}
{"text": "Note : You should NOT change any code in SearchAgent .\" # Get the search function from the name and heuristic if fn not in dir ( search ): raise AttributeError , fn + ' is not a search function in search.py . '", "label": "", "metadata": {}, "score": "107.5908"}
{"text": "You are free to use and extend these projects for educational # purposes .The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .Here 's the intended output of this script , once you fill it in : .", "label": "", "metadata": {}, "score": "107.66023"}
{"text": "( ) class AnyFoodSearchProblem ( PositionSearchProblem ): \" \" \" .A search problem for finding a path to any food . . .This search problem is just like the PositionSearchProblem , but . has a different goal test , which you need to fill in below .", "label": "", "metadata": {}, "score": "108.95935"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .To run this script , type . python buyLotsOfFruit.py .Once you have correctly implemented the buyLotsOfFruit function , .", "label": "", "metadata": {}, "score": "109.16542"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) . items ( ): print ' % s cost % f a pound ' % ( fruit , price ) # listcomp.py # ----------- # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "110.45682"}
{"text": "used to find paths to a particular point on the pacman board . . .The state space consists of ( x , y ) positions in a pacman game . . .Note : this search problem is fully specified ; you should NOT change it .", "label": "", "metadata": {}, "score": "110.5069"}
{"text": "getWalls ( ) self . start def isGoalState ( self , state ): return state [ 1 ] .NORTH , Directions .SOUTH , Directions .EAST , Directions . append ( ( ( ( nextx , nexty ) , nextFood ) , direction , 1 ) ) return successors def getCostOfActions ( self , actions ): \" \" \" Returns the cost of a particular sequence of actions .", "label": "", "metadata": {}, "score": "110.52788"}
{"text": "Returns the next action in the path chosen earlier ( in registerInitialState ) .Return .Directions .STOP if there is no further action to take . . .state : a GameState object ( pacman.py ) . \" \" \" if ' actionIndex ' not in dir ( self ): self . actionIndex self .", "label": "", "metadata": {}, "score": "111.4303"}
{"text": "Cost of [ ( ' apples ' , 2.0 ) , ( ' pears ' , 3.0 ) , ( ' limes ' , 4.0 ) ] is 12.25 . \" orderList : List of ( fruit , numPounds ) tuples .", "label": "", "metadata": {}, "score": "111.5336"}
{"text": "getWalls ( ) self .walls .height - 2 , self .walls .width - 2 self .corners : if not startingGameState . raiseNotDefined( ) def isGoalState ( self , state ): \" Returns whether this search state is a goal state of the problem \" . raiseNotDefined", "label": "", "metadata": {}, "score": "113.34544"}
{"text": "# searchAgents.py # --------------- # Licensing Information : Please do not distribute or publish solutions to this # project .You are free to use and extend these projects for educational # purposes .The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .", "label": "", "metadata": {}, "score": "114.12407"}
{"text": "\" if Directions .WEST in state .getLegalPacmanActions ( ): return Directions .WEST else : return Directions .STOP # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # .", "label": "", "metadata": {}, "score": "114.258995"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# quickSort.py # ------------ # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "114.40914"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# listcomp2.py # ------------ # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "114.44559"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# foreach.py # ---------- # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "115.85072"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .# shopTest.py # ----------- # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "116.32669"}
{"text": "fruitShops : List of FruitShops . \" getName ( ) # bustersGhostAgents.py # --------------------- # Licensing Information : Please do not distribute or publish solutions to this # project .You are free to use and extend these projects for educational # purposes .", "label": "", "metadata": {}, "score": "116.76944"}
{"text": "state : The current search state .( a data structure you chose in your search problem ) .problem : The CornersProblem instance for this layout . . .This function should always return a number that is a lower bound . on the shortest path from the state to a goal of the problem ; i.e. .", "label": "", "metadata": {}, "score": "117.141655"}
{"text": "getNumFood ( ) !_ visited , self ._ visitedlist , self .goal # For display purposes only if isGoal : self ._ visitedlist . append ( state ) import _ _ main _ _ if ' _ display ' in dir ( _ _ main _ _ ): if ' drawExpandedCells ' in dir ( _ _ main _ _ .", "label": "", "metadata": {}, "score": "127.55727"}
{"text": "The Pacman AI projects were developed at UC Berkeley , primarily by # John DeNero ( denero@cs.berkeley.edu ) and Dan Klein ( klein@cs.berkeley.edu ) .getCostPerPound ( ' apples ' ) print otherPrice print ( ' Apples cost $ % .2f at % s. ' % ( otherPrice , otherName ) ) print ( \" My , that 's expensive ! \" ) # buyLotsOfFruit.py # ----------------- # Licensing Information : Please do not distribute or publish solutions to this # project .", "label": "", "metadata": {}, "score": "131.01712"}
{"text": "Welcome to shop2 fruit shop .For orders : [ ( ' apples ' , 1.0 ) , ( ' oranges ' , 3.0 ) ] best shop is shop1 .For orders : [ ( ' apples ' , 3.0 ) ] best shop is shop2 . \" \" \" import shop def shopSmart ( orderList , fruitShops ): \" \" \" .", "label": "", "metadata": {}, "score": "141.15672"}
