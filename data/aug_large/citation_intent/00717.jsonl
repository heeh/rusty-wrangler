{"text": "Due to the constraints of verbal communication , nonverbal and or written methods should be used to reinforce the verbal message .Source of Question , Date of Response .The construction \" and/or , \" though commonplace , is seldom necessary .", "label": "", "metadata": {}, "score": "37.99761"}
{"text": "At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .The following describes the formal semantics of this syntax .", "label": "", "metadata": {}, "score": "38.21373"}
{"text": "I am also forced to wonder what motivates you to post such questions as you do : if you are aiming to teach grammar , then you clearly need to gain a much better grasp of it yourself before doing so .", "label": "", "metadata": {}, "score": "39.395584"}
{"text": "Most people will take \" verbal \" to mean \" spoken , \" but some people wo n't , and it 's a good idea to make distinctions like this along the lines of spoken ( or oral ) and written .", "label": "", "metadata": {}, "score": "39.48223"}
{"text": "I think that , before posting any further questions on technical grammatical distinctions , you really need to go away and carefully study several introductions to English grammar , aiming to acquire a sound basic knowledge of the meanings of all the relevant terms .", "label": "", "metadata": {}, "score": "40.068703"}
{"text": "properly marked up in such a way as to reflect its logical structure and . to comply with a formal grammar such as a DTD ; this alternative version . should ( i ) contain the same information as the original ; ( ii ) be updated . simultaneously with the latter ; and ( iii ) be linked to in a prominent .", "label": "", "metadata": {}, "score": "41.415672"}
{"text": "the structural markup ( excluding the table - related tags , which are purely . presentational ) adequately conveys the logical organisation and semantic . distinctions inherent in the document , so that the table - related markup . can be stripped and the resulting document can then be formatted with . style sheets etc . , for non - visual presentation .", "label": "", "metadata": {}, "score": "41.47178"}
{"text": "These requirements are already .provided in the checkpoint related to alternative pages and can thus be . incorporated by reference .( I )All of the logical structure and semantic distinctions conveyed by .the visual format of the document which uses tables for layout , are also . present in structural markup which is included within the tables . themselves ( E.G. lists and paragraphs within TD elements ) , such that . deletion of the table - related markup would yield a valid ( formal grammar . compliant ) document in which the aforementioned structural and semantic . distinctions are preserved in virtue of the structural markup ; . and .", "label": "", "metadata": {}, "score": "44.090576"}
{"text": "Or is it possible that linking verbs such as \" to be \" can never ( ? ) be followed / modified by an adverbial of manner ?I 'm very much afraid that the supplemental questions you have posed here indicate clearly that you have understood rather less well than you think .", "label": "", "metadata": {}, "score": "44.247124"}
{"text": "Some details may vary for C++ and Objective - C. Because of infelicities in the grammar for attributes , some forms described here may not be successfully parsed in all cases .There are some problems with the semantics of attributes in C++ .", "label": "", "metadata": {}, "score": "46.659737"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration .The Grammar Logs # 603 .I would like to know if the use of \" and or \" in the sentence below is appropriate and grammatically correct .", "label": "", "metadata": {}, "score": "47.04075"}
{"text": "Then we get into the real problems with this sentence : if you walk into the sentence aware of the fact that \" verbal \" and \" written \" can mean the same thing , the sentence quickly fizzzles into meaninglessness .", "label": "", "metadata": {}, "score": "49.06273"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "The precise semantics of what attributes in such cases will apply to are not yet specified .An attribute specifier list may , in future , be permitted to appear after the declarator in a function definition ( before any old - style parameter declarations or the function body ) .", "label": "", "metadata": {}, "score": "49.706043"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration .Sorry to insist , but referring back to my post \" how : subordinating conjunction ( 2 ) \" could you tell me how you differentiate : a ) \" how \" as an adverb from a subordinating conjunction ?", "label": "", "metadata": {}, "score": "50.505424"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "It will make the most sense if you are familiar with the formal specification of declarators in the ISO C standard .Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .", "label": "", "metadata": {}, "score": "53.630756"}
{"text": "The clause that it introduces is adverbial .It is like saying ' ... in this way / in that way ' .Now note that , unlike the first example , ' how ' in the second could not be rephrased as ' in what / which way ' , but represents a more complex structure : ' in the way in which ' .", "label": "", "metadata": {}, "score": "53.710567"}
{"text": "In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .", "label": "", "metadata": {}, "score": "54.21912"}
{"text": "In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .", "label": "", "metadata": {}, "score": "54.21912"}
{"text": "When formatted by a visual user agent , the document which uses tables .for layout appears as a single column of text .This is rather a complex way of stating the requirements but I am trying . to be as clear as possible .", "label": "", "metadata": {}, "score": "55.440563"}
{"text": "Source of Question , Date of Response .\" More \" is a comparative adjective ( modifying \" people \" ) and you can regard \" than \" as either a preposition or a conjunction .I prefer to think of it as a preposition here , with \" than one hundred \" functioning as a prepositional phrase .", "label": "", "metadata": {}, "score": "56.198666"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .An attribute specifier list may appear at the start of a nested declarator .At present , there are some limitations in this usage : the attributes correctly apply to the declarator , but for most individual attributes the semantics this implies are not implemented .", "label": "", "metadata": {}, "score": "56.482956"}
{"text": "\" we took a nuanced approach in writing our report \" ?Source of Question , Date of Response .The adjective \" nuanced \" usually means \" showing subtle distinctions , variations , niceties \" and \" sensibilities toward delicate shadings , \" etc .", "label": "", "metadata": {}, "score": "57.58898"}
{"text": "Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers , whether or not such a list may in that context contain storage class specifiers .( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )", "label": "", "metadata": {}, "score": "57.590675"}
{"text": "Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers , whether or not such a list may in that context contain storage class specifiers .( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )", "label": "", "metadata": {}, "score": "57.590675"}
{"text": "Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers , whether or not such a list may in that context contain storage class specifiers .( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )", "label": "", "metadata": {}, "score": "57.590675"}
{"text": "Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers , whether or not such a list may in that context contain storage class specifiers .( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )", "label": "", "metadata": {}, "score": "57.590675"}
{"text": "Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers , whether or not such a list may in that context contain storage class specifiers .( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )", "label": "", "metadata": {}, "score": "57.590675"}
{"text": "An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .Such attribute specifiers apply only to the identifier before whose declarator they appear .", "label": "", "metadata": {}, "score": "57.635567"}
{"text": "An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .Such attribute specifiers apply only to the identifier before whose declarator they appear .", "label": "", "metadata": {}, "score": "57.635567"}
{"text": "An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .Such attribute specifiers apply only to the identifier before whose declarator they appear .", "label": "", "metadata": {}, "score": "57.635567"}
{"text": "An attribute specifier list may appear immediately before a declarator ( other than the first ) in a comma - separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers .Such attribute specifiers apply only to the identifier before whose declarator they appear .", "label": "", "metadata": {}, "score": "57.635567"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .A possibly empty comma - separated list of expressions .", "label": "", "metadata": {}, "score": "57.770943"}
{"text": "If the semicolon is missing , C++ label attributes are ambiguous , as it is permissible for a declaration , which could begin with an attribute list , to be labelled in C++ .Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .", "label": "", "metadata": {}, "score": "57.931786"}
{"text": "Where attribute specifiers follow the closing brace , they are considered to relate to the structure , union or enumerated type defined , not to any enclosing declaration the type specifier appears in , and the type defined is not complete until after the attribute specifiers .", "label": "", "metadata": {}, "score": "58.053413"}
{"text": "Where attribute specifiers follow the closing brace , they are considered to relate to the structure , union or enumerated type defined , not to any enclosing declaration the type specifier appears in , and the type defined is not complete until after the attribute specifiers .", "label": "", "metadata": {}, "score": "58.053413"}
{"text": "Similarly , typeid does not distinguish between types with different attributes .Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .", "label": "", "metadata": {}, "score": "59.022446"}
{"text": "All attribute specifiers in this place relate to the declaration as a whole .In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .", "label": "", "metadata": {}, "score": "59.22027"}
{"text": "All attribute specifiers in this place relate to the declaration as a whole .In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .", "label": "", "metadata": {}, "score": "59.22027"}
{"text": "All attribute specifiers in this place relate to the declaration as a whole .In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .", "label": "", "metadata": {}, "score": "59.22027"}
{"text": "All attribute specifiers in this place relate to the declaration as a whole .In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .", "label": "", "metadata": {}, "score": "59.22027"}
{"text": "All attribute specifiers in this place relate to the declaration as a whole .In the obsolescent usage where a type of int is implied by the absence of type specifiers , such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers .", "label": "", "metadata": {}, "score": "59.22027"}
{"text": "Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .An attribute specifier list may appear as part of a struct , union or enum specifier .It may go either immediately after the struct , union or enum keyword , or after the closing brace .", "label": "", "metadata": {}, "score": "59.264664"}
{"text": "Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .An attribute specifier list may appear as part of a struct , union or enum specifier .It may go either immediately after the struct , union or enum keyword , or after the closing brace .", "label": "", "metadata": {}, "score": "59.264664"}
{"text": "Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .An attribute specifier list may appear as part of a struct , union or enum specifier .It may go either immediately after the struct , union or enum keyword , or after the closing brace .", "label": "", "metadata": {}, "score": "59.264664"}
{"text": "Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .An attribute specifier list may appear as part of a struct , union or enum specifier .It may go either immediately after the struct , union or enum keyword , or after the closing brace .", "label": "", "metadata": {}, "score": "59.264664"}
{"text": "Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .", "label": "", "metadata": {}, "score": "59.352036"}
{"text": "Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .", "label": "", "metadata": {}, "score": "59.352036"}
{"text": "Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .", "label": "", "metadata": {}, "score": "59.352036"}
{"text": "Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .", "label": "", "metadata": {}, "score": "59.352036"}
{"text": "Support for attributes in C++ may be restricted in future to attributes on declarations only , but not on nested declarators .See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .", "label": "", "metadata": {}, "score": "59.352036"}
{"text": "( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )In some other cases , attribute specifiers are permitted by this grammar but not yet supported by the compiler .", "label": "", "metadata": {}, "score": "60.282204"}
{"text": "( Some attributes , however , are essentially in the nature of storage class specifiers , and only make sense where storage class specifiers may be used ; for example , section . )In some other cases , attribute specifiers are permitted by this grammar but not yet supported by the compiler .", "label": "", "metadata": {}, "score": "60.282204"}
{"text": "I 'm afraid most people will wonder what you mean by it .By permission .Re: Proposed change to checkpoint 5.3 .In a further attempt to clarify my position , I would argue that checkpoint .5.3 , at priority level 2 , should prohibit the use of tables for layout , . except where either of the following conditions is satisfied : .", "label": "", "metadata": {}, "score": "60.58938"}
{"text": "Authority : The New Fowler 's Modern English Usage edited by R.W. Burchfield .Clarendon Press : Oxford , England .Used with the permission of Oxford University Press .Is there an apostrophe before or after the s in awards ?", "label": "", "metadata": {}, "score": "60.744247"}
{"text": "Unless a sentence is calling for a conjunction to convey \" the way or manner in which , \" the conjunction that is required .Authority : The Careful Writer by Theodore Bernstein .The Free Press : New York .What part of speech is MORE in the above sentence ?", "label": "", "metadata": {}, "score": "61.056038"}
{"text": "It may go either immediately after the struct , union or enum keyword , or after the closing brace .The former syntax is preferred .Where attribute specifiers follow the closing brace , they are considered to relate to the structure , union or enumerated type defined , not to any enclosing declaration the type specifier appears in , and the type defined is not complete until after the attribute specifiers .", "label": "", "metadata": {}, "score": "61.325294"}
{"text": "It may go either immediately after the struct , union or enum keyword , or after the closing brace .The former syntax is preferred .Where attribute specifiers follow the closing brace , they are considered to relate to the structure , union or enumerated type defined , not to any enclosing declaration the type specifier appears in , and the type defined is not complete until after the attribute specifiers .", "label": "", "metadata": {}, "score": "61.325294"}
{"text": "For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators , some laxity is allowed in the placing of attributes .If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration . 5.25 Attribute Syntax .", "label": "", "metadata": {}, "score": "61.82944"}
{"text": "Attribute specifiers may be mixed with type qualifiers appearing inside the [ ] of a parameter array declarator , in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted .Such attribute specifiers apply to the pointer , not to the array , but at present this is not implemented and they are ignored .", "label": "", "metadata": {}, "score": "62.053497"}
{"text": "The word ' how ' itself here means simply ' in what way ' - i.e. the normal , basic meaning of ' how ' as an interrogative .Now look at this example , in which ' how ' serves as a true subordinating conjunction ( as noted previously , however , suitable for informal use only ) .", "label": "", "metadata": {}, "score": "62.310936"}
{"text": "It may go either immediately after the struct , union or enum keyword , or after the closing brace .Where attribute specifiers follow the closing brace , they are considered to relate to the structure , union or enumerated type defined , not to any enclosing declaration the type specifier appears in , and the type defined is not complete until after the attribute specifiers .", "label": "", "metadata": {}, "score": "62.630253"}
{"text": "These parameters take one of the following forms : .An identifier .For example , mode attributes use this form .An identifier followed by a comma and a non - empty comma - separated list of expressions .For example , format attributes use this form .", "label": "", "metadata": {}, "score": "62.649418"}
{"text": "For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .Similarly , typeid does not distinguish between types with different attributes .", "label": "", "metadata": {}, "score": "63.13014"}
{"text": "An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "65.89529"}
{"text": "An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "65.89529"}
{"text": "An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "65.89529"}
{"text": "An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "65.89529"}
{"text": "There are some problems with the semantics of attributes in C++ .For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .", "label": "", "metadata": {}, "score": "66.056076"}
{"text": "There are some problems with the semantics of attributes in C++ .For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .", "label": "", "metadata": {}, "score": "66.056076"}
{"text": "There are some problems with the semantics of attributes in C++ .For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .", "label": "", "metadata": {}, "score": "66.056076"}
{"text": "There are some problems with the semantics of attributes in C++ .For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .", "label": "", "metadata": {}, "score": "66.056076"}
{"text": "There are some problems with the semantics of attributes in C++ .For example , there are no manglings for attributes , although they may affect code generation , so problems may arise when attributed types are used in conjunction with templates or overloading .", "label": "", "metadata": {}, "score": "66.056076"}
{"text": "\" Is this use of \" how \" grammatically wrong ?It always bothers me that people use \" how \" in this sense ... or , as most people might say , it always bothers me how people use \" how \" in this sense .", "label": "", "metadata": {}, "score": "66.126465"}
{"text": "e.g. \" I do n't know how he can do it \" answers the question \" what is it that I do n't know ? \" Would it be the same for \" I do n't know when they are leaving / why they are leaving \" ?", "label": "", "metadata": {}, "score": "66.62803"}
{"text": "requirement reflects the continued existence of primitive screen readers .that are unable to handle columnar material .", "label": "", "metadata": {}, "score": "66.72478"}
{"text": "Declarations can not be labelled in C90 or C99 , so the ambiguity does not arise there .In GNU C an attribute specifier list may also appear after the keyword while in a while loop , after do and after for .", "label": "", "metadata": {}, "score": "66.838486"}
{"text": "This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "67.34809"}
{"text": "This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "67.34809"}
{"text": "This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "67.34809"}
{"text": "This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "67.34809"}
{"text": "This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "67.34809"}
{"text": "However , when we say that something is disorganized , that means that organization is expected or valued in this context , but it 's just not there .Working in an unorganized office might be kind of fun for a while ; working in a disorganized office would just be chaotic .", "label": "", "metadata": {}, "score": "67.888596"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .In GNU C , an attribute specifier list may appear after the colon following a label , other than a case or default label .", "label": "", "metadata": {}, "score": "68.88552"}
{"text": "An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .Empty .Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .", "label": "", "metadata": {}, "score": "69.45528"}
{"text": "Consider ( as in C99 subclause 6.7.5 paragraph 4 ) a declaration T D1 , where T contains declaration specifiers that specify a type Type ( such as int ) and D1 is a declarator that contains an identifier ident .The type specified for ident for derived declarators whose type does not include an attribute specifier is as in the ISO C standard .", "label": "", "metadata": {}, "score": "69.49554"}
{"text": "Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .Some details may vary for C++ and Objective - C. Because of infelicities in the grammar for attributes , some forms described here may not be successfully parsed in all cases .", "label": "", "metadata": {}, "score": "69.55549"}
{"text": "\" The writer has apparently switched from am \" as as \" construction to a \" more than \" construction \" mid - stream .In fact , Fowler referred to this error as \" swapping horses .From Garner 's Modern American Usage by Bryan Garner .", "label": "", "metadata": {}, "score": "69.88663"}
{"text": "See Function Attributes , for details of the semantics of attributes applying to functions .See Variable Attributes , for details of the semantics of attributes applying to variables .See Type Attributes , for details of the semantics of attributes applying to structure , union and enumerated types .", "label": "", "metadata": {}, "score": "70.12071"}
{"text": "Does it show possession ?Source of Question , Date of Response .There is no apostrophe ; an apostrophe would show possession , which would n't make sense .Unfortunately , it still looks like the alumni association is giving an award to Mr. Brunch , whoever that is .", "label": "", "metadata": {}, "score": "70.140114"}
{"text": "See Label Attributes , for details of the semantics of attributes applying to labels and statements .An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "70.16811"}
{"text": "See Type Attributes , for details of the semantics of attributes applying to structure , union and enumerated types .An attribute specifier is of the form _ _ attribute _ _ ( ( attribute - list ) ) .An attribute list is a possibly empty comma - separated sequence of attributes , where each attribute is one of the following : .", "label": "", "metadata": {}, "score": "70.25647"}
{"text": "Where an attribute specifier is applied to a parameter declared as a function or an array , it should apply to the function or array rather than the pointer to which the parameter is implicitly converted , but this is not yet correctly implemented .", "label": "", "metadata": {}, "score": "71.74272"}
{"text": "Where an attribute specifier is applied to a parameter declared as a function or an array , it should apply to the function or array rather than the pointer to which the parameter is implicitly converted , but this is not yet correctly implemented .", "label": "", "metadata": {}, "score": "71.74272"}
{"text": "Authority : A Grammar of Contemporary English by Randolph Quirk , Sidney Greenbaum , Geoffrey Leech , and Jan Svartvik .Longman Group : London .Twice as many U.S. troops were killed in hostilities in June than in May.Is it proper to use \" than \" or should that have been \" as \" ?", "label": "", "metadata": {}, "score": "72.286964"}
{"text": "The only attribute it makes sense to use after a label is unused .This feature is intended for code generated by programs which contains labels that may be unused but which is compiled with -Wall .It would not normally be appropriate to use in it human - written code , though it could be useful in cases where the code that jumps to the label is contained within an # ifdef conditional .", "label": "", "metadata": {}, "score": "73.651245"}
{"text": "When we say that something is unorganized , we simply mean that there does n't appear to any organization to it .But that 's not necessasrily a bad thing , is it ?You can be having a party and you decide to go off to the movies , but you do it in an unorganized way .", "label": "", "metadata": {}, "score": "74.268715"}
{"text": "Source of Question , Date of Response .Your friend gave you good advice . \"Smooth \" can be confusing , because we use the phrase \" It went on smooth , \" and we use the adjective form , \" smooth , \" to define the nature of the surface when we 're finished ( not the way it went on ) .", "label": "", "metadata": {}, "score": "75.34248"}
{"text": "For example , format_arg attributes use this form with the list being a single integer constant expression , and alias attributes use this form with the list being a single string constant .An attribute specifier list is a sequence of one or more attribute specifiers , not separated by any other tokens .", "label": "", "metadata": {}, "score": "75.45579"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "Empty attributes are ignored .A word ( which may be an identifier such as unused , or a reserved word such as const ) .A word , followed by , in parentheses , parameters for the attribute .These parameters take one of the following forms : .", "label": "", "metadata": {}, "score": "75.48108"}
{"text": "I trust that you will not take offence at these suggestions , but rather take them in the constructive spirit in which they are offered .GNU C / C++/Objective - C 4.2.1 Compiler User Guide .5.26 Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .", "label": "", "metadata": {}, "score": "75.60721"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration .Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .", "label": "", "metadata": {}, "score": "76.63556"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration .Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .", "label": "", "metadata": {}, "score": "76.63556"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "If D1 has the form ( attribute - specifier - list D ) , and the declaration T D specifies the type \" derived - declarator - type - list Type \" for ident , then T D1 specifies the type \" derived - declarator - type - list attribute - specifier - list Type \" for ident .", "label": "", "metadata": {}, "score": "77.21416"}
{"text": "For example , in .the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "77.96825"}
{"text": "For example , in .the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "77.96825"}
{"text": "the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "80.061874"}
{"text": "the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "80.061874"}
{"text": "the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "80.061874"}
{"text": "\" For example , people often say \" did I tell you how he called me last night ? \" \" How \" in this case is not used to mean \" the way in which . \"Instead , it is being used as if it meant \" that \" or \" the fact that .", "label": "", "metadata": {}, "score": "80.44849"}
{"text": "Alumni Association Annual Awards Brunch \" ?Many years ago , a supervisor told me that using the word \" unorganized \" was incorrect and to say \" disorganized .\" I hear people saying unorganized all the time .Is it a word or not ?", "label": "", "metadata": {}, "score": "80.80543"}
{"text": "Such attribute specifiers apply only to the identifier before whose declarator they appear .For example , in .the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .At present , such attribute specifiers apply to the declared object or function , but in future they may attach to the outermost adjacent declarator .", "label": "", "metadata": {}, "score": "80.87051"}
{"text": "the noreturn attribute applies to all the functions declared ; the format attribute only applies to d1 .Such attribute specifiers apply to the declared object or function .Where an assembler name for an object or function is specified ( see Asm Labels ) , the attribute must follow the asm specification .", "label": "", "metadata": {}, "score": "81.38647"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of aligned and noreturn attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "82.11723"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of aligned and noreturn attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "82.11723"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of aligned and noreturn attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "82.11723"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration .5.26 Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .", "label": "", "metadata": {}, "score": "82.1447"}
{"text": "I am pleased to announce that the closing of our transaction went very smooth today .I was corrected by someone who said : This should read \" smoothly \" , not \" smooth \" . \"Smooth \" is an adjective , not an adverb .", "label": "", "metadata": {}, "score": "82.36183"}
{"text": "If an attribute that only applies to types is applied to a declaration , it will be treated as applying to the type of that declaration . 6.31 Attribute Syntax .This section describes the syntax with which _ _ attribute _ _ may be used , and the constructs to which attribute specifiers bind , for the C language .", "label": "", "metadata": {}, "score": "82.67061"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of ' aligned ' and ' noreturn ' attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "83.60126"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of ' aligned ' and ' noreturn ' attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "83.60126"}
{"text": "As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .Note again that this does not work with most attributes ; for example , the usage of ' aligned ' and ' noreturn ' attributes given above is not yet supported .", "label": "", "metadata": {}, "score": "83.60126"}
{"text": "I 'm lost .Look at this example , where the adverb ' how ' functions conjunctively ( i.e.introducing a subordinate clause ) : .I do n't know HOW he did it .The subordinate clause ( underlined ) serves nominally , here as object of the verb .", "label": "", "metadata": {}, "score": "83.940704"}
{"text": "You might consider dropping the intensifier \" very , \" as it 's not doing much work for you .Save your very 's for when you need them .You probably mean \" Arab films . \"( If you do a search for \" Arab film , \" on Google , you 'll find course descriptions , seminars , etc . , on \" Arab film , \" not \" Arabic film .", "label": "", "metadata": {}, "score": "85.90576"}
{"text": "For example , . specifies the type \" pointer to pointer to pointer to pointer to non - returning function returning void \" .As another example , . specifies the type \" pointer to 8-byte - aligned pointer to char \" .", "label": "", "metadata": {}, "score": "87.16407"}
{"text": "So you could probably talk about films in Arabic ( i.e. , the actors are speaking Arabic ) , but these actos are in Arab films . \" Arabic \" can be used to define anything characteristic of Arabia or Arab people , but in this context , use \" Arab \" and save \" Arabic \" for questions about language .", "label": "", "metadata": {}, "score": "90.98388"}
{"text": "Ithaca , New York Tue , May 11 , 2004 .Grammar 's Response .Theodore Bernstein abhores this use of \" how \" to mean \" that .\" It is not standard written usage to say \" He told us how he had gone on a vacation during the heat wave , \" Bernstein writes , \" unless the vacationist described the packing of his luggage , the trip to the airport , \" etc .", "label": "", "metadata": {}, "score": "101.56061"}
