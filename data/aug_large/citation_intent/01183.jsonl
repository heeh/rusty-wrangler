{"text": "In order to retain the structural information inherent in the system of phrase structure rules , it is necessary to maintain a history of how each symbol is rewritten .This can be done by means of the tree - drawing algorithm in ( 4 ) .", "label": "", "metadata": {}, "score": "33.08878"}
{"text": "In a FOL system , additional axioms are required to make inferences about the environment ( for example , that a block can not change position unless it 's physically moved ) .The frame problem is the problem of finding adequate collections of axioms for a viable description of a robot environment .", "label": "", "metadata": {}, "score": "33.20391"}
{"text": "Thus , the sentences in ( 9 ) are generated , but those in ( 10 ) are not .Two conceptual difficulties .Although subcategorization frames solve the problem posed by sentences like those in ( 10 ) , phrase structure rules , along with subcategorization frames , were eventually given up for two reasons .", "label": "", "metadata": {}, "score": "33.36696"}
{"text": "This second approach to the generation of phrase structure is therefore referred to as lexicalist .The particular formulation of the lexicalist approach presented here is based on the mathematical formalism of Tree - Adjoining Grammar ( Joshi et al .1975 , Kroch and Joshi 1985 ) .", "label": "", "metadata": {}, "score": "34.850235"}
{"text": "Both traditional and generative grammar maintain that the grammatical relation between heads and their arguments is closer than that between heads and adjuncts .The idea is that adjuncts are not required by a particular lexical item ; rather , they are optional specifications .", "label": "", "metadata": {}, "score": "34.926125"}
{"text": "Here is the argument .As stated above , solutions to the logical frame problem developed by AI researchers typically appeal to some version of the common sense law of inertia , according to which properties of a situation are assumed by default not to change as the result of an action .", "label": "", "metadata": {}, "score": "34.987873"}
{"text": "When represented as in ( 11 ) , these environments are known as subcategorization frames .The blank line represents the position of the verb , and any remaining syntactic categories represent information about the verb 's syntactic environment that is obligatory , but not predictable .", "label": "", "metadata": {}, "score": "35.2259"}
{"text": "In order for this condition to work , occlusion predicates have to be true only when they are made true as an effect of an action .This can be achieved either by circumscription or by predicate completion .This encoding is similar to the fluent occlusion solution , but the additional predicates denote change , not permission to change .", "label": "", "metadata": {}, "score": "35.37415"}
{"text": "a. .NP .V Adj .b. .VP .Adj .But structures corresponding to such rules are simply not found in the world 's languages .Rather , a phrase of a particular type ( say , a verb phrase ) contains a lexical item of that same type ( in this case , a verb ) .", "label": "", "metadata": {}, "score": "35.47386"}
{"text": "[ clarification needed ] In other words , the problem is that of formalizing a dynamical domain without explicitly specifying the frame axioms .The solution proposed by McCarthy to solve this problem involves assuming that a minimal amount of condition changes have occurred ; this solution is formalized using the framework of circumscription .", "label": "", "metadata": {}, "score": "35.740135"}
{"text": "However , it is well - known that disjunctions of such conditions can also be used in the bodies of rules without changing the essential properties of the rule language .In other words , a rule with a disjunction in the body can be split into two or more rules that have no such disjunction .", "label": "", "metadata": {}, "score": "36.062042"}
{"text": "However , it is well - known that disjunctions of such conditions can also be used in the bodies of rules without changing the essential properties of the rule language .In other words , a rule with a disjunction in the body can be split into two or more rules that have no such disjunction .", "label": "", "metadata": {}, "score": "36.062042"}
{"text": "Then we extend the basic semantic structures defined in Model Theory for the Core RIF Condition Language and define an interpretation for flat frames .The rest of the semantic definition does not change , since it is defined in terms of atomic formulas ( the ATOMIC production in the BNF syntax ) .", "label": "", "metadata": {}, "score": "36.54164"}
{"text": "Then we extend the basic semantic structures defined in Model Theory for the Core RIF Condition Language and define an interpretation for flat frames .The rest of the semantic definition does not change , since it is defined in terms of atomic formulas ( the ATOMIC production in the BNF syntax ) .", "label": "", "metadata": {}, "score": "36.54164"}
{"text": "From the facts presented in Chapter 1 and Assignment 1 , we can conclude that the interpretation of a noun phrase ( and in some cases , even the grammaticality of the sentence containing it ) depends on its structural relations to other noun phrases .", "label": "", "metadata": {}, "score": "36.643322"}
{"text": "Our main target paradigms include production rules , logic programming , FOL - based rules , reactive rules , and normative rules ( integrity constraints ) .The central part of RIF is its Condition Language .The condition language defines the syntax and semantics for the bodies of the rules in RIF - BLD and the syntax for queries .", "label": "", "metadata": {}, "score": "36.866936"}
{"text": "Our main target paradigms include production rules , logic programming , FOL - based rules , reactive rules , and normative rules ( integrity constraints ) .The central part of RIF is its Condition Language .The condition language defines the syntax and semantics for the bodies of the rules in RIF - BLD and the syntax for queries .", "label": "", "metadata": {}, "score": "36.866936"}
{"text": "By focusing on the condition part of the rule bodies we achieve a great deal of syntactic and semantic reuse among the dialects .The sublanguage of positive conditions in RIF - BLD determines what can appear as a body of a rule ( also known as the if - part , antecedent , or condition part of the rule ) supported by RIF - BLD .", "label": "", "metadata": {}, "score": "36.86972"}
{"text": "All declarative environment record bindings are marked as enumerable .( This is n't great ; the semantics of variables in declarative enviroments do n't really match those of properties , so .Create or reconfigure the variable bound to name in this environment according to descriptor .", "label": "", "metadata": {}, "score": "36.88089"}
{"text": "We prefer inherited accessor properties to own data properties .Both are read using the same syntax , but inherited accessors seem like a more accurate reflection of what 's going on .Unless otherwise noted , these properties have getters but no setters , as they can not meaningfully be assigned to .", "label": "", "metadata": {}, "score": "36.991776"}
{"text": "By focusing on the condition part of the rule bodies we achieve a great deal syntactic and semantic reuse among the dialects .The sublanguage of positive conditions in RIF - BLD determines what can appear as a body of a rule ( also known as the if - part , antecedent , or condition part of the rule ) supported by RIF - BLD .", "label": "", "metadata": {}, "score": "37.286064"}
{"text": "In other words , there is an axiom for every condition , rather than a formula for every action .Preconditions to actions ( which are not present in this example ) are formalized by other formulae .The successor state axioms are used in the variant to the situation calculus proposed by Ray Reiter .", "label": "", "metadata": {}, "score": "37.316135"}
{"text": "Alternative solutions were then proposed , involving predicate completion , fluent occlusion , successor state axioms , etc . ; they are explained below .By the end of the 1980s , the frame problem as defined by McCarthy and Hayes was solved [ clarification needed ] .", "label": "", "metadata": {}, "score": "37.37857"}
{"text": "For the basic logic dialect , which is based on Horn rules , the set of intended models of R is commonly agreed upon : it is the unique minimal model of R .However , when rule bodies contain literals negated with the negation - as - failure connective naf , then only some of the minimal models of a rule set are viewed as intended .", "label": "", "metadata": {}, "score": "37.967907"}
{"text": "For the basic logic dialect , which is based on Horn rules , the set of intended models of R is commonly agreed upon : it is the unique minimal model of R .However , when rule bodies contain literals negated with the negation - as - failure connective naf , then only some of the minimal models of a rule set are viewed as intended .", "label": "", "metadata": {}, "score": "37.967915"}
{"text": "The challenge , then , is to find a way to capture the non - effects of actions more succinctly in formal logic .What we need , it seems , is some way of declaring the general rule - of - thumb that an action can be assumed not to change a given property of a situation unless there is evidence to the contrary .", "label": "", "metadata": {}, "score": "38.018158"}
{"text": "A dialect is a rule language with a well - defined syntax and semantics .This semantics must be model - theoretic , proof - theoretic , or operational in this order of preference .Some dialects might be proper extensions of others ( both syntactically and semantically ) and some may have incompatible expressive power .", "label": "", "metadata": {}, "score": "38.058174"}
{"text": "[ 2 ] Later , the term acquired a broader meaning in philosophy , where it is formulated as the problem of limiting the beliefs that have to be updated in response to actions .In the logical context , actions are typically specified by what they change , with the implicit assumption that everything else ( the frame ) remains unchanged .", "label": "", "metadata": {}, "score": "38.427147"}
{"text": "This syntax can be used in the various dialects that extend RIF - BLD .Then we introduce the notion of a signature and specify the restrictions on the way signatures are allowed to be assigned to symbols .Next we define the presentation syntax using EBNF and describe the corresponding XML - based exchange syntax .", "label": "", "metadata": {}, "score": "38.436264"}
{"text": "This syntax can be used in the various dialects that extend RIF - BLD .Then we introduce the notion of a signature and specify the restrictions on the way signatures are allowed to be assigned to symbols .Next we define the presentation syntax using EBNF and describe the corresponding XML - based exchange syntax .", "label": "", "metadata": {}, "score": "38.436264"}
{"text": "But the importance each thinker accords to the frame problem today will typically depend on their stance on other matters .Within classical AI , a variety of workable solutions to the logical frame problem have been developed , and it is no longer considered a serious obstacle even for those working in a strictly logic - based paradigm ( Shanahan 1997 ; Reiter 2001 ; Shanahan 2003 ; Lifschitz 2015 ) .", "label": "", "metadata": {}, "score": "39.04039"}
{"text": "If LOCALE is supplied , then instead of returning the actual value , the specification(s ) for the given locale or locale type will be returned .This will only work if the actual value of PROPERTY is a specifier ( this will always be the case for built - in properties , but not or not may apply to user - defined properties ) .", "label": "", "metadata": {}, "score": "39.420654"}
{"text": "If LOCALE is supplied , then instead of returning the actual value , the specification(s ) for the given locale or locale type will be returned .This will only work if the actual value of PROPERTY is a specifier ( this will always be the case for built - in properties , but not or not may apply to user - defined properties ) .", "label": "", "metadata": {}, "score": "39.420654"}
{"text": "With the addition of these two formulae ( written more formally in predicate logic ) , all the desired conclusions can be drawn .However , this is not at all a satisfactory solution .Since most actions do not affect most properties of a situation , in a domain comprising M actions and N properties we will , in general , have to write out almost MN frame axioms .", "label": "", "metadata": {}, "score": "39.565056"}
{"text": "Recall that a process is informationally unencapsulated ( Fodor sometimes uses the term \" isotropic \" ) if there is no a priori boundary to what information is relevant to it .In recent writing , Fodor uses the term \" frame problem \" in the context of all informationally unencapsulated processes , and not just those to do with inferring the consequences of change ( Fodor 2000 , Ch.2 ; Fodor 2006 , Ch.4 ) .", "label": "", "metadata": {}, "score": "39.650375"}
{"text": "Van Brakel ( 1992 , 1993 ) has listed a \" family of frame problems , \" arising from the question of \" [ A ] [ w]hich things ( facts , etc . ) change and which do n't ? \" , \" [ w]hat are the necessary and sufficient conditions for an event [ ? ] , \" \" How can [ A ] be represented ? \" , and \" How can / do we reason about [ A ] ? \"", "label": "", "metadata": {}, "score": "39.67146"}
{"text": "An example of such a restriction is that no constant in a particular symbol space may be mapped to an element in the value space of any XML Schema data type .The above semantics is not limited to any particular set of symbol spaces or primitive data types .", "label": "", "metadata": {}, "score": "39.944004"}
{"text": "Since domains are expressed in these languages rather than directly in logic , the frame problem only arises when a specification given in an action description logic is to be translated into logic .Typically , however , a translation is given from these languages to answer set programming rather than first - order logic .", "label": "", "metadata": {}, "score": "40.106247"}
{"text": "Although the concepts and terms of generative grammar are often borrowed from traditional grammar and begin by coinciding with them , their further development can diverge .Such conceptual and terminological innovation is par for the course in the history of any science or technical discipline .", "label": "", "metadata": {}, "score": "40.211414"}
{"text": "In contrast , a uniterm slot semantically behaves like a unary uninterpreted function symbol .In both cases , however , the order of the slots is immaterial ( in contrast to positional uniterms ) .Syntactically , the extension is achieved by extending the notion of a uniterm with slots and by adding a new kind of formula , called frame formula .", "label": "", "metadata": {}, "score": "40.240433"}
{"text": "Some popular ways to handle uncertain or inconsistent information ( which is certainly important in the Web environment ) rely on four - valued and other multi - valued logics .Therefore , following M. Fitting , Fixpoint Semantics for Logic Programming A Survey , Theoretical Computer Science , 1999 , we build our definitions to be compatible with future RIF dialects , which will be based on multivalued logics .", "label": "", "metadata": {}, "score": "40.371445"}
{"text": "Some popular ways to handle uncertain or inconsistent information ( which is certainly important in the Web environment ) rely on four - valued and other multi - valued logics .Therefore , following M. Fitting , Fixpoint Semantics for Logic Programming A Survey , Theoretical Computer Science , 1999 , we build our definitions to be compatible with future RIF dialects , which will be based multivalued logics .", "label": "", "metadata": {}, "score": "40.594246"}
{"text": "As before , such formulas are constructed from well - formed atomic formulas using the logical connectives And , Or , and the quantifier Exists .Extended signatures for RIF - BLD .Section Symbols and Signatures defined the allowed signatures for RIF - BLD .", "label": "", "metadata": {}, "score": "40.644386"}
{"text": "As before , such formulas are constructed from well - formed atomic formulas using the logical connectives And , Or , and the quantifier Exists .Extended signatures for RIF - BLD .Section Symbols and Signatures defined the allowed signatures for RIF - BLD .", "label": "", "metadata": {}, "score": "40.644386"}
{"text": "A second piece of information that needs to be represented is the fact that lexical items serve as heads of phrases .Again , we can represent this by having an appropriately labeled node dominate the lexical item .Syntactic dependents .", "label": "", "metadata": {}, "score": "40.66311"}
{"text": "For user - defined properties , you can use this function to either change the actual value of the property or , if this value is a specifier , change the specifications within it .-- If VALUE is a specifier ( as would be returned by ' face - property ' if no LOCALE argument is given ) , then some or all of the specifications in the specifier will be added to the property .", "label": "", "metadata": {}, "score": "40.852074"}
{"text": "For user - defined properties , you can use this function to either change the actual value of the property or , if this value is a specifier , change the specifications within it .-- If VALUE is a specifier ( as would be returned by ' face - property ' if no LOCALE argument is given ) , then some or all of the specifications in the specifier will be added to the property .", "label": "", "metadata": {}, "score": "40.852074"}
{"text": "In the latter case , the free variables in a condition formula must also occur in the then part of the rule .We shall see in Section Horn Rules that such variables are quantified universally outside of the rule , and the scope of such quantification is the entire rule .", "label": "", "metadata": {}, "score": "40.956833"}
{"text": "In the latter case , the free variables in a condition formula must also occur in the then part of the rule .We shall see in Section Horn Rules that such variables are quantified universally outside of the rule , and the scope of such quantification is the entire rule .", "label": "", "metadata": {}, "score": "40.956833"}
{"text": "Dialects that extend RIF - BLD might appropriate some of the symbol spaces , which are left undefined in RIF - BLD , and give them special semantics .The RIF - BLD presents a much simpler picture to the user by restricting the set of well - formed terms to a specific coherent set of signatures .", "label": "", "metadata": {}, "score": "41.083923"}
{"text": "An example of such a restriction is that no constant in a particular symbol space may be mapped to an element in the value space of any XML data type .The above semantics is not limited to any particular set of symbol spaces or primitive data types .", "label": "", "metadata": {}, "score": "41.16426"}
{"text": "Dialects that extend RIF - BLD might appropriate some of the symbol spaces , which are left undefined in RIF - BLD , and give them special semantics .The condition language of RIF - BLD presents a much simpler picture to the user by restricting the set of well - formed terms to a specific coherent set of signatures .", "label": "", "metadata": {}, "score": "41.397003"}
{"text": "Various RIF dialects will extend this semantics in the required directions .Some of these extended semantics might not have a model theory ( for example , production rules ) and some will have non - first - order semantics .However , all these extensions are required to be compatible with the above definition when the rule set is completely covered by RIF BLD .", "label": "", "metadata": {}, "score": "41.41911"}
{"text": "Various RIF dialects will extend this semantics in the required directions .Some of these extended semantics might not have a model theory ( for example , production rules ) and some will have non - first - order semantics .However , all these extensions are required to be compatible with the above definition when the rule set is completely covered by RIF BLD .", "label": "", "metadata": {}, "score": "41.41911"}
{"text": "The overall RIF design takes the form of a layered architecture organized around the notion of a dialect .A dialect is a rule language with a well - defined syntax and semantics .This semantics must be model - theoretic , proof - theoretic , or operational in this order of preference .", "label": "", "metadata": {}, "score": "41.56199"}
{"text": "The logic underlying rule - based systems also assumes that only the minimal models are intended ( minimality here is with respect to the set of true facts ) .Therefore , the intended models of the above rule set R must have the property that not only p is true but also that q is false .", "label": "", "metadata": {}, "score": "41.628372"}
{"text": "Hayes , P.J. ( 1992 ) Summary of \" Reasoning Agents in a Dynamic World : The Frame Problem \" ( Ford & Hayes 1991 , Eds . )PSYCOLOQUY 3(59 ) frame - problem.1 .Hayes , P.J. and Ford , K.M. ( 1993 ) Effective Descriptions Need Not Be Complete .", "label": "", "metadata": {}, "score": "41.644966"}
{"text": "Note that , by definition , atomic formulas that correspond to builtin predicates ( i.e. , formulas with signature bi_atomic ) are not allowed in the rule heads .This restriction is not reflected in the diagram or EBNF syntax above .", "label": "", "metadata": {}, "score": "41.663338"}
{"text": "Note that , by definition , atomic formulas that correspond to builtin predicates ( i.e. , formulas with signature bi_atomic ) are not allowed in the rule heads .This restriction is not reflected in the diagram or EBNF syntax above .", "label": "", "metadata": {}, "score": "41.663338"}
{"text": "This is a draft document and may be updated , replaced or obsoleted by other documents at any time .It is inappropriate to cite this document as other than work in progress .Based on the RIF Use Cases and Requirements , this document develops RIF - BLD ( the B asic L ogic D ialect of the R ule I nterchange F ormat ) through a set of foundational concepts that are intended to be shared by all logic - based RIF dialects .", "label": "", "metadata": {}, "score": "41.781837"}
{"text": "The logic underlying rule - based systems also assumes that only the minimal models as intended ( minimality here is with respect to the set of true facts ) .Therefore , the intended models of the above rule set R must have the property that not only p is true but also that q is false .", "label": "", "metadata": {}, "score": "41.918777"}
{"text": "( van Brakel 1992 : 1.1 ) .The family then includes \" the persistence problem , temporal projection problem , inertia problem , qualification problem , ramification problem , extended prediction problem , installation problem , planning problem , holism problem , relevance problem , and so on \" ( 1.2 ) .", "label": "", "metadata": {}, "score": "41.97038"}
{"text": "Oxford University Press . pp .439 - 498 .ISBN 0 - 19 - 853791 - 3 .Toth , J.A. ( 1995 ) .\" Book review .Kenneth M. and Patrick J. Hayes , eds \" .Reasoning agents in a dynamic world : The frame problem .", "label": "", "metadata": {}, "score": "42.24042"}
{"text": "However , RIF is designed to enable interoperability among rule languages in general , and its uses are not limited to the Web .The semantics of RIF has provisions for future extensions towards dialects that support pure FOL , dialects that support negation as failure ( NAF ) , business ( or production ) rules , reactive rules , and other features .", "label": "", "metadata": {}, "score": "42.290005"}
{"text": "If PROPERTY does not name a built - in property , its value will simply be returned unless it is a specifier object , in which case it will be instanced using ' specifier - instance ' .Optional arguments DEFAULT and NO - FALLBACK are the same as in ' specifier - instance ' .", "label": "", "metadata": {}, "score": "42.31678"}
{"text": "If PROPERTY does not name a built - in property , its value will simply be returned unless it is a specifier object , in which case it will be instanced using ' specifier - instance ' .Optional arguments DEFAULT and NO - FALLBACK are the same as in ' specifier - instance ' .", "label": "", "metadata": {}, "score": "42.31678"}
{"text": "Frame problem .In artificial intelligence , the frame problem describes an issue with using first - order logic ( FOL ) to express facts about a robot in the world .Representing the state of a robot with traditional FOL requires the use of many axioms that simply imply that things in the environment do not change arbitrarily .", "label": "", "metadata": {}, "score": "42.349827"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for non - strict eval code is the referent , and the bindings appear in a new declarative environment , which is the eval code 's LexicalEnvironment . )", "label": "", "metadata": {}, "score": "42.38562"}
{"text": "In this section we define basic semantic structures .This definition will be extended in Extension of Semantic Structures for Frames when we introduce frame syntax .Semantic structures are used to assign a truth value to each formula .Currently , by formula we mean anything produced by the CONDITION production in the presentation syntax .", "label": "", "metadata": {}, "score": "42.41379"}
{"text": "In this section we define basic semantic structures .This definition will be extended in Extension of Semantic Structures for Frames when we introduce frame syntax .Semantic structures are used to assign a truth value to each formula .Currently , by formula we mean anything produced by the CONDITION production in the presentation syntax .", "label": "", "metadata": {}, "score": "42.41379"}
{"text": "Using ( 4 ) , the rules in ( 1 ) and ( 2b ) can be translated into the trees in ( 5 ) .In the mathematical literature , the structures that result from applying the algorithm in ( 4 ) are known as derivation trees because they represent the history of how a particular sequence of symbols is derived from an original symbol .", "label": "", "metadata": {}, "score": "42.45204"}
{"text": "It 's obvious that a sentence in a book does not mean something in the sense that a thought in my head does .In short , symbolic capacities are to be grounded in robotic capacities .An ungrounded symbol system has only one set of constraints : purely formal , syntactic ones , operating rulefully on the arbitrary shapes of the symbol tokens .", "label": "", "metadata": {}, "score": "42.55928"}
{"text": "It 's obvious that a sentence in a book does not mean something in the sense that a thought in my head does .In short , symbolic capacities are to be grounded in robotic capacities .An ungrounded symbol system has only one set of constraints : purely formal , syntactic ones , operating rulefully on the arbitrary shapes of the symbol tokens .", "label": "", "metadata": {}, "score": "42.55928"}
{"text": "Generative grammarians therefore proposed to incorporate the relevant information into each verb 's lexical entry .The idea is that each lexical item has an entry in our mental grammar , comparable to a conventional dictionary entry ( though much more detailed ) .", "label": "", "metadata": {}, "score": "42.63866"}
{"text": "In addition , RIF promotes the use of Internationalized Resource Identifiers ( or IRI s ) RFC 3987 to refer to individuals , predicates , and functions .To ensure extensibility and to provide for future higher - order dialects based on formalisms such as HiLog and Common Logic , the RIF does not draw a sharp boundary between the symbols used to denote individuals from symbols used as names for functions or predicates .", "label": "", "metadata": {}, "score": "42.64206"}
{"text": "If PROPERTY is not a built - in property , then this function will simply set its value if LOCALE is nil .However , if LOCALE is given , then this function will attempt to add VALUE as the instantiator for the given LOCALE , using ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "42.75072"}
{"text": "If PROPERTY is not a built - in property , then this function will simply set its value if LOCALE is nil .However , if LOCALE is given , then this function will attempt to add VALUE as the instantiator for the given LOCALE , using ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "42.75072"}
{"text": "As we shall soon see , this signature is used in RIF - BLD .Consider the term p ( p ( a ) p ( a b c ) ) .Then r ( r ( a ) r ( a b c ) ) is well - formed .", "label": "", "metadata": {}, "score": "42.75477"}
{"text": "As we shall soon see , this signature is used in RIF - BLD .Consider the term p ( p ( a ) p ( a b c ) ) .Then r ( r ( a ) r ( a b c ) ) is well - formed .", "label": "", "metadata": {}, "score": "42.75477"}
{"text": "The rationale of this solution is to represent not only the value of conditions over time , but also whether they can be affected by the last executed action .The latter is represented by another condition , called occlusion .A condition is said to be occluded in a given time point if an action has been just executed that makes the condition true or false as an effect .", "label": "", "metadata": {}, "score": "42.829018"}
{"text": "But this is not the issue at hand .The real issue , to reiterate the point , is one of relevance .To summarize , it is possible to discern an epistemological frame problem , and to distinguish it from a computational counterpart .", "label": "", "metadata": {}, "score": "42.917313"}
{"text": "We first define the notion of a truth value formally and then introduce semantic structures .Next we give the semantics to symbol spaces and , finally , define truth values of formulas with respect to semantic structures .Truth values .", "label": "", "metadata": {}, "score": "42.993595"}
{"text": "We first define the notion of a truth value formally and then introduce semantic structures .Next we give the semantics to symbol spaces and , finally , define truth values of formulas with respect to semantic structures .Truth values .", "label": "", "metadata": {}, "score": "42.993595"}
{"text": "A boolean value indicating whether this Debugger instance 's handlers , breakpoints , watchpoints , and the like are currently enabled .It is an accessor property with a getter and setter : assigning to it enables or disables this Debugger instance ; reading it produces true if the instance is enabled , or false otherwise .", "label": "", "metadata": {}, "score": "42.994"}
{"text": "Action description languages elude the frame problem rather than solving it .An action description language is a formal language with a syntax that is specific for describing situations and actions .For example , that the action makes the door open if not locked is expressed by : . causes if .", "label": "", "metadata": {}, "score": "43.02558"}
{"text": "Much of the history of generative grammar has been driven by the assumption that redundancy in the theory indicates a failure of insight , and that more insight will be achieved by searching for ways to eliminate the redundancy .Projection from the lexicon .", "label": "", "metadata": {}, "score": "43.04203"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.144558"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.144558"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.144558"}
{"text": "X ?Y ) ) ) .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .It is presented here to get feedback on this strawman and to give readers an idea for the kind of information that will be presented in this section .", "label": "", "metadata": {}, "score": "43.15338"}
{"text": "X ?Y ) ) ) .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .It is presented here to get feedback on this strawman and to give readers an idea for the kind of information that will be presented in this section .", "label": "", "metadata": {}, "score": "43.15338"}
{"text": "The two most common theories of intended models are based on the so called well - founded models and stable models .Here we will just illustrate the problem with a simple example .Suppose R consists of a single rule p : - naf q .", "label": "", "metadata": {}, "score": "43.29257"}
{"text": "The two most common theories of intended models are based on the so called well - founded models and stable models .Here we will just illustrate the problem with a simple example .Suppose R consists of a single rule p : - naf q .", "label": "", "metadata": {}, "score": "43.292572"}
{"text": "However , we will usually omit the symbol space , for readability .The equality predicate has special model - theoretic semantics , as explained in Section Model Theory for Condition Language of RIF BLD .RIF - BLD requires no extra syntax for declaring signatures , since signatures can be inferred .", "label": "", "metadata": {}, "score": "43.326435"}
{"text": "However , we will usually omit the symbol space , for readability .The equality predicate has special model - theoretic semantics , as explained in Section Model Theory for Condition Language of RIF BLD .RIF - BLD requires no extra syntax for declaring signatures , since signatures can be inferred .", "label": "", "metadata": {}, "score": "43.326435"}
{"text": "Furthermore , the classical AI researcher is vulnerable to an argument from holism .A key claim in Fodor 's work is that when it comes to circumscribing the consequences of an action , just as in the business of theory confirmation in science , anything could be relevant ( Fodor 1983 , 105 ) .", "label": "", "metadata": {}, "score": "43.32949"}
{"text": "The most obvious way to augment such a formalisation so that the right common sense conclusions fall out is to add a number of formulae that explicitly describe the non - effects of each action .These formulae are called frame axioms .", "label": "", "metadata": {}, "score": "43.355682"}
{"text": "In the condition language of RIF - BLD , a variable can be free or quantified .All quantification is explicit and the variables introduced by quantification must also occur in the quantified formula .Variables that are not explicitly quantified are free .", "label": "", "metadata": {}, "score": "43.363712"}
{"text": "In the condition language of RIF - BLD , a variable can be free or quantified .All quantification is explicit and the variables introduced by quantification must also occur in the quantified formula .Variables that are not explicitly quantified are free .", "label": "", "metadata": {}, "score": "43.363712"}
{"text": "Put succinctly , the frame problem in its narrow , technical form is this ( McCarthy & Hayes 1969 ) .Using mathematical logic , how is it possible to write formulae that describe the effects of actions without having to write a large number of accompanying formulae that describe the mundane , obvious non - effects of those actions ?", "label": "", "metadata": {}, "score": "43.372547"}
{"text": "It should be noted , however , that apart from RIF - BLD and RIF - PRD no decision has been made regarding which dialects will ultimately be part of RIF .The condition sublanguage of RIF - BLD is intended to be used only in rule bodies and queries , not in rule heads .", "label": "", "metadata": {}, "score": "43.4442"}
{"text": "It should be noted , however , that apart from RIF - BLD and RIF - PRD no decision has been made regarding which dialects will ultimately be part of RIF .The condition sublanguage of RIF - BLD is intended to be used only in rule bodies and queries , not in rule heads .", "label": "", "metadata": {}, "score": "43.4442"}
{"text": "REFERENCES .Fetzer , J. H. ( 1993a )Van Brakel 's Position Appears to be Incoherent .PSYCOLOQUY 4(14 ) frame - problem.4 .Ford , K.M. & Hayes , P.J. ( 1991 )Reasoning Agents in a Dynamic World : The Frame Problem , Greenwich : JAI Press .", "label": "", "metadata": {}, "score": "43.51455"}
{"text": "Translating phrase structure rules into trees .As they stand , phrase structure rules are devices that manipulate strings without regard for structure .For instance , given the two rules in ( 2 ) , the symbol in ( 3a ) can be successively rewritten as the strings in ( 3b ) and ( 3c ) .", "label": "", "metadata": {}, "score": "43.518124"}
{"text": "Since the grammar of a language must include the information in lexical entries no matter what , syntactic structure can be thought of as originating in the lexicon itself .We will refer to these syntactic atoms as elementary trees .The derivation of the phrases and sentences of a language is then the process of composing the elementary trees with each other in a well - defined way .", "label": "", "metadata": {}, "score": "43.67841"}
{"text": "A separate condition can be stated to specify that this is actually the state at a given time , e.g. , means that this is the state at time .The solution to the frame problem given in the fluent calculus is to specify the effects of actions by stating how a term representing the state changes when the action is executed .", "label": "", "metadata": {}, "score": "43.67889"}
{"text": "More precisely , .I isa gives meaning to class membership .The truth valuation for classification formulas of the form o # cl , where o and cl are terms , is defined as follows : .We also want # and # # to have the usual property that all members of a subclass are also members of the superclass , i.e. , we want o # cl and cl # # scl to imply o # scl .", "label": "", "metadata": {}, "score": "43.71541"}
{"text": "More precisely , .I isa gives meaning to class membership .The truth valuation for classification formulas of the form o # cl , where o and cl are terms , is defined as follows : .We also want # and # # to have the usual property that all members of a subclass are also members of the superclass , i.e. , we want o # cl and cl # # scl to imply o # scl .", "label": "", "metadata": {}, "score": "43.71541"}
{"text": "Query is an object whose properties restrict which scripts are returned ; a script must meet all the criteria given by query to be returned .If query is omitted , we return the url values of all debuggee scripts .The script must be in the scope of the given global object .", "label": "", "metadata": {}, "score": "43.76352"}
{"text": "In addition , RIF promotes the use of Internationalized Resource Identifiers ( or IRI s ) RFC 3987 to refer to individuals , predicates , and functions .To ensure extensibility and to provide for future higher - order dialects based on formalisms such as HiLog and Common Logic , the RIF logic language does not draw a sharp boundary between the symbols used to denote individuals from symbols used as names for functions or predicates .", "label": "", "metadata": {}, "score": "43.7872"}
{"text": "Since common optimizations ( say , the \" null closure \" closure representation ) make environments that one would expect to be present , given the source code , unavailable at run time , Debugger .Environment should provide ways to reflect what is and is not available .", "label": "", "metadata": {}, "score": "43.85435"}
{"text": "Section Positive Conditions defined the notion of semantic structures and how such structures determine truth values of RIF conditions .The current section defines what it means for such a structure to satisfy a rule .While semantic structures can be multivalued in RIF dialects that extend the BLD , rules are typically two - valued even in dialects that support inconsistency and uncertainty .", "label": "", "metadata": {}, "score": "43.8985"}
{"text": "Section Positive Conditions defined the notion of semantic structures and how such structures determine truth values of RIF conditions .The current section defines what it means for such a structure to satisfy a rule .While semantic structures can be multivalued in RIF dialects that extend the BLD , rules are typically two - valued even in dialects that support inconsistency and uncertainty .", "label": "", "metadata": {}, "score": "43.8985"}
{"text": "That is , subjects c - command objects , but objects do n't c - command subjects .Since the representations in ( 19 ) , at least those in ( 19a , b ) , fail to represent this fact , they must be rejected .", "label": "", "metadata": {}, "score": "43.91588"}
{"text": "Rationale : There are several equivalent ways to define first - order semantic structures .The one we adopted has the advantage that it generalizes to rule sets with negation as failure ( NAF ) and to logics for dealing with uncertainty and inconsistency .", "label": "", "metadata": {}, "score": "43.970253"}
{"text": "Rationale : There are several equivalent ways to define first - order semantic structures .The one we adopted has the advantage that it generalizes to rule sets with negation as failure ( NAF ) and to logics for dealing with uncertainty and inconsistency .", "label": "", "metadata": {}, "score": "43.970253"}
{"text": "However , the righthand side of a lexical insertion rule is constrained to be a single terminal symbol .The result of inserting the lexical items in ( 7 ) into the structures in ( 5 ) is shown in ( 8) .", "label": "", "metadata": {}, "score": "44.03242"}
{"text": "When t , p i , or v i are not just terms but frame formulas themselves , the above is treated as a conjunction of simpler frame formulas , as defined by the unnest transformation in the section on semantics ( below ) .", "label": "", "metadata": {}, "score": "44.37932"}
{"text": "When t , p i , or v i are not just terms but frame formulas themselves , the above is treated as a conjunction of simpler frame formulas , as defined by the unnest transformation in the section on semantics ( below ) .", "label": "", "metadata": {}, "score": "44.37932"}
{"text": "This is what Harnad ( 1990 ) calls the ' symbol grounding problem ' \" ( Hayes & Ford 1993 : 4.2 ) .The symbol grounding problem is not just the problem of attaching formal symbols to the world , for an UNGROUNDED symbol system ( like English or geometry ) will serve that purpose admirably well ( as long as it has the right formal , syntactic properties ) .", "label": "", "metadata": {}, "score": "44.50688"}
{"text": "This is what Harnad ( 1990 ) calls the ' symbol grounding problem ' \" ( Hayes & Ford 1993 : 4.2 ) .The symbol grounding problem is not just the problem of attaching formal symbols to the world , for an UNGROUNDED symbol system ( like English or geometry ) will serve that purpose admirably well ( as long as it has the right formal , syntactic properties ) .", "label": "", "metadata": {}, "score": "44.50688"}
{"text": "The value space of a data type should not be confused with the lexical space .Lexical spaces define the syntax of the constant symbols that belong to the various primitive data types .In contrast , value spaces define the meaning of the constants in data types .", "label": "", "metadata": {}, "score": "44.51181"}
{"text": "The value space of a data type should not be confused with the lexical space .Lexical spaces define the syntax of the constant symbols that belong to the various primitive data types .In contrast , value spaces define the meaning of the constants in data types .", "label": "", "metadata": {}, "score": "44.51181"}
{"text": "In this chapter , we discuss two approaches to this question that have been pursued in the history of generative grammar .The first , based on so - called phrase structure rules , characterized the field from its beginnings in the 1950s until roughly 1980 .", "label": "", "metadata": {}, "score": "44.687347"}
{"text": "First , as mentioned above , each constant and variable symbol is associated with exactly one signature from a coherent set of signatures .Different symbols can be associated with the same signature , but no symbol can be associated with more than one signature .", "label": "", "metadata": {}, "score": "44.76126"}
{"text": "First , as mentioned above , each constant and variable symbol is associated with exactly one signature from a coherent set of signatures .Different symbols can be associated with the same signature , but no symbol can be associated with more than one signature .", "label": "", "metadata": {}, "score": "44.76126"}
{"text": "This process of substitution yields ( 32b ) ; as before , the internal structure of syntactic dependents is omitted for clarity .Of course , the question still remains of how adjuncts enter into syntactic structure .The answer is that they are integrated by a separate process called adjunction .", "label": "", "metadata": {}, "score": "44.76806"}
{"text": "See ' copy - specifier ' and ' add - spec - to - specifier ' for a description of what each of these means .Most of the time , you do not need to worry about this argument ; the default behavior usually is fine .", "label": "", "metadata": {}, "score": "44.79218"}
{"text": "See ' copy - specifier ' and ' add - spec - to - specifier ' for a description of what each of these means .Most of the time , you do not need to worry about this argument ; the default behavior usually is fine .", "label": "", "metadata": {}, "score": "44.79218"}
{"text": "Therefore , the signature can be determined from the context in which the symbol is used .If a symbol is used in more than one context , the parser should treat it as a syntax error .If no errors are found , all uniterms and atomic formulas are guaranteed to be well - formed .", "label": "", "metadata": {}, "score": "44.847534"}
{"text": "Therefore , the signature can be determined from the context in which the symbol is used .If a symbol is used in more than one context , the parser should treat it as a syntax error .If no errors are found , all uniterms and atomic formulas are guaranteed to be well - formed .", "label": "", "metadata": {}, "score": "44.847534"}
{"text": "The computational counterpart to the epistemological problem is this .How could an inference process tractably be confined to just what is relevant , given that relevance is holistic , open - ended , and context - sensitive ?An additional dimension to the frame problem is uncovered in ( Fodor 1987 ) , where the metaphysical justification for the common sense law of inertia is challenged .", "label": "", "metadata": {}, "score": "45.064613"}
{"text": "First , they are not assigned any value space .Thus , such symbol spaces are not considered to be primitive data types by RIF even though they may be viewed as data types by some concrete rule languages that use RIF for exchange .", "label": "", "metadata": {}, "score": "45.12973"}
{"text": "First , they are not assigned any value space .Thus , such symbol spaces are not considered to be primitive data types by RIF even though they may be viewed as data types by some concrete rule languages that use RIF for exchange .", "label": "", "metadata": {}, "score": "45.12973"}
{"text": "The ( technical ) frame problem can be viewed as the task of formalising this law .The main obstacle to doing this is the monotonicity of classical logic .In classical logic , the set of conclusions that can be drawn from a set of formulae always increases with the addition of further formulae .", "label": "", "metadata": {}, "score": "45.181786"}
{"text": "In the simplified example of the door and the light , occlusion can be formalized by two predicates and .The rationale is that a condition can change value only if the corresponding occlusion predicate is true at the next time point .", "label": "", "metadata": {}, "score": "45.238586"}
{"text": "For uniformity and greater syntactic convenience , frame formulas can be nested inside other frame formulas .However , this feature is syntactic sugar that does not extend the expressive power .Slotted terms are like regular terms except that the arguments are named and their order is considered to be immaterial .", "label": "", "metadata": {}, "score": "45.30591"}
{"text": "The last two conditions state that a condition changes value at time if and only if the corresponding change predicate is true at time .To complete the solution , the time points in which the change predicates are true have to be as few as possible , and this can be done by applying predicate completion to the rules specifying the effects of actions .", "label": "", "metadata": {}, "score": "45.447838"}
{"text": "Unfortunately , this is not the case .If written out more formally in classical predicate logic , using a suitable formalism for representing time and action such as the situation calculus ( McCarthy & Hayes 1969 ) , the two formulae above only license the conclusion that Position ( A , Garden ) holds .", "label": "", "metadata": {}, "score": "45.46901"}
{"text": "Because it sometimes jumps to premature conclusions , bounded rationality is logically flawed , but no more so than human thinking .This is because it neglects the issue of how the heuristic boundary is to be drawn , which is to say it fails to address the original question of how to specify what is and is n't relevant to the inferential process .", "label": "", "metadata": {}, "score": "45.477615"}
{"text": "359 - 380 .Sandewall , E. ( 1972 ) . \"An approach to the Frame Problem and its Implementation \" .Machine Intelligence 7 : 195 - 204 .Sandewall , E. ( 1994 ) .Features and Fluents .", "label": "", "metadata": {}, "score": "45.72557"}
{"text": "Intermediate projections .Empirical motivation .As stated earlier , an elementary tree is intended to specify exactly the information that is characteristic of the lexical item that anchors it .In contrast to subcategorization frames , elementary trees can include predictable information .", "label": "", "metadata": {}, "score": "45.80303"}
{"text": "In contrast to first - order logic , most rule - based systems do not consider p and q symmetrically .Instead , they view the rule p : - naf q as a statement that p must be true if it is not possible to establish the truth of q .", "label": "", "metadata": {}, "score": "45.85842"}
{"text": "In contrast to first - order logic , most rule - based systems do not consider p and q symmetrically .Instead , they view the rule p : - naf q as a statement that p must be true if it is not possible to establish the truth of q .", "label": "", "metadata": {}, "score": "45.85846"}
{"text": "In general , every action making a condition true or false also makes the corresponding occlusion predicate true .In this case , is true , making the antecedent of the fourth formula above false for ; therefore , the constraint that does not hold for .", "label": "", "metadata": {}, "score": "45.869595"}
{"text": "Builtin predicates are not subject to the above signature inference rule .The signatures of the builtin predicates are defined by List_of_functions_and_operators .In dialects that extend RIF - BLD , signature inference may not always be possible .We expect that most dialects will use signature inference and RIF does not define any special sublanguage for signatures .", "label": "", "metadata": {}, "score": "45.909363"}
{"text": "Builtin predicates are not subject to the above signature inference rule .The signatures of the builtin predicates are defined by List_of_functions_and_operators .In dialects that extend RIF - BLD , signature inference may not always be possible .We expect that most dialects will use signature inference and RIF does not define any special sublanguage for signatures .", "label": "", "metadata": {}, "score": "45.909363"}
{"text": "These latter features make RIF a Web language .However , RIF is designed to enable interoperability among rule languages in general , and its uses are not limited to the Web .The semantics of RIF has provisions for future extensions towards dialects that support pure FOL , dialects that support negation as failure ( NAF ) , business ( or production ) rules , reactive rules , and other features .", "label": "", "metadata": {}, "score": "45.99669"}
{"text": "For Fodor , this is a fundamental barrier to the provision of a computational account of these processes .It is tempting to see Fodor 's concerns as resting on a fallacious argument to the effect that a process must be informationally encapsulated to be computationally tractable .", "label": "", "metadata": {}, "score": "46.00136"}
{"text": "Buyer ?P ( ? inst # class . sub # # super .The syntax of RIF frames permits nesting of two kinds .First , a classification formula of the form obj1 # obj2 or obj1 # # obj2 can appear in the object position of a frame .", "label": "", "metadata": {}, "score": "46.173172"}
{"text": "Buyer ?P ( ? inst # class . sub # # super .The syntax of RIF frames permits nesting of two kinds .First , a classification formula of the form obj1 # obj2 or obj1 # # obj2 can appear in the object position of a frame .", "label": "", "metadata": {}, "score": "46.173172"}
{"text": "VARNAME .A CLASSIFICATION specifies that one object is a member ( in case of the # -connective ) or a subclass ( in case of the # # -connective ) of another object .Example 3 shows Uniterm and Frame conditions , the latter with variables for the three major ( combinations of ) syntactic categories , corresponding to the three components of RDF triples .", "label": "", "metadata": {}, "score": "46.342327"}
{"text": "VARNAME .A CLASSIFICATION specifies that one object is a member ( in case of the # -connective ) or a subclass ( in case of the # # -connective ) of another object .Example 3 shows Uniterm and Frame conditions , the latter with variables for the three major ( combinations of ) syntactic categories , corresponding to the three components of RDF triples .", "label": "", "metadata": {}, "score": "46.342327"}
{"text": "At any point , a symbol system has only dealt with a small amount of data ( relative to human scale performance ) .That 's why such systems are often called \" toy \" systems .Yet in projecting a systematic ( usually natural - language ) interpretation onto such a toy , one is at the same time OVERinterpreting it ( typically overinterpreting it mentalistically , in terms of what it \" knows , \" \" thinks , \" \" means \" ) .", "label": "", "metadata": {}, "score": "46.461685"}
{"text": "At any point , a symbol system has only dealt with a small amount of data ( relative to human scale performance ) .That 's why such systems are often called \" toy \" systems .Yet in projecting a systematic ( usually natural - language ) interpretation onto such a toy , one is at the same time OVERinterpreting it ( typically overinterpreting it mentalistically , in terms of what it \" knows , \" \" thinks , \" \" means \" ) .", "label": "", "metadata": {}, "score": "46.461685"}
{"text": "They act like macros and are not visible in instance markup .For the XML Schema Definition ( XSD ) of the RIF - BLD condition language see Appendix Specification .The XML syntax for symbol spaces utilizes the type attribute associated with XML term elements such as Const .", "label": "", "metadata": {}, "score": "46.53282"}
{"text": "They act like macros and are not visible in instance markup .For the XML Schema Definition ( XSD ) of the RIF - BLD condition language see Appendix Specification .The XML syntax for symbol spaces utilizes the type attribute associated with XML term elements such as Const .", "label": "", "metadata": {}, "score": "46.53282"}
{"text": "This nested notation is convenient and allows succinct representation of object properties , but is no more than a shorthand notation .A nested frame represents a conjunction of flat frames .For instance , .Formally , given a frame , f , we define the Unnest transformation and postulate f to be true in a semantic structure iff Unnest(f ) is true .", "label": "", "metadata": {}, "score": "46.568863"}
{"text": "This nested notation is convenient and allows succinct representation of object properties , but is no more than a shorthand notation .A nested frame represents a conjunction of flat frames .For instance , .Formally , given a frame , f , we define the Unnest transformation and postulate f to be true in a semantic structure iff Unnest(f ) is true .", "label": "", "metadata": {}, "score": "46.568863"}
{"text": "Any value , get , and set properties of attributes must be debuggee values .( This function behaves like Object.defineProperty , except that the target object is implicit , and in a different compartment from the function and descriptor . )", "label": "", "metadata": {}, "score": "46.59788"}
{"text": "See also ' specifier - matching - instance ' for a fuller description of the matching process . \"NOTE :If you want to remove a property from a face , use ' remove - face - property ' rather than attempting to set a value of nil for the property .", "label": "", "metadata": {}, "score": "46.97686"}
{"text": "See also ' specifier - matching - instance ' for a fuller description of the matching process . \"NOTE :If you want to remove a property from a face , use ' remove - face - property ' rather than attempting to set a value of nil for the property .", "label": "", "metadata": {}, "score": "46.97686"}
{"text": "Finally , if LOCALE is ' all , the specifications for all locales of all types will be returned .The specifications in a specifier determine what the value of PROPERTY will be in a particular \\\"domain\\ \" or set of circumstances , which is typically a particular Emacs window along with the buffer it contains and the frame and device it lies within .", "label": "", "metadata": {}, "score": "47.014732"}
{"text": "Finally , if LOCALE is ' all , the specifications for all locales of all types will be returned .The specifications in a specifier determine what the value of PROPERTY will be in a particular \\\"domain\\ \" or set of circumstances , which is typically a particular Emacs window along with the buffer it contains and the frame and device it lies within .", "label": "", "metadata": {}, "score": "47.014732"}
{"text": "In spite of these subtleties , a number of solutions to the technical frame problem now exist that are adequate for logic - based AI research .Although improvements and extensions continue to be found , it is fair to say that the dust has settled , and that the frame problem , in its technical guise , is more - or - less solved ( Shanahan 1997 ; Lifschitz 2015 ) .", "label": "", "metadata": {}, "score": "47.074257"}
{"text": "In these cases , we expect those dialects to introduce their own primitives for defining signatures .The central syntactic class of RIF , CONDITION , is specified recursively through its subclasses and their parts .The Equal class has two side roles .", "label": "", "metadata": {}, "score": "47.103283"}
{"text": "In these cases , we expect those dialects to introduce their own primitives for defining signatures .The central syntactic class of RIF , CONDITION , is specified recursively through its subclasses and their parts .The Equal class has two side roles .", "label": "", "metadata": {}, "score": "47.103283"}
{"text": "In the two - valued case , a set of objects associated with the truth value true represents the ( set of ) values that the slot returns when applied to an object .Formally , this is expressed by extending I Truth to flat frames as follows : .", "label": "", "metadata": {}, "score": "47.182396"}
{"text": "In the two - valued case , a set of objects associated with the truth value true represents the ( set of ) values that the slot returns when applied to an object .Formally , this is expressed by extending I Truth to flat frames as follows : .", "label": "", "metadata": {}, "score": "47.182396"}
{"text": "The three classes Var , CONDITION , and ATOMIC are used in the syntax of Horn Rules .We now give an EBNF for the RIF presentation syntax .This syntax is somewhat abstract in nature .In particular , it does not address the concrete details of how constants and variables are represented .", "label": "", "metadata": {}, "score": "47.208046"}
{"text": "The three classes Var , CONDITION , and ATOMIC are used in the syntax of Horn Rules .We now give an EBNF for the RIF presentation syntax .This syntax is somewhat abstract in nature .In particular , it does not address the concrete details of how constants and variables are represented .", "label": "", "metadata": {}, "score": "47.208046"}
{"text": "It solves the frame problem by using first - order logic terms , rather than predicates , to represent the states .Converting predicates into terms in first order logic is called reification ; the fluent calculus can be seen as a logic in which predicates representing the state of conditions are reified .", "label": "", "metadata": {}, "score": "47.23211"}
{"text": "The first two formulae represent the initial situation ; the third formula represents the effect of executing the action of opening the door at time 1 .If such an action had preconditions , such as the door being unlocked , it would have been represented by .", "label": "", "metadata": {}, "score": "47.23233"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.29118"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.29118"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.29118"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.29118"}
{"text": "In particular , it might be used as a sublanguage for specifying the conditional part in the bodies of production rules ( RIF PRD ) , reactive rules , and normative rules .As mentioned , IRI constants are used in RIF both as logical constants and as names for predicate and function symbols .", "label": "", "metadata": {}, "score": "47.29605"}
{"text": "In particular , it might be used as a sublanguage for specifying the conditional part in the bodies of production rules ( RIF PRD ) , reactive rules , and normative rules .As mentioned , IRI constants are used in RIF both as logical constants and as names for predicate and function symbols .", "label": "", "metadata": {}, "score": "47.29605"}
{"text": "Script instances for all debuggee scripts .The script must include given column on the line given by the line property .If this property is present , the url and line properties must both be present as well .The script must be in the scope of the given global object .", "label": "", "metadata": {}, "score": "47.333603"}
{"text": "However , this feature is just a syntactic sugar that does not extend the expressive power .Slotted terms are like regular terms except that the arguments are named and their order is considered to be immaterial .In order to talk about the slotted terms that are also well - formed , we need to extend the notion of a signature to include slots .", "label": "", "metadata": {}, "score": "47.434315"}
{"text": "The condition language is then extended to Horn rules and this document specifies a presentation syntax and a corresponding concrete XML syntax for RIF - BLD .A model - theoretic semantics for the language is also defined .May Be Superseded .", "label": "", "metadata": {}, "score": "47.43433"}
{"text": "The family then includes \" the persistence problem , temporal projection problem , inertia problem , qualification problem , ramification problem , extended prediction problem , installation problem , planning problem , holism problem , relevance problem , and so on \" ( 1.2 ) .", "label": "", "metadata": {}, "score": "47.555546"}
{"text": "Shanahan , M. ( 1997 ) , Solving the Frame Problem : A Mathematical Investigation of the Common Sense Law of Inertia , MIT Press . - ( 2003 ) , \" The Frame Problem \" , in The Macmillan Encyclopedia of Cognitive Science , L. Nadel ( ed . ) , Macmillan , pp .", "label": "", "metadata": {}, "score": "47.556526"}
{"text": "( 2006 ) , The Architecture of the Mind , Oxford University Press .Chow , S.J. ( 2013 ) , \" What 's the Problem with the Frame Problem ? \" , Review of Philosophy and Psychology , 4 : 309 - 331 .", "label": "", "metadata": {}, "score": "47.612076"}
{"text": "In form ( b ) , the variables that do not appear in the rule then part are instead quantified existentially in the if part .These two forms are logically equivalent .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "47.81328"}
{"text": "In form ( b ) , the variables that do not appear in the rule then part are instead quantified existentially in the if part .These two forms are logically equivalent .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "47.81328"}
{"text": "PROBLEMS , PROBLEMS : THE FRAME PROBLEM AS A SYMPTOM OF THE SYMBOL GROUNDING PROBLEM Commentary on Van Brakel and Fetzer on Ford & Hayes on the Frame Problem .Stevan Harnad Laboratoire Cognition et Mouvement URA CNRS 1166 I.B.H.O.P. Universite d'Aix Marseille II 13388 Marseille cedex 13 , France 33 - 91 - 66 - 00 - 69 harnad@riluminy.univ-mrs.fr .", "label": "", "metadata": {}, "score": "47.9571"}
{"text": "The current frame must be a generator frame that has not yet completed in some other way .You may use yield resumption values to substitute a new value or one already yielded by a generator , or to make a generator yield additional values .", "label": "", "metadata": {}, "score": "48.013367"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088867"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088867"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088867"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088867"}
{"text": "Arguably , a capacity for analogical and metaphorical thinking - a talent for creatively transcending the boundaries between different domains of understanding - is the source of human cognitive prowess ( Lakoff & Johnson 1980 ; Mithen 1996 ) .So the informational unencapsulation of analogical reasoning is potentially very troublesome , and especially so for modular theories of mind in which modules are viewed as ( context - insensitive ) specialists ( Carruthers 2003 ; 2006 ) .", "label": "", "metadata": {}, "score": "48.10093"}
{"text": "For expository simplicity , the focus in what follows is on verbs .The discussion is extended to other types of heads in Chapters 3 and 4 .Notice that in such flat structures , the subject and any objects of the verb c - command each other .", "label": "", "metadata": {}, "score": "48.12908"}
{"text": "v ( a c ) p ) is also a term .To control the context in which any given symbol can occur in a RIF dialect , the language associates a signature with each symbol ( both constant and variable symbols ) .", "label": "", "metadata": {}, "score": "48.168793"}
{"text": "v ( a c ) p ) is also a term .To control the context in which any given symbol can occur in a RIF dialect , the language associates a signature with each symbol ( both constant and variable symbols ) .", "label": "", "metadata": {}, "score": "48.168793"}
{"text": "As Dreyfus puts it , \" if each context can be recognized only in terms of features selected as relevant and interpreted in a broader context , the AI worker is faced with a regress of contexts \" ( Dreyfus 1992 , 289 ) .", "label": "", "metadata": {}, "score": "48.187157"}
{"text": "People often fail to foresee every consequence of their actions even though they lack none of the information required to derive those consequences , as any novice chess player can testify .Fodor asserts that \" the frame problem goes very deep ; it goes as deep as the analysis of rationality \" ( Fodor 1987 ) .", "label": "", "metadata": {}, "score": "48.233826"}
{"text": "Pop any younger frames from the stack , and then change this frame into a frame for a call to function , with the given this value and arguments .Arguments should be an array of debuggee values .This frame must be a \" call \" frame .", "label": "", "metadata": {}, "score": "48.24405"}
{"text": "DOMAIN can be a frame or device , instead of a window .The value returned for a such a domain is used in special circumstances when a more specific domain does not apply ; for example , a frame value might be used for coloring a toolbar , which is conceptually attached to a frame rather than a particular window .", "label": "", "metadata": {}, "score": "48.2677"}
{"text": "DOMAIN can be a frame or device , instead of a window .The value returned for a such a domain is used in special circumstances when a more specific domain does not apply ; for example , a frame value might be used for coloring a toolbar , which is conceptually attached to a frame rather than a particular window .", "label": "", "metadata": {}, "score": "48.2677"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for the eval code is the VariableEnvironment this environment represents , and the bindings appear in a new declarative environment , which is the eval code 's LexicalEnvironment . )", "label": "", "metadata": {}, "score": "48.344078"}
{"text": "If LOCALE is omitted , the FACE 's actual value for PROPERTY will be returned .For built - in properties , this will be a specifier object of a type appropriate to the property ( e.g. a font or color specifier ) .", "label": "", "metadata": {}, "score": "48.355675"}
{"text": "If LOCALE is omitted , the FACE 's actual value for PROPERTY will be returned .For built - in properties , this will be a specifier object of a type appropriate to the property ( e.g. a font or color specifier ) .", "label": "", "metadata": {}, "score": "48.355675"}
{"text": "Hanks , S. & McDermott , D. ( 1987 ) , \" Nonmonotonic Logic and Temporal Projection \" , Artificial Intelligence , 33(3 ) : 379 - 412 .Haselager , W.F.G. & Van Rappard , J.F.H. ( 1998 ) , \" Connectionism , Systematicity , and the Frame Problem \" , Minds and Machines , 8(2 ) : 161 - 179 .", "label": "", "metadata": {}, "score": "48.40247"}
{"text": "The question that we focus on for most of the rest of this chapter is what information needs to be included in the elementary trees .A first important piece of information is clearly a lexical item 's syntactic category .This can easily be represented as the lexical item 's mother , as shown in ( 14 ) .", "label": "", "metadata": {}, "score": "48.45805"}
{"text": "Frame methods and accessor properties work as described on generator frames , even when the generator frame is suspended .You may examine a suspended generator frame 's variables , and use its script and offset members to see which yield it is suspended at .", "label": "", "metadata": {}, "score": "48.46521"}
{"text": "The formalisms themselves are not presented in full : what is presented are simplified versions that are sufficient to explain the full solution .This solution was proposed by Erik Sandewall , who also defined a formal language for the specification of dynamical domains ; therefore , such a domain can be first expressed in this language and then automatically translated into logic .", "label": "", "metadata": {}, "score": "48.4859"}
{"text": "All bound variables that occur in the rule are implicitly or explicitly universally quantified outside of the rule .The class Ruleset contains zero or more RULE s , where each RULE is one of the following classes : .Implies , which distinguishes if - CONDITION from then - ATOMIC parts .", "label": "", "metadata": {}, "score": "48.4971"}
{"text": "All bound variables that occur in the rule are implicitly or explicitly universally quantified outside of the rule .The class Ruleset contains zero or more RULE s , where each RULE is one of the following classes : .Implies , which distinguishes if - CONDITION from then - ATOMIC parts .", "label": "", "metadata": {}, "score": "48.4971"}
{"text": "This permits the straightforward representation of the various subcategories of verbs , the fact that prepositions take objects , and so on .Elementary trees for prepositions and for ditransitive , transitive , and intransitive verbs are illustrated in ( 17 ) .", "label": "", "metadata": {}, "score": "48.587517"}
{"text": "Return a property descriptor for the property named name of the referent .If the referent has no such property , return undefined .Return an array of strings naming all the referent 's own properties , as if Object.getOwnPropertyNames(referent ) had been called in the debuggee , and the result copied in the scope of the debugger 's global object .", "label": "", "metadata": {}, "score": "48.613968"}
{"text": "It has also been suggested that isotropy is damaging to the so - called theory theory of folk psychology ( Heal 1996 ) .( For Heal , this lends support to the rival simulation theory , but Wilkerson ( 2001 ) argues that informational unencapsulation is a problem for both accounts of folk psychology . )", "label": "", "metadata": {}, "score": "48.631996"}
{"text": "Since Debugger instances do n't hold strong references to their debuggee globals , if a debuggee global is otherwise unreachable , it may be dropped at any moment from the array this method returns .Return an array containing the values of the url properties of all debuggee scripts matching query .", "label": "", "metadata": {}, "score": "48.789837"}
{"text": "It can be represented by an IRI or be known only locally .Semantically , a frame slot is a set - valued function that represents a property of an object .Such a function maps an object i d to a set of values of the property .", "label": "", "metadata": {}, "score": "48.810665"}
{"text": "Truth valuation of formulas .Observe that the notion of signatures from Section Symbols and Signatures is used only to constrain the syntax and does not appear in the definition of the semantic structure .This is because when we define truth valuations for formulas , below , all formulas are assumed to be well - formed .", "label": "", "metadata": {}, "score": "48.822205"}
{"text": "Truth valuation of formulas .Observe that the notion of signatures from Section Symbols and Signatures is used only to constrain the syntax and does not appear in the definition of the semantic structure .This is because when we define truth valuations for formulas , below , all formulas are assumed to be well - formed .", "label": "", "metadata": {}, "score": "48.822205"}
{"text": "Frames not matching these propertiess should have frame local faces .The value should be nil , if uninitialized , or a plist otherwise .See ' defface ' for a list of valid keys and values for the plist . \" ) ( defun get - custom - frame - properties ( & optional frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "48.8599"}
{"text": "Frames not matching these propertiess should have frame local faces .The value should be nil , if uninitialized , or a plist otherwise .See ' defface ' for a list of valid keys and values for the plist . \" ) ( defun get - custom - frame - properties ( & optional frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "48.8599"}
{"text": "For the Horn subset , Q is a universal prefix , i.e. , all variables in the rule are universally quantified outside of the rule .We first define the notion of rule satisfaction without the quantification prefix Q : .In this case we also say that I is a model of the rule .", "label": "", "metadata": {}, "score": "48.896835"}
{"text": "For the Horn subset , Q is a universal prefix , i.e. , all variables in the rule are universally quantified outside of the rule .We first define the notion of rule satisfaction without the quantification prefix Q : .In this case we also say that I is a model of the rule .", "label": "", "metadata": {}, "score": "48.896835"}
{"text": "Frames .A well - formed frame formula is one of the following : .Membership formula : o # c , where o , c are well - formed terms .Informally , such a formula says that object o is a member of class c .", "label": "", "metadata": {}, "score": "48.949028"}
{"text": "Frames .A well - formed frame formula is one of the following : .Membership formula : o # c , where o , c are well - formed terms .Informally , such a formula says that object o is a member of class c .", "label": "", "metadata": {}, "score": "48.949028"}
{"text": "The AI researchers who tackled the original frame problem in its narrow , technical guise were working under this constraint , since logic - based AI is a variety of classical AI .Philosophers sympathetic to the computational theory of mind -who suppose that mental states comprise sets of propositional attitudes and mental processes are forms of inference over the propositions in question - also tend to feel at home with this prescription .", "label": "", "metadata": {}, "score": "48.972633"}
{"text": "More general formulas are constructed out of atomic formulas with the help of logical connectives .The condition sublanguage of RIF - BLD defines the following general well - formed condition formulas .If \u03c6 is a well - formed atomic formula then it is also a well - formed condition formula .", "label": "", "metadata": {}, "score": "48.998863"}
{"text": "More general formulas are constructed out of atomic formulas with the help of logical connectives .The condition sublanguage of RIF - BLD defines the following general well - formed condition formulas .If \u03c6 is a well - formed atomic formula then it is also a well - formed condition formula .", "label": "", "metadata": {}, "score": "48.998863"}
{"text": "The aforesaid term t is a well - formed slotted atomic formula if \u03c3 is atomic .A slotted atomic formula is just like an atomic formula of Section Symbols and Signatures except that the arguments of the predicate are named and their order is considered immaterial .", "label": "", "metadata": {}, "score": "49.118584"}
{"text": "The aforesaid term t is a well - formed slotted atomic formula if \u03c3 is atomic .A slotted atomic formula is just like an atomic formula of Section Symbols and Signatures except that the arguments of the predicate are named and their order is considered immaterial .", "label": "", "metadata": {}, "score": "49.118584"}
{"text": "We will continue to use Const to refer to the set of all constant symbols and Var to refer to the set of all variable symbols .The other components of I are mappings defined as follows : .I C from Const to elements of D .", "label": "", "metadata": {}, "score": "49.13613"}
{"text": "We will continue to use Const to refer to the set of all constant symbols and Var to refer to the set of all variable symbols .The other components of I are mappings defined as follows : .I C from Const to elements of D .", "label": "", "metadata": {}, "score": "49.13613"}
{"text": "In such a case , the instantiator used to create that instance object will be used ( for example , if you set a font - instance object as the value of the ' font property , then the font name used to create that object will be used instead ) .", "label": "", "metadata": {}, "score": "49.152336"}
{"text": "In such a case , the instantiator used to create that instance object will be used ( for example , if you set a font - instance object as the value of the ' font property , then the font name used to create that object will be used instead ) .", "label": "", "metadata": {}, "score": "49.152336"}
{"text": "Frame.prototype.environment to return more complete environment chains than Debugger . Object.prototype.environment .This possibility should be documented , along with its effects on environment identity .The interface should provide clean , predictable ways to observe the effects of garbage collection .", "label": "", "metadata": {}, "score": "49.244717"}
{"text": "Having grasped the cup and withdrawn it from the cupboard , the robot needs to update this database .The location of the cup has clearly changed , so that 's one fact that demands revision .But which other sentences require modification ?", "label": "", "metadata": {}, "score": "49.283356"}
{"text": "Commentary on Van Brakel and Fetzer on Ford & Hayes on the Frame Problem .In the ongoing discussion of the \" frame problem \" ( McCarthy 1963 ; McCarthy & Hayes 1969 ; Hayes 1992 ) there has been a steady proliferation of problems and problem - names ( in a way that is itself reminiscent of a frame problem ! )", "label": "", "metadata": {}, "score": "49.389942"}
{"text": "From the 1950s until roughly 1980 , syntactic structure was thought to be generated by phrase structure rules like those in ( 1 ) .V .Specifically , the lefthand side of a phrase structure rule consists of exactly one symbol , whereas the righthand side of a phrase structure rule may consist of one or more symbols .", "label": "", "metadata": {}, "score": "49.39052"}
{"text": "From a theoretical perspective , RIF - BLD corresponds to the language of definite Horn rules ( see Horn Logic ) with equality and with a standard first - order semantics .Syntactically , RIF - BLD has a number of extensions to support features such as objects and frames , internationalized resource identifiers ( or IRIs , defined by RFC 3987 ) as identifiers for concepts , and XML Schema data types .", "label": "", "metadata": {}, "score": "49.44262"}
{"text": "( This function behaves like Object.defineProperties , except that the target object is implicit , and in a different compartment from the properties argument . )Prevent properties from being added to or deleted from the referent .Return this Debugger .", "label": "", "metadata": {}, "score": "49.454544"}
{"text": "RIF dialects control the contexts in which the different symbols can occur by attaching signatures to these symbols .RIF - BLD carefully selects signatures for the symbols so that the corresponding logic will be first - order : each symbol has a unique role as a symbol that represents an individual object , a function symbol of a particular arity , or a predicate symbol of a particular arity .", "label": "", "metadata": {}, "score": "49.515213"}
{"text": "RIF dialects control the contexts in which the different symbols can occur by attaching signatures to these symbols .RIF - BLD carefully selects signatures for the symbols so that the corresponding logic will be first - order : each symbol has a unique role as a symbol that represents an individual object , a function symbol of a particular arity , or a predicate symbol of a particular arity .", "label": "", "metadata": {}, "score": "49.515213"}
{"text": "The basic language construct is called term , which is defined inductively as follows : .If t and t 1 , ... , t n are terms then t ( t 1 ... t n ) is a term .This definition is very general .", "label": "", "metadata": {}, "score": "49.698532"}
{"text": "The basic language construct is called term , which is defined inductively as follows : .If t and t 1 , ... , t n are terms then t ( t 1 ... t n ) is a term .This definition is very general .", "label": "", "metadata": {}, "score": "49.698532"}
{"text": "A slot can be represented by an individual symbol or , more generally , by a Uniterm .It can be represented by an IRI or be known only locally .Semantically , a frame slot is a set - valued function that represents a property of an object .", "label": "", "metadata": {}, "score": "49.704643"}
{"text": "The arguments passed to the current frame , or null if this is not a \" call \" frame .When non - null , this is an object , allocated in the same global as the debugger , with Array.prototype on its prototype chain , a non - writable length property , and properties whose names are array indices .", "label": "", "metadata": {}, "score": "49.760834"}
{"text": "McCarthy , J and Hayes , P ( 1969 )Some philosophical problems from the standpoint of Artificial Intelligence .In B. Meltzer & D. Michie ( eds ) Machine Intelligence 4 .Elsevier .van Brakel , J. ( 1992 )", "label": "", "metadata": {}, "score": "49.796856"}
{"text": "The event calculus uses terms for representing fluents , like the fluent calculus , but also has axioms constraining the value of fluents , like the successor state axioms .In the event calculus , inertia is enforced by formulae stating that a fluent is true if it has been true at a given previous time point and no action changing it to false has been performed in the meantime .", "label": "", "metadata": {}, "score": "49.834366"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the foreground appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "49.86311"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the foreground appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "49.86311"}
{"text": "Let the symbol on the lefthand side of a phrase structure rule correspond to a node in a tree .b. .Let the symbols on the righthand side of a phrase structure rule correspond to a set of nodes in the same order as that of the symbols in the rule .", "label": "", "metadata": {}, "score": "49.880615"}
{"text": "Shanahan , M. & Baars , B.J. ( 2005 ) , \" Applying Global Workspace Theory to the Frame Problem \" , Cognition , 98(2 ) : 157 - 176 .Simon , H. ( 1957 ) , Models of Man , Wiley .", "label": "", "metadata": {}, "score": "50.024193"}
{"text": "This allows the code using each Debugger instance to place whatever properties it likes on its Debugger .Frame instances , without worrying about interfering with other debuggers . )Note that frames only become inactive at times that are predictable for the debugger : when the debuggee runs , or when the debugger removes frames from the stack itself .", "label": "", "metadata": {}, "score": "50.025833"}
{"text": "McCarthy , J. ( 1986 ) , \" Applications of Circumscription to Formalizing Common Sense Knowledge \" , Artificial Intelligence , 26(3 ) : 89 - 116 .McCarthy , J. & Hayes , P.J. ( 1969 ) , \" Some Philosophical Problems from the Standpoint of Artificial Intelligence \" , in Machine Intelligence 4 , ed .", "label": "", "metadata": {}, "score": "50.109715"}
{"text": "Is it possible , in principle , to limit the scope of the reasoning required to derive the consequences of an action ?And , more generally , how do we account for our apparent ability to make decisions on the basis only of what is relevant to an ongoing situation without having explicitly to consider all that is not relevant ?", "label": "", "metadata": {}, "score": "50.189697"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the font appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "50.194878"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the font appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "50.194878"}
{"text": "On success , return undefined ; on failure , throw an appropriate exception .Name must be a string whose value is a valid ECMAScript identifier name .Return a reference to the innermost environment , starting with this environment , that binds name .", "label": "", "metadata": {}, "score": "50.620064"}
{"text": "To gain an understanding of the issues , this article will begin with a look at the frame problem in its technical guise .Some of the ways in which philosophers have re - interpreted the problem will then be examined .", "label": "", "metadata": {}, "score": "51.011036"}
{"text": "If LOCALE specifies a valid domain ( i.e. a window , frame , or device ) , this function instantiates the specifier over that domain , applies FUNC to the resulting instance , and adds the result back as an instantiator for that locale .", "label": "", "metadata": {}, "score": "51.017097"}
{"text": "If LOCALE specifies a valid domain ( i.e. a window , frame , or device ) , this function instantiates the specifier over that domain , applies FUNC to the resulting instance , and adds the result back as an instantiator for that locale .", "label": "", "metadata": {}, "score": "51.017097"}
{"text": "This is analogous to the interpretation of regular ( positional ) terms with two differences : .The argument to a slotted term is a finite bag of slot / value pairs rather than an ordered sequence .Bags are used here because , for slotted terms , the order of slot / value pairs is immaterial , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "51.116096"}
{"text": "This is analogous to the interpretation of regular ( positional ) terms with two differences : .The argument to a slotted term is a finite bag of slot / value pairs rather than an ordered sequence .Bags are used here because , for slotted terms , the order of slot / value pairs is immaterial , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "51.116096"}
{"text": "Let SigNames be a non - empty , partially - ordered finite or countably infinite set of signature names .We require that this set includes at least the name atomic , which represents the context of atomic formulas .Dialects are free to introduce additional signature names .", "label": "", "metadata": {}, "score": "51.15327"}
{"text": "Let SigNames be a non - empty , partially - ordered finite or countably infinite set of signature names .We require that this set includes at least the name atomic , which represents the context of atomic formulas .Dialects are free to introduce additional signature names .", "label": "", "metadata": {}, "score": "51.15327"}
{"text": "Rule bodies and queries in declarative logic programming dialects ( LP ) .Rule bodies in first - order dialects ( FO ) .Conditions in the rule bodies of the Production Rule Dialect ( RIF PRD ) .The event and condition parts of the rule bodies in reactive rule dialects ( RR ) .", "label": "", "metadata": {}, "score": "51.33339"}
{"text": "Rule bodies and queries in declarative logic programming dialects ( LP ) .Rule bodies in first - order dialects ( FO ) .Conditions in the rule bodies of the Production Rule Dialect ( RIF PRD ) .The event and condition parts of the rule bodies in reactive rule dialects ( RR ) .", "label": "", "metadata": {}, "score": "51.33339"}
{"text": "Presentation syntax .This syntax is used in formal definitions , especially for the semantics .It is a human - oriented syntax and , therefore , we use it in the model theory and the examples .The presentation syntax is not meant to be used for exchange of RIF rules .", "label": "", "metadata": {}, "score": "51.333652"}
{"text": "Presentation syntax .This syntax is used in formal definitions , especially for the semantics .It is a human - oriented syntax and , therefore , we use it in the model theory and the examples .The presentation syntax is not meant to be used for exchange of RIF rules .", "label": "", "metadata": {}, "score": "51.333652"}
{"text": "For example , the state in which the door is open and the light is on is represented by the term .It is important to notice that a term is not true or false by itself , as it is an object and not a condition .", "label": "", "metadata": {}, "score": "51.520294"}
{"text": "Symbols with an ill - formed lexical part .RIF constant symbols that belong to one of the aforesaid RIF - supported symbol spaces must be well - formed , i.e. , their lexical part must belong to the lexical space associated with the symbol space .", "label": "", "metadata": {}, "score": "51.558052"}
{"text": "Symbols with an ill - formed lexical part .RIF constant symbols that belong to one of the aforesaid RIF - supported symbol spaces must be well - formed , i.e. , their lexical part must belong to the lexical space associated with the symbol space .", "label": "", "metadata": {}, "score": "51.558052"}
{"text": "Dreyfus regards the neurodynamics work of Freeman ( 2000 ) as a better foundation for the sort of Heideggerian approach to AI in which the frame problem might be dissolved ( see also Shanahan 2010 , Ch.5 ; Rietveld 2012 ; Bruineberg & Rietveld 2014 ) .", "label": "", "metadata": {}, "score": "51.660843"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments .\" See ' face - property - instance ' for the semantics of the DOMAIN argument . \" Then , check those properties specific to ; ; the particular device type .", "label": "", "metadata": {}, "score": "51.74865"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments .\" See ' face - property - instance ' for the semantics of the DOMAIN argument . \" Then , check those properties specific to ; ; the particular device type .", "label": "", "metadata": {}, "score": "51.74865"}
{"text": "The symbols need not have any intrinsic meaning of their own ; they need only be systematically interpretable by us as meaning what they mean , and then our own minds and actions can mediate the connection between the symbols and what they can be interpreted as being about .", "label": "", "metadata": {}, "score": "51.893143"}
{"text": "The symbols need not have any intrinsic meaning of their own ; they need only be systematically interpretable by us as meaning what they mean , and then our own minds and actions can mediate the connection between the symbols and what they can be interpreted as being about .", "label": "", "metadata": {}, "score": "51.893143"}
{"text": "New York : Oxford University Press .ISBN 0 - 19 - 853845 - 6 .Sandewall , E. ; Shoham , Y. ( 1995 ) .\" Non - monotonic Temporal Reasoning \" .In Gabbay , D. M. ; Hogger , C. J. ; Robinson , J. A. Handbook of Logic in Artificial Intelligence and Logic Programming .", "label": "", "metadata": {}, "score": "51.917957"}
{"text": "The frame problem , likewise , is one of justifying some inferences about the future as opposed to others .The second problem is an instance of the first .\" This view of the frame problem is highly controversial , however ( Hayes 1991 ) .", "label": "", "metadata": {}, "score": "51.96403"}
{"text": "PSYCOLOQUY 3(60 ) frame - problem.2 .The Frame Problem .First published Mon Feb 23 , 2004 ; substantive revision Mon Feb 8 , 2016 .To most AI researchers , the frame problem is the challenge of representing the effects of action in logic without having to represent explicitly a large number of intuitively obvious non - effects .", "label": "", "metadata": {}, "score": "52.06315"}
{"text": "Such polymorphism is common practice in Logic Programming ( e.g. , [ Prolog ] , [ F - logic ] , [ HiLog ] ) and in [ RDF].This extensibility is achieved in RIF by building its syntax on the basis of signatures .", "label": "", "metadata": {}, "score": "52.06624"}
{"text": "Such polymorphism is common practice in Logic Programming ( e.g. , [ Prolog ] , [ F - logic ] , [ HiLog ] ) and in [ RDF].This extensibility is achieved in RIF by building its syntax on the basis of signatures .", "label": "", "metadata": {}, "score": "52.06624"}
{"text": "Finally , CONDITION assembles everything into what we earlier called RIF condition formulas .Note that individuals , function symbols , and predicate symbols all belong to the same set of symbols Const .This syntax is more general than what RIF - BLD actually permits .", "label": "", "metadata": {}, "score": "52.08779"}
{"text": "Finally , CONDITION assembles everything into what we earlier called RIF condition formulas .Note that individuals , function symbols , and predicate symbols all belong to the same set of symbols Const .This syntax is more general than what RIF - BLD actually permits .", "label": "", "metadata": {}, "score": "52.08779"}
{"text": "The article on the situation calculus gives more details .While the three formulae above are a direct expression in logic of what is known , they do not suffice to correctly draw consequences .While the following conditions ( representing the expected situation ) are consistent with the three formulae above , they are not the only ones .", "label": "", "metadata": {}, "score": "52.09261"}
{"text": "This is analogous to the interpretation of regular ( positional ) predicates except for two differences : .The argument to a slotted predicate is a finite bag of slot / value pairs rather than an ordered sequence .Bags ( also known as multisets ) are used here because for slotted predicates the order of slot - value pairs does not matter , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "52.114098"}
{"text": "This is analogous to the interpretation of regular ( positional ) predicates except for two differences : .The argument to a slotted predicate is a finite bag of slot / value pairs rather than an ordered sequence .Bags ( also known as multisets ) are used here because for slotted predicates the order of slot - value pairs does not matter , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "52.114098"}
{"text": "463 - 502 .McDermott , D. ( 1987 ) , \" We 've Been Framed : Or Why AI Is Innocent of the Frame Problem \" , in Pylyshyn ( 1987 ) .Mithen , S. ( 1987 ) , The Prehistory of the Mind , Thames & Hudson .", "label": "", "metadata": {}, "score": "52.16349"}
{"text": "Formal systems do very well in the world of formal , Platonic objects : An axiomatic system can successfully \" second - guess \" all the truths of arithmetic ( I hope no one will cite Goedelian limits on provability as instances of the frame problem ! )", "label": "", "metadata": {}, "score": "52.224415"}
{"text": "Formal systems do very well in the world of formal , Platonic objects : An axiomatic system can successfully \" second - guess \" all the truths of arithmetic ( I hope no one will cite Goedelian limits on provability as instances of the frame problem ! )", "label": "", "metadata": {}, "score": "52.224415"}
{"text": "We say an environment binds an identifier if that environment itself associates the identifier with a variable , independently of its outer environments .We say an identifier is in scope in an environment if the identifier is bound in that environment or any enclosing environment .", "label": "", "metadata": {}, "score": "52.286922"}
{"text": "The current document is the second draft of the RIF - BLD specification ( in the first draft called ' RIF Core ' ) .A number of extensions are planned to support built - ins , additional primitive XML data types , the notion of RIF compliance , and so on .", "label": "", "metadata": {}, "score": "52.332115"}
{"text": "The current document is the second draft of the RIF - BLD specification ( in the first draft called ' RIF Core ' ) .A number of extensions are planned to support built - ins , additional primitive XML data types , the notion of RIF compliance , and so on .", "label": "", "metadata": {}, "score": "52.332115"}
{"text": "Yet he goes on to reaffirm his conviction that , in the frame problem , AI has discovered \" a new , deep epistemological problem - accessible in principle but unnoticed by generations of philosophers \" .The best way to gain an understanding of the issue is to imagine being the designer of a robot that has to carry out an everyday task , such as making a cup of tea .", "label": "", "metadata": {}, "score": "52.347157"}
{"text": "The functions described below may only be called with a this value referring to a Debugger .Object instance ; they may not be used as methods of other kinds of objects .The descriptions use \" referent \" to mean \" the referent of this Debugger .", "label": "", "metadata": {}, "score": "52.51065"}
{"text": "the condition was previously true and the action does not make it false .A successor state axiom is a formalization in logic of these two facts .For example , if and are two conditions used to denote that the action executed at time was to open or close the door , respectively , the running example is encoded as follows .", "label": "", "metadata": {}, "score": "52.513412"}
{"text": "This can be a singleton set or even an empty set .In contrast , a uniterm slot semantically behaves like a unary uninterpreted function symbol .In both cases , however , the order of the slots is immaterial ( in contrast to positional uniterms ) .", "label": "", "metadata": {}, "score": "52.557648"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" display - table \" ) ) ( set - face - property face ' display - table display - table locale tag - set how - to - add ) ) ; ; The following accessors and mutators are , IMHO , good ; ; implementation .", "label": "", "metadata": {}, "score": "52.768627"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" display - table \" ) ) ( set - face - property face ' display - table display - table locale tag - set how - to - add ) ) ; ; The following accessors and mutators are , IMHO , good ; ; implementation .", "label": "", "metadata": {}, "score": "52.768627"}
{"text": "\" The frame problem in the situation calculus : a simple solution ( sometimes ) and a completeness result for goal regression \" .In Lifschitz , Vladimir .Artificial Intelligence and Mathematical Theory of Computation : Papers in Honor of John McCarthy .", "label": "", "metadata": {}, "score": "52.796326"}
{"text": "If FONT is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "53.02871"}
{"text": "If FONT is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "53.02871"}
{"text": "So we will either not notice them or cease to regard them as evidence that there is something wrong with this kind of model in the first place .I am more pessimistic .I think the reason the frame problem keeps rearing its head is because there is something intrinsically wrong with an ungrounded symbolic approach to modeling the mind ( if not to building useful tools for systems with minds ) .", "label": "", "metadata": {}, "score": "53.147762"}
{"text": "So we will either not notice them or cease to regard them as evidence that there is something wrong with this kind of model in the first place .I am more pessimistic .I think the reason the frame problem keeps rearing its head is because there is something intrinsically wrong with an ungrounded symbolic approach to modeling the mind ( if not to building useful tools for systems with minds ) .", "label": "", "metadata": {}, "score": "53.147762"}
{"text": "All the components except the last five , I slot , I SF , I SR , I sub , I isa , are the same as before .The new mapping I slot is used to interpret frames ; the mappings I SF and I SR interpret terms and predicates with named arguments , respectively ; I sub gives meaning to the subclass hierarchy ; and I isa interprets class membership .", "label": "", "metadata": {}, "score": "53.16731"}
{"text": "All the components except the last five , I slot , I SF , I SR , I sub , I isa , are the same as before .The new mapping I slot is used to interpret frames ; the mappings I SF and I SR interpret terms and predicates with named arguments , respectively ; I sub gives meaning to the subclass hierarchy ; and I isa interprets class membership .", "label": "", "metadata": {}, "score": "53.16731"}
{"text": "Return an array of Debugger .Script instances for all debuggee scripts matching query .Each instance appears only once in the array .Query is an object whose properties restrict which scripts are returned ; a script must meet all the criteria given by query to be returned .", "label": "", "metadata": {}, "score": "53.187046"}
{"text": "Currently the only useful value for MATCHSPEC is a charset , when used in conjunction with the face 's font ; this allows you to retrieve a font that can be used to display a particular charset , rather than just any font .", "label": "", "metadata": {}, "score": "53.217983"}
{"text": "Currently the only useful value for MATCHSPEC is a charset , when used in conjunction with the face 's font ; this allows you to retrieve a font that can be used to display a particular charset , rather than just any font .", "label": "", "metadata": {}, "score": "53.217983"}
{"text": "As a result , a predicate changes if and only if the corresponding change predicate is true .An action results in a change if and only if it makes true a condition that was previously false or vice versa .The third formula is a different way of saying that opening the door causes the door to be opened .", "label": "", "metadata": {}, "score": "53.32924"}
{"text": "In a sufficiently simple robot , this does n't seem like much of a problem .Surely the robot can simply examine its entire database of propositions one - by - one and work out which require modification .But if we imagine that our robot has near human - level intelligence , and is therefore burdened with an enormous database of facts to examine every time it so much as spins a motor , such a strategy starts to look computationally intractable .", "label": "", "metadata": {}, "score": "53.489742"}
{"text": "Object instance belonging to this Debugger instance , then its referent is used .If the object is not a global object , then the global in whose scope it was allocated is used .Note that the result may include values for scripts that can no longer ever be used by the debuggee , say , those for eval code that has finished running , or unreachable functions .", "label": "", "metadata": {}, "score": "53.51384"}
{"text": "The return value will be a list of instantiators ( e.g. strings specifying a font or color name ) , or a list of specifications , each of which is a cons of a locale and a list of instantiators .Specifically , if LOCALE is a particular locale ( a buffer , window , frame , device , or ' global ) , a list of instantiators for that locale will be returned .", "label": "", "metadata": {}, "score": "53.61689"}
{"text": "The return value will be a list of instantiators ( e.g. strings specifying a font or color name ) , or a list of specifications , each of which is a cons of a locale and a list of instantiators .Specifically , if LOCALE is a particular locale ( a buffer , window , frame , device , or ' global ) , a list of instantiators for that locale will be returned .", "label": "", "metadata": {}, "score": "53.61689"}
{"text": "Each Debugger instance maintains a set of global objects that , taken together , comprise the debuggee .Code evaluated in the scope of a debuggee global object , directly or indirectly , is considered debuggee code .Similarly : .When a debuggee stack frame completes its execution , or when some sort of debuggee call initiated by the debugger finishes , the Debugger interface provides a value describing how the code completed ; these are called completion values .", "label": "", "metadata": {}, "score": "53.653557"}
{"text": "John McCarthy and Patrick J. Hayes defined this problem in their 1969 article , Some Philosophical Problems from the Standpoint of Artificial Intelligence .In this paper and many that came after the formal mathematical problem was a starting point for more general discussions of the difficulty of knowledge representation for artificial intelligence .", "label": "", "metadata": {}, "score": "53.65757"}
{"text": "Y in the first RIF condition of Example 1 is quantified , existentially , but ?X is free .However , when this condition occurs in the if part of the second rule in Example 1 , then this variable is quantified universally outside of the rule .", "label": "", "metadata": {}, "score": "53.674408"}
{"text": "Y in the first RIF condition of Example 1 is quantified , existentially , but ?X is free .However , when this condition occurs in the if part of the second rule in Example 1 , then this variable is quantified universally outside of the rule .", "label": "", "metadata": {}, "score": "53.674408"}
{"text": "Script instance ) , or null on frames that do not represent calls to debuggee code .On frames whose callee property is not null , this is equal to callee.script .The lexical environment within which evaluation is taking place ( a Debugger .", "label": "", "metadata": {}, "score": "53.78767"}
{"text": "Quantification : I Truth ( Exists ?v 1 ... ?v 1 , ... , ?v n .In this section we extend Positive Conditions , defined in Section Positive Conditions , with slotted Uniterm s and Frame formulas .", "label": "", "metadata": {}, "score": "53.797356"}
{"text": "Any value assigned to a debugging handler must be either a function or undefined ; otherwise a TypeError is thrown .New code , represented by the Debugger .Script instance script , has been loaded in the scope of the debuggee global object global .", "label": "", "metadata": {}, "score": "53.813354"}
{"text": "In addition , RIF - BLD imposes the following restrictions : .The terms that are allowed as slot names in slotted terms .they must be constant symbols .This means that RIF - BLD does not allow variables or complex terms ( like f ( ) , f(a , b ) ) as slot names in slotted uniterms ( but there are no such restrictions on slots in frames ) .", "label": "", "metadata": {}, "score": "53.85846"}
{"text": "In addition , RIF - BLD imposes the following restrictions : .The terms that are allowed as slot names in slotted terms .they must be constant symbols .This means that RIF - BLD does not allow variables or complex terms ( like f ( ) , f(a , b ) ) as slot names in slotted uniterms ( but there are no such restrictions on slots in frames ) .", "label": "", "metadata": {}, "score": "53.85846"}
{"text": "This specifier stuff needs some rethinking .( really ! )( or ( null domain ) ( not ( equal inst ( face - property - instance face ' font domain ) ) ) ; ; do n't do it for standard faces , or you 'll get inheritance loops .", "label": "", "metadata": {}, "score": "53.88481"}
{"text": "This specifier stuff needs some rethinking .( really ! )( or ( null domain ) ( not ( equal inst ( face - property - instance face ' font domain ) ) ) ; ; do n't do it for standard faces , or you 'll get inheritance loops .", "label": "", "metadata": {}, "score": "53.88481"}
{"text": "The first significant mention of the frame problem in the philosophical literature was made by Dennett ( 1978 , 125 ) .The puzzle , according to Dennett , is how \" a cognitive creature ... with many beliefs about the world \" can update those beliefs when it performs an act so that they remain \" roughly faithful to the world \" ?", "label": "", "metadata": {}, "score": "53.94079"}
{"text": "RIF - BLD presentation syntax does not commit to any particular vocabulary for the names of variables or for the literals used in constant symbols .In the examples , variables are denoted by Unicode character sequences beginning with a ? -sign .", "label": "", "metadata": {}, "score": "53.95169"}
{"text": "RIF - BLD presentation syntax does not commit to any particular vocabulary for the names of variables or for the literals used in constant symbols .In the examples , variables are denoted by Unicode character sequences beginning with a ? -sign .", "label": "", "metadata": {}, "score": "53.95169"}
{"text": "These will also be ; ; frobbed further in init - other - random - faces .; ; These warnings are there for a reason .Just specify your fonts ; ; correctly .Deal with it .Additionally , one can use ; ; ' log - warning - minimum - level ' instead of this . ; ( defvar inhibit - font - complaints nil ; \" Whether to suppress complaints about incomplete sets of fonts . \")", "label": "", "metadata": {}, "score": "53.967957"}
{"text": "These will also be ; ; frobbed further in init - other - random - faces .; ; These warnings are there for a reason .Just specify your fonts ; ; correctly .Deal with it .Additionally , one can use ; ; ' log - warning - minimum - level ' instead of this . ; ( defvar inhibit - font - complaints nil ; \" Whether to suppress complaints about incomplete sets of fonts . \")", "label": "", "metadata": {}, "score": "53.967957"}
{"text": "Instead , white space is informally used as a delimiter .This is done on purpose , since RIF 's presentation syntax is intended to be used for specifying semantics and to illustrate the main RIF concepts through examples .It is not intended as a concrete syntax for a rule language .", "label": "", "metadata": {}, "score": "54.117596"}
{"text": "Instead , white space is informally used as a delimiter .This is done on purpose , since RIF 's presentation syntax is intended to be used for specifying semantics and to illustrate the main RIF concepts through examples .It is not intended as a concrete syntax for a rule language .", "label": "", "metadata": {}, "score": "54.117596"}
{"text": "This is the question of how to compute the consequences of an action without the computation having to range over the action 's non - effects .The solution to the computational aspect of the frame problem adopted in most symbolic AI programs is some variant of what McDermott calls the \" sleeping dog \" strategy ( McDermott 1987 ) .", "label": "", "metadata": {}, "score": "54.15293"}
{"text": "Object instance presents its referent as it would be seen from a particular compartment .This \" viewing compartment \" is chosen to match the way the debugger came across the referent .As a consequence , a single Debugger instance may actually have several Debugger .", "label": "", "metadata": {}, "score": "54.193565"}
{"text": "The same symbol can occur in multiple contexts at the same time .For instance , if p , a , and b are symbols then p ( p ( a ) p ( a p c ) ) is a term .", "label": "", "metadata": {}, "score": "54.265152"}
{"text": "The same symbol can occur in multiple contexts at the same time .For instance , if p , a , and b are symbols then p ( p ( a ) p ( a p c ) ) is a term .", "label": "", "metadata": {}, "score": "54.265152"}
{"text": "It is important to attach the adjunct as a daughter of the higher copy of the intermediate projection .Attaching the adjunct as a daughter of the lower copy would result in a structure in which the attached constituent is incorrectly represented as a complement .", "label": "", "metadata": {}, "score": "54.29795"}
{"text": "Name must be a string whose value is a valid ECMAScript identifier name .Code is a string .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If code is not strict mode code , then variable declarations in code affect this environment .", "label": "", "metadata": {}, "score": "54.330784"}
{"text": "If a given method is absent from handler , then events of that sort are ignored .The watchpoint consults handler 's properties each time an event occurs , so adding methods to or removing methods from handler after setting the watchpoint enables or disables reporting of the corresponding events .", "label": "", "metadata": {}, "score": "54.48581"}
{"text": "Tools should instead use the [ [ Remote Debugging Protocol ] ] for all inter - thread communication .Properties are configurable .This applies to both \" own \" and prototype properties , and to both methods and data properties .", "label": "", "metadata": {}, "score": "54.50711"}
{"text": "Object instance belonging to this Debugger instance , then its referent is used .If the object is not a global object , then the global in whose scope it was allocated is used .Note that the result may include Debugger .", "label": "", "metadata": {}, "score": "54.52906"}
{"text": "If this frame 's environment property is null , throw a TypeError .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If code is not strict mode code , then variable declarations in code affect the environment of this frame .", "label": "", "metadata": {}, "score": "54.547714"}
{"text": "In : Working Papers of the AAAI Spring Symposium on Machine Learning of Natural Language and Ontology ( DW Powers & L Reeker , Eds . ) pp .65 - 74 .Presented at Symposium on Symbol Grounding : Problems and Practice , Stanford University , March 1991 .", "label": "", "metadata": {}, "score": "54.682007"}
{"text": "Forall , which is specified through its parts , i.e. one or more variable ( Var ) declarations and , recursively , a RULE as the formula in their scope .Var , ATOMIC , and CONDITION were defined as part of the syntax for positive conditions in Positive Conditions .", "label": "", "metadata": {}, "score": "54.75267"}
{"text": "Forall , which is specified through its parts , i.e. one or more variable ( Var ) declarations and , recursively , a RULE as the formula in their scope .Var , ATOMIC , and CONDITION were defined as part of the syntax for positive conditions in Positive Conditions .", "label": "", "metadata": {}, "score": "54.75267"}
{"text": "( This function behaves like the standard Object.isSealed function , except that the object inspected is implicit and in a different compartment from the caller . )Return true if the referent is frozen \u2014 that is , if it is not extensible , and all its properties have been marked as non - configurable and read - only .", "label": "", "metadata": {}, "score": "54.760685"}
{"text": "( face - property - instance face ' reverse domain default no - fallback ) ) ( defun set - face - reverse - p ( face reverse - p & optional locale tag - set how - to - add ) \" Change whether FACE is reversed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "54.771057"}
{"text": "( face - property - instance face ' reverse domain default no - fallback ) ) ( defun set - face - reverse - p ( face reverse - p & optional locale tag - set how - to - add ) \" Change whether FACE is reversed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "54.771057"}
{"text": "First , some symbol spaces , called primitive data types , have a value space , denoted VS symsp , and a mapping from the lexical space to the VS symsp , denoted L symsp , where symsp is an identifier for the symbol space .", "label": "", "metadata": {}, "score": "54.82232"}
{"text": "First , some symbol spaces , called primitive data types , have a value space , denoted VS symsp , and a mapping from the lexical space to the VS symsp , denoted L symsp , where symsp is an identifier for the symbol space .", "label": "", "metadata": {}, "score": "54.82232"}
{"text": "This problem can be solved by adding the so - called \" frame axioms \" , which explicitly specify that all conditions not affected by actions are not changed while executing that action .For example , since the action executed at time 0 is that of opening the door , a frame axiom would state that the status of the light does not change from time 0 to time 1 : .", "label": "", "metadata": {}, "score": "54.90311"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' font locale tag - set exact - p ) ) ( defun face - font - instance ( face & optional domain charset ) \" Return the instance of FACE 's font in DOMAIN .", "label": "", "metadata": {}, "score": "55.020226"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' font locale tag - set exact - p ) ) ( defun face - font - instance ( face & optional domain charset ) \" Return the instance of FACE 's font in DOMAIN .", "label": "", "metadata": {}, "score": "55.020226"}
{"text": "Also , FSFmacs name .( defvaralias ' initialize - face - resources ' init - face - from - resources ) ( defun face - spec - set ( face spec & optional frame ) \" Set FACE 's face attributes according to the first matching entry in SPEC .", "label": "", "metadata": {}, "score": "55.065636"}
{"text": "Also , FSFmacs name .( defvaralias ' initialize - face - resources ' init - face - from - resources ) ( defun face - spec - set ( face spec & optional frame ) \" Set FACE 's face attributes according to the first matching entry in SPEC .", "label": "", "metadata": {}, "score": "55.065636"}
{"text": "( This function behaves like the standard Object.seal function , except that the object to be sealed is implicit and in a different compartment from the caller . )Prevent properties from being added to or deleted from the referent , and mark each property as non - writable .", "label": "", "metadata": {}, "score": "55.08871"}
{"text": "Object instance is replaced .If handler is null , the referent is no longer watched .Handler may have the following methods , called under the given circumstances : .A property named name has been added to the referent .", "label": "", "metadata": {}, "score": "55.094803"}
{"text": "Return the debuggee value that represents value in the debuggee .If value is a primitive , we return it unchanged ; if value is an object , we return the Debugger .Object instance representing that object , wrapped appropriately for use in this Debugger .", "label": "", "metadata": {}, "score": "55.17627"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( face - property - instance face ' display - table domain default no - fallback ) ) ( defun set - face - display - table ( face display - table & optional locale tag - set how - to - add ) \" Change the display table of FACE to DISPLAY - TABLE in LOCALE .", "label": "", "metadata": {}, "score": "55.19614"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( face - property - instance face ' display - table domain default no - fallback ) ) ( defun set - face - display - table ( face display - table & optional locale tag - set how - to - add ) \" Change the display table of FACE to DISPLAY - TABLE in LOCALE .", "label": "", "metadata": {}, "score": "55.19614"}
{"text": "van Brakel , J. ( 1992 )The Complete Description of the Frame Problem .PSYCOLOQUY 3(60 ) frame - problem.2 . van Brakel , J. ( 1993 ) Unjustified Coherence .PSYCOLOQUY 4(23 ) frame - problem.7 .PSYCOLOQUY ( ISSN 1055 - 0143 ) is sponsored by the American Psychological Association ( APA ) .", "label": "", "metadata": {}, "score": "55.23429"}
{"text": "But if the robot 's task is to clean the cupboard , a more relevant consequence is the exposure of the surface the cup was resting on .An AI researcher in the classical mould could rise to this challenge by attempting to specify what propositions are relevant to what context .", "label": "", "metadata": {}, "score": "55.25917"}
{"text": "Harnad , S. ( 1990 )The Symbol Grounding Problem .Physica D 42 : 335 - 346 .Harnad , S. ( 1992 )Connecting Object to Symbol in Modeling Cognition .In : A. Clarke and R. Lutz ( Eds ) Connectionism in Context Springer Verlag .", "label": "", "metadata": {}, "score": "55.307423"}
{"text": "Despite this , many philosophers of mind , in the company of Fodor and Pylyshyn , still subscribe to the view that human mental processes consist chiefly of inferences over a set of propositions , and that those inferences are carried out by some form of computation .", "label": "", "metadata": {}, "score": "55.314533"}
{"text": "If any onStep handler forces the frame to return early ( by returning a resumption value other than undefined ) , any remaining debuggers ' onStep handlers do not run .This property must be either undefined or a function .On newly created frames , this property 's value is undefined .", "label": "", "metadata": {}, "score": "55.456306"}
{"text": "eat ._ _ _ , _ _ _ NP .Subcategorization frames are used as follows .At the point of lexical insertion , a verb 's subcategorization frame is checked against the syntactic environment that the verb is being inserted into .", "label": "", "metadata": {}, "score": "55.5065"}
{"text": "Reiter , R. ( 2001 ) , Knowledge in Action : Logical Foundations for Specifying and Implementing Dynamical Systems , MIT Press .Russell , S. & Wefald , E. ( 1991 ) , Do the Right Thing : Studies in Limited Rationality , MIT Press .", "label": "", "metadata": {}, "score": "55.520638"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( font - width ( face - font face ) domain charset ) ) ( defun face - height ( face & optional domain charset ) \" Return the height of FACE in DOMAIN .", "label": "", "metadata": {}, "score": "55.708473"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( font - width ( face - font face ) domain charset ) ) ( defun face - height ( face & optional domain charset ) \" Return the height of FACE in DOMAIN .", "label": "", "metadata": {}, "score": "55.708473"}
{"text": "For RIF - BLD , TV includes only two values , t ( true ) and f ( false ) .( See end note on truth values . )( See end note on ordering truth values . )Semantic structures .", "label": "", "metadata": {}, "score": "55.71183"}
{"text": "For RIF - BLD , TV includes only two values , t ( true ) and f ( false ) .( See end note on truth values . )( See end note on ordering truth values . )Semantic structures .", "label": "", "metadata": {}, "score": "55.71183"}
{"text": "This property is only used on window system devices .FACE may be either a face object or a symbol representing a face .PIXMAP should be an instantiator ( see ' image - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or an image specifier object .", "label": "", "metadata": {}, "score": "55.735394"}
{"text": "This property is only used on window system devices .FACE may be either a face object or a symbol representing a face .PIXMAP should be an instantiator ( see ' image - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or an image specifier object .", "label": "", "metadata": {}, "score": "55.735394"}
{"text": "Return value immediately as the current value of the function .Value must be a debuggee value .( Most handler functions support this , except those whose descriptions say otherwise . )Yield value immediately as the next value of the current frame , which must be a generator frame .", "label": "", "metadata": {}, "score": "55.77186"}
{"text": "Semantics of undefined symbol spaces .Section Symbol Spaces addressed the syntactic aspects of the treatment of \" unknown \" symbol spaces , i.e. , symbol spaces that are not defined by the RIF specification .It defined the lexical space of those symbols as the set of all Unicode strings .", "label": "", "metadata": {}, "score": "55.80727"}
{"text": "Semantics of undefined symbol spaces .Section Symbol Spaces addressed the syntactic aspects of the treatment of \" unknown \" symbol spaces , i.e. , symbol spaces that are not defined by the RIF specification .It defined the lexical space of those symbols as the set of all Unicode strings .", "label": "", "metadata": {}, "score": "55.80727"}
{"text": "FACE may be either a face object or a symbol representing a face .FONT should be an instantiator ( see ' font - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a font specifier object .", "label": "", "metadata": {}, "score": "55.972954"}
{"text": "FACE may be either a face object or a symbol representing a face .FONT should be an instantiator ( see ' font - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a font specifier object .", "label": "", "metadata": {}, "score": "55.972954"}
{"text": "The frame problem can be thought of as the problem of formalizing the principle that , by default , \" everything is presumed to remain in the state in which it is \" ( Leibniz , \" An Introduction to a Secret Encyclop\u00e6dia \" , c .", "label": "", "metadata": {}, "score": "55.995224"}
{"text": "But it was taken up in an embellished and modified form by philosophers of mind , and given a wider interpretation .The tension between its origin in the laboratories of AI researchers and its treatment at the hands of philosophers engendered an interesting and sometimes heated debate in the 1980s and 1990s .", "label": "", "metadata": {}, "score": "56.007607"}
{"text": "If LOCALE is a particular locale , what happens depends on what sort of locale is given .If you gave a device , frame , or window , then it 's always possible to determine what the font actually will be , so this is determined and the resulting font is frobbed and added back as a specification for this locale .", "label": "", "metadata": {}, "score": "56.030266"}
{"text": "If LOCALE is a particular locale , what happens depends on what sort of locale is given .If you gave a device , frame , or window , then it 's always possible to determine what the font actually will be , so this is determined and the resulting font is frobbed and added back as a specification for this locale .", "label": "", "metadata": {}, "score": "56.030266"}
{"text": "The location of the tea - pot is unaffected .But if it so happens that a spoon was resting in the cup , then the spoon 's new location , inherited from its container , must also be updated .The epistemological difficulty now discerned by philosophers is this .", "label": "", "metadata": {}, "score": "56.08178"}
{"text": "Note also that , since CONDITION permits disjunction and existential quantification , the rules defined by the Implies production are more general than pure Horn rules .This extension was explained in the introduction to Section Positive Conditions .Well - formed rules .", "label": "", "metadata": {}, "score": "56.10091"}
{"text": "Note also that , since CONDITION permits disjunction and existential quantification , the rules defined by the Implies production are more general than pure Horn rules .This extension was explained in the introduction to Section Positive Conditions .Well - formed rules .", "label": "", "metadata": {}, "score": "56.10091"}
{"text": "However , the philosophical problem is not exhausted by this computational issue .The outstanding philosophical question is how the robot could ever determine that it had successfully revised all its beliefs to match the consequences of its actions .Only then would it be in a position safely to apply the \" common sense law of inertia \" and assume the rest of the world is untouched .", "label": "", "metadata": {}, "score": "56.152756"}
{"text": "When one of the events described below occurs in debuggee code , the engine pauses the debuggee and calls the corresponding debugging handler on each Debugger instance that is observing the debuggee .The handler functions receive the Debugger instance as their this value .", "label": "", "metadata": {}, "score": "56.175385"}
{"text": "McCarthy , J ( 1963 )Situations , Actions and Causal Laws .Stanford Artificial Intelligence Project , Memo 2 .McCarthy , J and Hayes , P ( 1969 )Some philosophical problems from the standpoint of Artificial Intelligence .In B. Meltzer & D. Michie ( eds ) Machine Intelligence 4 .", "label": "", "metadata": {}, "score": "56.3018"}
{"text": "We call those stack frames a Debugger does reveal visible frames .If the non - debuggee function eventually calls back into debuggee code , then those frames are visible .( Note that the debuggee is not considered an \" immediate caller \" of handler methods it triggers .", "label": "", "metadata": {}, "score": "56.31649"}
{"text": "When the referent frame is popped , the argument value 's properties ' getters throw an error .Calls to frames ' handler methods are cross - compartment , intra - thread calls : the call takes place in the thread to which the frame belongs , and runs in the compartment to which the handler method belongs .", "label": "", "metadata": {}, "score": "56.328796"}
{"text": "Otherwise , the face will be resourced over all possible locales ( i.e. all frames , all devices , and ' global ) . \"( cond ( ( null init - face - from - resources ) ; ; Do nothing . )", "label": "", "metadata": {}, "score": "56.345253"}
{"text": "Otherwise , the face will be resourced over all possible locales ( i.e. all frames , all devices , and ' global ) . \"( cond ( ( null init - face - from - resources ) ; ; Do nothing . )", "label": "", "metadata": {}, "score": "56.345253"}
{"text": "REFERENCES .Fetzer , J. H. ( 1993a )Van Brakel 's Position Appears to be Incoherent .PSYCOLOQUY 4(14 ) frame - problem.4 .Fetzer , J. H. ( 1993b ) Philosophy Unframed .PSYCOLOQUY 4(33 ) frame - problem.10 .", "label": "", "metadata": {}, "score": "56.38846"}
{"text": "Quantification : I Truth ( Exists ?v 1 ... ?v 1 , ... , ?v n .Notice that the mapping I Truth is uniquely determined by the four mappings comprising I and , therefore , it does not need to be listed explicitly .", "label": "", "metadata": {}, "score": "56.44502"}
{"text": "( 33a ) contains only one instance of V ' to serve as target of adjunction .In ( 33c ) , on the other hand , there are two V ' nodes , and the question immediately arises whether either of them can serve as target of adjunction for a second adjunct .", "label": "", "metadata": {}, "score": "56.47178"}
{"text": "A non - live Debugger .Frame instance no longer holds a strong reference to the generator - iterator object .A Debugger .Script instance refers to a sequence of bytecode in the debuggee ; it is the JavaScript - level presentation of a JSAPI JSScript object .", "label": "", "metadata": {}, "score": "56.532753"}
{"text": "( font - ascent ( face - font face ) domain charset ) ) ( defun face - descent ( face & optional domain charset ) \" Return the descent of FACE in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "56.55456"}
{"text": "( font - ascent ( face - font face ) domain charset ) ) ( defun face - descent ( face & optional domain charset ) \" Return the descent of FACE in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "56.55456"}
{"text": "( face - property - instance face ' blinking domain default no - fallback ) ) ( defun set - face - blinking - p ( face blinking - p & optional locale tag - set how - to - add ) \" Change whether FACE is blinking in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "56.57652"}
{"text": "( face - property - instance face ' blinking domain default no - fallback ) ) ( defun set - face - blinking - p ( face blinking - p & optional locale tag - set how - to - add ) \" Change whether FACE is blinking in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "56.57652"}
{"text": "Arguments must either be an array ( in the debugger ) of debuggee values , or null or undefined , which are treated as an empty array .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .", "label": "", "metadata": {}, "score": "56.675457"}
{"text": "According to Fodor , this metaphysical justification is unwarranted .To begin with , some actions change many , many things .Those who affirm that painting an object has little or no effect on most properties of most of the objects in the room are likely to concede that detonating a bomb actually does affect most of those properties .", "label": "", "metadata": {}, "score": "56.768257"}
{"text": "For the modifier of a head , the target of adjunction is that head 's intermediate projection , as indicated by the box in ( 33a ) .The first step in adjunction is to make a copy of the target of adjunction right above the original node , as in ( 33b ) .", "label": "", "metadata": {}, "score": "56.798355"}
{"text": "For example , in due course we might want to add a formula that captures the exception to Axiom 3 that arises when we move an object into a pot of paint .But our not having thought of this exception before should not prevent us from applying the common sense law of inertia and drawing a wide enough set of ( defeasible ) conclusions to get off the ground .", "label": "", "metadata": {}, "score": "56.82823"}
{"text": "Object.prototype.getOwnPropertyDescriptor .Name must be a string whose value is a valid ECMAScript identifier name .If this is an \" object \" or \" with \" environment record , this simply returns the descriptor for the given property of the environment 's object .", "label": "", "metadata": {}, "score": "56.874947"}
{"text": "However , the appeal to relevance is unhelpful .For the difficulty now is to determine what is and what is n't relevant , and this is dependent on context .Consider again the action of removing a tea - cup from the cupboard .", "label": "", "metadata": {}, "score": "56.909958"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "( face - property - instance face ' highlight domain default no - fallback ) ) ( defun set - face - highlight - p ( face highlight - p & optional locale tag - set how - to - add ) \" Change whether FACE is highlighted in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "57.049458"}
{"text": "( face - property - instance face ' highlight domain default no - fallback ) ) ( defun set - face - highlight - p ( face highlight - p & optional locale tag - set how - to - add ) \" Change whether FACE is highlighted in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "57.049458"}
{"text": "The induction and representation of categories .In : Harnad , S. ( ed . )Categorical Perception : The Groundwork of Cognition .New York : Cambridge University Press .Harnad , S. ( 1990 )The Symbol Grounding Problem .", "label": "", "metadata": {}, "score": "57.10259"}
{"text": "The RIF Condition Language is intended to be used in the bodies of the rules in RIF Basic Logic Dialect ( RIF - BLD ) .The condition language is then extended to Horn rules and this document specifies a presentation syntax and a corresponding concrete XML syntax for RIF - BLD .", "label": "", "metadata": {}, "score": "57.14187"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" blinking - p \" \" blinking \" ) ) ( set - face - property face ' blinking blinking - p locale tag - set how - to - add ) ) ( defun face - reverse - p ( face & optional domain default no - fallback ) \" Return t if FACE is reversed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "57.144455"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" blinking - p \" \" blinking \" ) ) ( set - face - property face ' blinking blinking - p locale tag - set how - to - add ) ) ( defun face - reverse - p ( face & optional domain default no - fallback ) \" Return t if FACE is reversed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "57.144455"}
{"text": "For the primitive data types that are currently supported by RIF , their value spaces and the lexical - to - value - space mappings are defined as follows : .For XML data types ( xsd : long , xsd : integer , xsd : decimal , xsd : string , xsd : time , and xsd : dateTime ) , these are defined in the XML Schema Part 2 : Datatypes specification .", "label": "", "metadata": {}, "score": "57.24756"}
{"text": "rif : local ( for constant symbols that are not visible outside of a particular set of RIF formulas ) .Symbols in this symbol space are used locally in their respective rule sets .This means that occurrences of the same rif : local -constant in different rule sets are viewed as unrelated distinct constants , but occurrences of the same constant in the same rule set must refer to the same object .", "label": "", "metadata": {}, "score": "57.25656"}
{"text": "rif : local ( for constant symbols that are not visible outside of a particular set of RIF formulas ) .Symbols in this symbol space are used locally in their respective rule sets .This means that occurrences of the same rif : local -constant in different rule sets are viewed as unrelated distinct constants , but occurrences of the same constant in the same rule set must refer to the same object .", "label": "", "metadata": {}, "score": "57.25656"}
{"text": "See ' face - property ' for more information . \"( face - property face ' background locale tag - set exact - p ) ) ( defun face - background - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background in DOMAIN .", "label": "", "metadata": {}, "score": "57.2845"}
{"text": "See ' face - property ' for more information . \"( face - property face ' background locale tag - set exact - p ) ) ( defun face - background - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background in DOMAIN .", "label": "", "metadata": {}, "score": "57.2845"}
{"text": "Harnad , S. ( 1992 )Connecting Object to Symbol in Modeling Cognition .In : A. Clarke and R. Lutz ( Eds ) Connectionism in Context Springer Verlag .Harnad , S. , Hanson , S.J. & Lubin , J. ( 1991 )", "label": "", "metadata": {}, "score": "57.31051"}
{"text": "( 2000 ) , The Mind Does n't Work That Way , MIT Press . -( 2008 ) , LOT 2 : The Language of Thought Revisited , Oxford University Press .Ford , K.M. & Hayes , P.J. ( eds . )", "label": "", "metadata": {}, "score": "57.3133"}
{"text": "The referent 's properties do not appear directly as properties of the Debugger .Object instance ; the debugger can access them only through methods like Debugger .Object.prototype.getOwnPropertyDescriptor and Debugger .Object.prototype.defineProperty , ensuring that the debugger will not inadvertently invoke the referent 's getters and setters .", "label": "", "metadata": {}, "score": "57.33931"}
{"text": "Article . the .In contrast to nonterminals , terminal symbols can not appear on the lefthand side of a phrase structure rule .This is what gives them their name ; since they can not be rewritten , they terminate the particular bit of the derivation in which they appear .", "label": "", "metadata": {}, "score": "57.356575"}
{"text": "If there is no older frame , this is null .True if the frame this Debugger .Frame instance refers to is still on the stack ( or , in the case of generator - iterator objects , has not yet finished its iteration ) ; false if it has completed execution or been popped in some other way .", "label": "", "metadata": {}, "score": "57.408363"}
{"text": "Frame instance referring to a generator - iterator frame has a strong reference to the generator - iterator object ; the frame ( and its object ) will live as long as the Debugger .Frame instance does .However , when the generator function returns , throws an exception , or is terminated , thus ending the iteration , the Debugger .", "label": "", "metadata": {}, "score": "57.678642"}
{"text": "Notice that the slots in the elementary trees other than the lexical item anchoring it are empty .For instance , a verb like devour requires an object , but not a particular one ; many different phrases will fill the bill , as long as they are noun phrases .", "label": "", "metadata": {}, "score": "57.751183"}
{"text": "In the next version of this document we intend to introduce a syntax for defining prefixes for compact URIs .TODO : Define CURIs .The set of all constant symbols in RIF has a number of predefined subsets , called symbol spaces , which are used to represent XML data types , data types defined in other W3C specifications , such as rdf : XMLLiteral , and to distinguish other sets of constants .", "label": "", "metadata": {}, "score": "57.789074"}
{"text": "doc - string Description of what the face 's normal use is .NOTE :This is not a specifier , unlike all the other built - in properties , and can not contain locale - specific values . \"( setq face ( get - face face ) ) ( if ( memq property built - in - face - specifiers ) ( set - specifier ( get face property ) value locale tag - set how - to - add ) ; ; This section adds user defined properties .", "label": "", "metadata": {}, "score": "57.809677"}
{"text": "doc - string Description of what the face 's normal use is .NOTE :This is not a specifier , unlike all the other built - in properties , and can not contain locale - specific values . \"( setq face ( get - face face ) ) ( if ( memq property built - in - face - specifiers ) ( set - specifier ( get face property ) value locale tag - set how - to - add ) ; ; This section adds user defined properties .", "label": "", "metadata": {}, "score": "57.809677"}
{"text": "Remove all breakpoints set in this script .If offset is present , remove all breakpoints set at that offset in this script ; if offset is not a valid bytecode offset in this script , throw an error .A Debugger .", "label": "", "metadata": {}, "score": "57.83183"}
{"text": "If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .Object instance for a given object .This allows the code using each Debugger instance to place whatever properties it likes on its own Debugger .", "label": "", "metadata": {}, "score": "57.87433"}
{"text": "If this value is not an object , it may be different from the value produced by the new expression , which will be the value of the frame 's this property .( In ECMAScript terms , the onPop handler receives the value returned by the [ [ Call ] ] method , not the value returned by the [ [ Construct ] ] method . )", "label": "", "metadata": {}, "score": "57.910675"}
{"text": "See ' face - property ' for more information . \"( face - property face ' foreground locale tag - set exact - p ) ) ( defun face - foreground - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's foreground in DOMAIN .", "label": "", "metadata": {}, "score": "57.98977"}
{"text": "See ' face - property ' for more information . \"( face - property face ' foreground locale tag - set exact - p ) ) ( defun face - foreground - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's foreground in DOMAIN .", "label": "", "metadata": {}, "score": "57.98977"}
{"text": "PSYCOLOQUY 3(59 ) frame - problem.1 .Hayes , P.J. and Ford , K.M. ( 1993 ) Effective Descriptions Need Not Be Complete .PSYCOLOQUY 4(21 ) frame - problem.5 .McCarthy , J ( 1963 )Situations , Actions and Causal Laws .", "label": "", "metadata": {}, "score": "58.27491"}
{"text": "Object instance referring to the copy .Note that this returns primitive values unchanged .This means you can use Debugger .Object.prototype.copy as a generic \" debugger value to debuggee value \" conversion function \u2014 within the limitations of the \" structured cloning \" algorithm .", "label": "", "metadata": {}, "score": "58.280346"}
{"text": "We also define the following mapping , I , based on the mappings I C , I V , and I F : .I ( ?v ) , if ?v is a variable in Var .Semantics of symbol spaces .", "label": "", "metadata": {}, "score": "58.2954"}
{"text": "We also define the following mapping , I , based on the mappings I C , I V , and I F : .I ( ?v ) , if ?v is a variable in Var .Semantics of symbol spaces .", "label": "", "metadata": {}, "score": "58.2954"}
{"text": "( setq face ( get - face face ) ) ( let ( ( specifier ( get face property ) ) ) ; ; if a user - property does not have a specifier but a ; ; locale was specified , put a specifier there . ; ; If there was already a value there , convert it to a ; ; specifier with the value as its ' global instantiator .", "label": "", "metadata": {}, "score": "58.31868"}
{"text": "( setq face ( get - face face ) ) ( let ( ( specifier ( get face property ) ) ) ; ; if a user - property does not have a specifier but a ; ; locale was specified , put a specifier there . ; ; If there was already a value there , convert it to a ; ; specifier with the value as its ' global instantiator .", "label": "", "metadata": {}, "score": "58.31868"}
{"text": "; ; ; Code : ( defgroup faces nil \" Support for multiple text attributes ( fonts , colors , ... )Such a collection of attributes is called a \\\"face\\ \" . \"( funcall fn face ) ) ) ( value ( if bool ( y - or - n - p ( format \" Should face % s be % s ? \"", "label": "", "metadata": {}, "score": "58.378864"}
{"text": "; ; ; Code : ( defgroup faces nil \" Support for multiple text attributes ( fonts , colors , ... )Such a collection of attributes is called a \\\"face\\ \" . \"( funcall fn face ) ) ) ( value ( if bool ( y - or - n - p ( format \" Should face % s be % s ? \"", "label": "", "metadata": {}, "score": "58.378864"}
{"text": "See ' remove - specifier ' for the meaning of the LOCALE , TAG - SET , and EXACT - P arguments .\" This makes FACE inherit all its display properties from ' default .WARNING : Be absolutely sure you want to do this ! ! !", "label": "", "metadata": {}, "score": "58.431236"}
{"text": "See ' remove - specifier ' for the meaning of the LOCALE , TAG - SET , and EXACT - P arguments .\" This makes FACE inherit all its display properties from ' default .WARNING : Be absolutely sure you want to do this ! ! !", "label": "", "metadata": {}, "score": "58.431236"}
{"text": "See ' face - property ' for more information . \"( face - property face ' display - table locale tag - set exact - p ) ) ( defun face - display - table - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's display table in DOMAIN .", "label": "", "metadata": {}, "score": "58.478046"}
{"text": "See ' face - property ' for more information . \"( face - property face ' display - table locale tag - set exact - p ) ) ( defun face - display - table - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's display table in DOMAIN .", "label": "", "metadata": {}, "score": "58.478046"}
{"text": "( face - property - instance face ' dim domain default no - fallback ) ) ( defun set - face - dim - p ( face dim - p & optional locale tag - set how - to - add ) \" Change whether FACE is dimmed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "58.49881"}
{"text": "( face - property - instance face ' dim domain default no - fallback ) ) ( defun set - face - dim - p ( face dim - p & optional locale tag - set how - to - add ) \" Change whether FACE is dimmed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "58.49881"}
{"text": "Whether such scripts appear can be affected by the garbage collector 's behavior , so this function 's behavior is not entirely deterministic .Remove all breakpoints set in this Debugger instance that use handler as their handler .Note that , if breakpoints using other handler objects are set at the same location(s ) as handler , they remain in place .", "label": "", "metadata": {}, "score": "58.521286"}
{"text": "For every primitive datatype symsp it must hold that : .That is , when restricted to a symbol space , symsp , I C must map the corresponding constants according to L symsp .RIF - BLD does not impose restrictions on the interpretation of constants ( the mapping I C ) in symbol spaces which are not primitive datatypes .", "label": "", "metadata": {}, "score": "58.5422"}
{"text": "For every primitive datatype symsp it must hold that : .That is , when restricted to a symbol space , symsp , I C must map the corresponding constants according to L symsp .RIF - BLD does not impose restrictions on the interpretation of constants ( the mapping I C ) in symbol spaces which are not primitive datatypes .", "label": "", "metadata": {}, "score": "58.5422"}
{"text": "If it is nil , then apply SPEC to each frame individually .See ' defface ' for information about SPEC . \" Iff optional FRAME is non - nil , set it for that frame only .See ' defface ' for information about SPEC . \"", "label": "", "metadata": {}, "score": "58.550064"}
{"text": "If it is nil , then apply SPEC to each frame individually .See ' defface ' for information about SPEC . \" Iff optional FRAME is non - nil , set it for that frame only .See ' defface ' for information about SPEC . \"", "label": "", "metadata": {}, "score": "58.550064"}
{"text": "( cond ( ( eq ' x ( frame - type frame ) ) ( x - init - frame - faces frame ) ) ( ( eq ' mswindows ( frame - type frame ) ) ( mswindows - init - frame - faces frame ) ) ; ; Is there anything which should be done for TTY 's ? ) ) ) ; ; # # # # This is somewhat X - specific , and is called when the first ; ; X device is created ( even if there were TTY devices created ; ; beforehand ) .", "label": "", "metadata": {}, "score": "58.5802"}
{"text": "( cond ( ( eq ' x ( frame - type frame ) ) ( x - init - frame - faces frame ) ) ( ( eq ' mswindows ( frame - type frame ) ) ( mswindows - init - frame - faces frame ) ) ; ; Is there anything which should be done for TTY 's ? ) ) ) ; ; # # # # This is somewhat X - specific , and is called when the first ; ; X device is created ( even if there were TTY devices created ; ; beforehand ) .", "label": "", "metadata": {}, "score": "58.5802"}
{"text": "If s is a constant or variable symbol with signature \u03b7 then s is a well - formed term with signature \u03b7 .A term t ( t 1 ... t n ) is a well - formed atomic formula iff it is a well - formed term with the signature atomic .", "label": "", "metadata": {}, "score": "58.66532"}
{"text": "If s is a constant or variable symbol with signature \u03b7 then s is a well - formed term with signature \u03b7 .A term t ( t 1 ... t n ) is a well - formed atomic formula iff it is a well - formed term with the signature atomic .", "label": "", "metadata": {}, "score": "58.66532"}
{"text": "The statement ATOMIC : - CONDITION should be informally read as if CONDITION is true then ATOMIC is also true .Rules are generated by the Implies production .Facts are generated by the ATOMIC production , and can be viewed as the then part of an Implies with an empty conjunctive if ( or with true as the if part ) .", "label": "", "metadata": {}, "score": "58.727257"}
{"text": "The statement ATOMIC : - CONDITION should be informally read as if CONDITION is true then ATOMIC is also true .Rules are generated by the Implies production .Facts are generated by the ATOMIC production , and can be viewed as the then part of an Implies with an empty conjunctive if ( or with true as the if part ) .", "label": "", "metadata": {}, "score": "58.727257"}
{"text": "A generator frame disappears from the stack each time the generator yields a value and is suspended , and reappears atop the stack when it is resumed to produce the generator 's next value .The same Debugger .Frame instance refers to the generator frame until it returns , throws an exception , or is terminated .", "label": "", "metadata": {}, "score": "58.80813"}
{"text": "Let the rewrite arrow correspond to a domination relation between the symbols from the lefthand and righthand sides of the rule .This relation is conventionally represented by downward - pointing branches connecting the dominating node ( the mother or parent ) and the dominated nodes ( the daughters or children ) .", "label": "", "metadata": {}, "score": "58.80903"}
{"text": "The symbols f n p n , and bi n are reserved signature names in RIF - BLD .It can not have the signature atomic or bi_atomic ( only terms can have such signatures , not symbols ) .The constant symbols that correspond to XML Schema data types all have the signature term in RIF - BLD .", "label": "", "metadata": {}, "score": "58.810616"}
{"text": "The symbols f n p n , and bi n are reserved signature names in RIF - BLD .It can not have the signature atomic or bi_atomic ( only terms can have such signatures , not symbols ) .The constant symbols that correspond to XML Schema data types all have the signature term in RIF - BLD .", "label": "", "metadata": {}, "score": "58.810616"}
{"text": "If this environment represents the variable environment ( the top - level environment within the function , which receives var definitions ) for a call to a function f , then this property 's value is a Debugger .Object instance referring to f. Otherwise , this property 's value is null .", "label": "", "metadata": {}, "score": "58.912716"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" highlight - p \" \" highlighted \" ) ) ( set - face - property face ' highlight highlight - p locale tag - set how - to - add ) ) ( defun face - dim - p ( face & optional domain default no - fallback ) \" Return t if FACE is dimmed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "58.913357"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" highlight - p \" \" highlighted \" ) ) ( set - face - property face ' highlight highlight - p locale tag - set how - to - add ) ) ( defun face - dim - p ( face & optional domain default no - fallback ) \" Return t if FACE is dimmed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "58.913357"}
{"text": "If the finally block finishes normally , the exception resumes propagation , and the debugger 's onExceptionUnwind handler is called again , in the same frame .( The other possibility is for the finally block to exit due to a return , continue , or break statement , or a new exception .", "label": "", "metadata": {}, "score": "58.919685"}
{"text": "Each symbol in Const belongs to a symbol space .Each symbol space has an associated lexical space and a number of identifiers .The lexical space of a symbol space is a non - empty set of Unicode character strings .", "label": "", "metadata": {}, "score": "58.92429"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" underline - p \" \" underlined \" ) ) ( set - face - property face ' underline underline - p locale tag - set how - to - add ) ) ( defun face - strikethru - p ( face & optional domain default no - fallback ) \" Return t if FACE is strikethru - d ( i.e. struck through ) in DOMAIN .", "label": "", "metadata": {}, "score": "59.024555"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" underline - p \" \" underlined \" ) ) ( set - face - property face ' underline underline - p locale tag - set how - to - add ) ) ( defun face - strikethru - p ( face & optional domain default no - fallback ) \" Return t if FACE is strikethru - d ( i.e. struck through ) in DOMAIN .", "label": "", "metadata": {}, "score": "59.024555"}
{"text": "Environment instance represents a lexical environment , associating names with variables .Each Debugger .Frame instance representing a debuggee frame has an associated environment object describing the variables in scope in that frame ; and each Debugger .Object instance representing a debuggee function has an environment object representing the environment the function has closed over .", "label": "", "metadata": {}, "score": "59.139"}
{"text": "Dreyfus does n't explain how , given the holistic , open - ended , context - sensitive character of relevance , this figuring - out is achieved .Baars , B. ( 1988 ) , A Cognitive Theory of Consciousness , Cambridge University Press .", "label": "", "metadata": {}, "score": "59.146885"}
{"text": "If the referent is not a function that is debuggee code , return undefined .Each argument must be a debuggee value .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .Details of how the call is carried out are given in the description of [ [ # Debugger .", "label": "", "metadata": {}, "score": "59.173454"}
{"text": "Lexical insertion rules .In order to generate phrases and sentences consisting of actual words , there must also be rules available whose righthand side contains terminal symbols , like those in ( 7 ) .devour .d. .V . waited .", "label": "", "metadata": {}, "score": "59.373573"}
{"text": "DISPLAY is part of a spec such as can be used in ' defface ' .If FRAME is nil or omitted , the selected frame is used .\" If FRAME is nil or omitted , initialize them for all frames .", "label": "", "metadata": {}, "score": "59.556564"}
{"text": "DISPLAY is part of a spec such as can be used in ' defface ' .If FRAME is nil or omitted , the selected frame is used .\" If FRAME is nil or omitted , initialize them for all frames .", "label": "", "metadata": {}, "score": "59.556564"}
{"text": "A script for code passed to direct eval is at a static level one greater than that of the script containing the call to eval , because direct eval code runs within the caller 's scope .However , a script for code passed to an indirect eval call is at static level zero , since it is evaluated in the global scope . should be set in g 's script , not in f 's , even though neither script contains code at that line .", "label": "", "metadata": {}, "score": "59.573906"}
{"text": "Positional information is optionally exploited only for the arg role elements .For example , role elements ( declare and formula ) are explicit within the Exists element .Following the examples of Java and RDF , we use capitalized names for class elements and names that start with lowercase for role elements .", "label": "", "metadata": {}, "score": "59.708332"}
{"text": "Positional information is optionally exploited only for the arg role elements .For example , role elements ( declare and formula ) are explicit within the Exists element .Following the examples of Java and RDF , we use capitalized names for class elements and names that start with lowercase for role elements .", "label": "", "metadata": {}, "score": "59.708332"}
{"text": "Thus , classes are also objects and they can be members of some other classes .( In object - oriented languages these latter classes are sometimes known as meta - classes . )Subclass formula : s # # c , where s , c are well - formed terms .", "label": "", "metadata": {}, "score": "59.736084"}
{"text": "Thus , classes are also objects and they can be members of some other classes .( In object - oriented languages these latter classes are sometimes known as meta - classes . )Subclass formula : s # # c , where s , c are well - formed terms .", "label": "", "metadata": {}, "score": "59.736084"}
{"text": "Their value spaces and the lexical - to - value space mappings are defined as follows : .For XML Schema data types ( xsd : long , xsd : integer , xsd : decimal , xsd : string , xsd : time , and xsd : dateTime ) , these are defined in the XML Schema Part 2 : Datatypes specification .", "label": "", "metadata": {}, "score": "59.845463"}
{"text": "No Endorsement .Publication as a Working Draft does not imply endorsement by the W3C Membership .This is a draft document and may be updated , replaced or obsoleted by other documents at any time .It is inappropriate to cite this document as other than work in progress .", "label": "", "metadata": {}, "score": "59.88946"}
{"text": "( Note that with statements have their own environment type . )A Debugger .Object instance referring to the object whose properties this environment reflects .If this is a declarative environment record , this accessor throws a TypeError ( since declarative environment records have no such object ) .", "label": "", "metadata": {}, "score": "59.9404"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" dim - p \" \" dimmed \" ) ) ( set - face - property face ' dim dim - p locale tag - set how - to - add ) ) ( defun face - blinking - p ( face & optional domain default no - fallback ) \" Return t if FACE is blinking in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "60.03138"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" dim - p \" \" dimmed \" ) ) ( set - face - property face ' dim dim - p locale tag - set how - to - add ) ) ( defun face - blinking - p ( face & optional domain default no - fallback ) \" Return t if FACE is blinking in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "60.03138"}
{"text": "For further details on defining the semantics for RIF dialects see end note on intended models for rule sets .We will now define what it means for a set of rules to entail a RIF condition .Let S be a RIF ruleset and \u03c6 a closed RIF condition ( a condition with no occurrences of free variables ) .", "label": "", "metadata": {}, "score": "60.055836"}
{"text": "For further details on defining the semantics for RIF dialects see end note on intended models for rule sets .We will now define what it means for a set of rules to entail a RIF condition .Let S be a RIF ruleset and \u03c6 a closed RIF condition ( a condition with no occurrences of free variables ) .", "label": "", "metadata": {}, "score": "60.055836"}
{"text": "Some debugger operations that appear to simply inspect the debuggee 's state may actually cause debuggee code to run .For example , reading a variable might run a getter function on the global or on a with expression 's operand ; and getting an object 's property descriptor will run a handler trap if the object is a proxy .", "label": "", "metadata": {}, "score": "60.093884"}
{"text": "I sub gives meaning to the subclass relationship .The truth valuation for classification formulas of the form sc # # cl , where sc and cl are terms , is defined as follows : .In addition , we want the operator # # to be transitive , i.e. , we would like c1 # # c2 and c2 # # c3 to imply c1 # # c3 .", "label": "", "metadata": {}, "score": "60.191628"}
{"text": "I sub gives meaning to the subclass relationship .The truth valuation for classification formulas of the form sc # # cl , where sc and cl are terms , is defined as follows : .In addition , we want the operator # # to be transitive , i.e. , we would like c1 # # c2 and c2 # # c3 to imply c1 # # c3 .", "label": "", "metadata": {}, "score": "60.191628"}
{"text": "This function is ugly and messy and is primarily used as an internal helper function for ' make - face - bold ' et al . , so you probably do n't want to use it or read the rest of the documentation .", "label": "", "metadata": {}, "score": "60.198242"}
{"text": "This function is ugly and messy and is primarily used as an internal helper function for ' make - face - bold ' et al . , so you probably do n't want to use it or read the rest of the documentation .", "label": "", "metadata": {}, "score": "60.198242"}
{"text": "X( book^^rif : local ( ?I ? X ( ?I ? X ( ?X ?X ?I ?X ?S ( ?X ?EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "60.29257"}
{"text": "X( book^^rif : local ( ?I ? X ( ?I ? X ( ?X ?X ?I ?X ?S ( ?X ?EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "60.29257"}
{"text": "( defun face - underline - p ( face & optional domain default no - fallback ) \" Return t if FACE is underlined in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "60.396675"}
{"text": "( defun face - underline - p ( face & optional domain default no - fallback ) \" Return t if FACE is underlined in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "60.396675"}
{"text": "Whereupon the dissenting philosopher might point out that AI 's past successes have always been confined to narrow domains , such as playing chess , or reasoning in limited microworlds where the set of potentially relevant propositions is fixed and known in advance .", "label": "", "metadata": {}, "score": "60.727753"}
{"text": "VP .b. .V NP .( by ( 2a ) ) .c. .V Article N .( by ( 2b ) ) .But although the phrase structure rule for NP in ( 2b ) implies that the article and the noun form a structural unit , nothing in the final result of the rewriting in ( 3c ) reflects this .", "label": "", "metadata": {}, "score": "60.729156"}
{"text": "If it returns undefined , the exception continues to propagate as normal : if control in frame is in a try block , control jumps to the corresponding catch or finally block ; otherwise , frame is popped , and the exception propagates to frame 's caller .", "label": "", "metadata": {}, "score": "60.758636"}
{"text": "( interactive ( face - interactive \" font \" ) ) ( set - face - property face ' font font locale tag - set how - to - add ) ) ( defun face - foreground ( face & optional locale tag - set exact - p ) \" Return the foreground of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "60.77096"}
{"text": "( interactive ( face - interactive \" font \" ) ) ( set - face - property face ' font font locale tag - set how - to - add ) ) ( defun face - foreground ( face & optional locale tag - set exact - p ) \" Return the foreground of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "60.77096"}
{"text": "Ford , K.M. & Pylyshyn , Z.W. ( eds . )( 1996 ) , The Robot 's Dilemma Revisited : The Frame Problem in Artificial Intelligence , Ablex .Freeman , W.J. ( 2000 ) , How Brains Make UpTheir Minds , Phoenix .", "label": "", "metadata": {}, "score": "60.845665"}
{"text": "This will attempt to make the font bold for X locales and will set the highlight flag for TTY locales .If LOCALE is nil , omitted , or ' all ' , this will attempt to frob all font specifications for FACE to make them appear bold .", "label": "", "metadata": {}, "score": "60.86622"}
{"text": "This will attempt to make the font bold for X locales and will set the highlight flag for TTY locales .If LOCALE is nil , omitted , or ' all ' , this will attempt to frob all font specifications for FACE to make them appear bold .", "label": "", "metadata": {}, "score": "60.86622"}
{"text": "the for statement head has two entry points at offsets 5 and 20 ( for the initialization , which is performed only once , and the loop test , which is performed at the start of each iteration ) ; .Return a new array whose elements are Debugger .", "label": "", "metadata": {}, "score": "60.98369"}
{"text": "Heal , J. ( 1996 ) , \" Simulation , Theory , and Content \" , in Theories of Theories of Mind , eds .P.Carruthers & P.Smith , Cambridge University Press , pp .75 - 89 .Lakoff , G. & Johnson , M. ( 1980 ) , Metaphors We Live By , University of Chicago Press .", "label": "", "metadata": {}, "score": "61.06669"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.06852"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.06852"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.06852"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.06852"}
{"text": "Wheeler , M. ( 2005 ) , Reconstructing the Cognitive World : The Next Step , MIT Press . -( 2008 ) , \" Cognition in Context : Phenomenology , Situated Robotics , and the Frame Problem \" , International Journal of Philosophical Studies , 16(3 ) : 323 - 349 .", "label": "", "metadata": {}, "score": "61.114906"}
{"text": "The following extends the XML syntax of Positive Conditions , by serializing the above EBNF Syntax of RIF Horn rules in XML .The Forall element contains the role elements declare and formula , which were earlier used within the Exists element of Positive Conditions .", "label": "", "metadata": {}, "score": "61.17376"}
{"text": "The following extends the XML syntax of Positive Conditions , by serializing the above EBNF Syntax of RIF Horn rules in XML .The Forall element contains the role elements declare and formula , which were earlier used within the Exists element of Positive Conditions .", "label": "", "metadata": {}, "score": "61.17376"}
{"text": "Object instance .( This function behaves like the standard Object.freeze function , except that the object to be sealed is implicit and in a different compartment from the caller . )Prevent properties from being added to the referent .( This function behaves like the standard Object.preventExtensions function , except that the object to operate on is implicit and in a different compartment from the caller . )", "label": "", "metadata": {}, "score": "61.288326"}
{"text": "In the next version of this document we intend to introduce a syntax for defining prefixes for compact URIs .Constant symbols that belong to the various symbol spaces have special presentation syntax and semantics .Formally , a symbol space is a named subset of the set of all constants , Const .", "label": "", "metadata": {}, "score": "61.30967"}
{"text": "Object instance whose referent is the global object .The stack frame frame is about to begin executing code .The exception value is being thrown by frame , which is running debuggee code .If it returns undefined , the exception is thrown as normal .", "label": "", "metadata": {}, "score": "61.339157"}
{"text": "The difficulty can be illustrated without the full apparatus of formal logic , but it should be borne in mind that the devil is in the mathematical details .Suppose we write two formulae , one describing the effects of painting an object and the other describing the effects of moving an object .", "label": "", "metadata": {}, "score": "61.353706"}
{"text": "This syntax is the normative XML serialization of the presentation syntax .The key features of this syntax are derived from the presentation syntax , but some aspects related to rule exchange do not have counterparts in the presentation syntax .In the RIF presentation syntax , variables are written as Unicode strings preceded with the symbol \" ? \" The syntax for constant symbols is given in Section Symbol Spaces below .", "label": "", "metadata": {}, "score": "61.53476"}
{"text": "This syntax is the normative XML serialization of the presentation syntax .The key features of this syntax are derived from the presentation syntax , but some aspects related to rule exchange do not have counterparts in the presentation syntax .In the RIF presentation syntax , variables are written as Unicode strings preceded with the symbol \" ? \" The syntax for constant symbols is given in Section Symbol Spaces below .", "label": "", "metadata": {}, "score": "61.53476"}
{"text": "The arguments LOCALE , TAG - SET and EXACT - P are the same as for ' remove - specifier ' . \"( mapc ( lambda ( x ) ( remove - specifier ( face - property face x ) locale tag - set exact - p ) ) built - in - face - specifiers ) nil ) ( defun set - face - parent ( face parent & optional locale tag - set how - to - add ) \" Set the parent of FACE to PARENT , for all properties .", "label": "", "metadata": {}, "score": "61.62464"}
{"text": "The arguments LOCALE , TAG - SET and EXACT - P are the same as for ' remove - specifier ' . \"( mapc ( lambda ( x ) ( remove - specifier ( face - property face x ) locale tag - set exact - p ) ) built - in - face - specifiers ) nil ) ( defun set - face - parent ( face parent & optional locale tag - set how - to - add ) \" Set the parent of FACE to PARENT , for all properties .", "label": "", "metadata": {}, "score": "61.62464"}
{"text": "\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ) ' global ) ; ; Define some logical color names to be used when reading the pixmap files .As part of its Phase 1 deliverable , the RIF Working Group defines a condition language , which is envisioned to be a shared part of all RIF dialects .", "label": "", "metadata": {}, "score": "61.705452"}
{"text": "This allows the code using each Debugger instance to place whatever properties it likes on its own Debugger .Object instances , without worrying about interfering with other debuggers . )Debugger .Environment instances protect their referents from the garbage collector ; as long as the Debugger .", "label": "", "metadata": {}, "score": "61.747154"}
{"text": "Descriptors passed to handler 's methods are ordinary objects in the debugger 's compartment , except for value , get , and set properties in descriptors , which are debuggee values ; they are the sort of value expected by Debugger .", "label": "", "metadata": {}, "score": "61.75532"}
{"text": "( 1987 ) , The Robot 's Dilemma : The Frame Problem in Artificial Intelligence , Ablex .Rietveld , R. ( 2012 ) , \" Context - switching and Responsiveness to Real Relevance \" , in J.Kiverstein & M.Wheeler ( eds . ) , Heidegger and Cognitive Science : New Directions in Cognitive Science and Philosophy , Palgrave Macmillan , pp .", "label": "", "metadata": {}, "score": "61.773445"}
{"text": "Of the debugger 's objects , only Debugger .Object instances may be passed to the debuggee : when this occurs , the debuggee receives the Debugger .Object 's referent , not the Debugger .Object instance itself .In the descriptions below , the term \" debuggee value \" means either a primitive value or a Debugger .", "label": "", "metadata": {}, "score": "61.793083"}
{"text": "The first instantiator that is valid for the domain ( usually this means that the instantiator is recognized by the device [ i.e. the X server or TTY device ] that the domain is on .The function ' face - property - instance ' actually does all this , and is used to determine how to display the face .", "label": "", "metadata": {}, "score": "61.968086"}
{"text": "The first instantiator that is valid for the domain ( usually this means that the instantiator is recognized by the device [ i.e. the X server or TTY device ] that the domain is on .The function ' face - property - instance ' actually does all this , and is used to determine how to display the face .", "label": "", "metadata": {}, "score": "61.968086"}
{"text": "RIF - compliant implementations must support the following symbol spaces .Rule sets that are exchanged through RIF can use additional symbol spaces as explained below .This symbol space represents text strings with a language tag attached .The lexical space of rif : text is the set of all Unicode strings of the form ... @LANG , i.e. , strings that end with @LANG where LANG is a language identifier as defined in IETF RFC 3066 .", "label": "", "metadata": {}, "score": "62.07051"}
{"text": "RIF - compliant implementations must support the following symbol spaces .Rule sets that are exchanged through RIF can use additional symbol spaces as explained below .This symbol space represents text strings with a language tag attached .The lexical space of rif : text is the set of all Unicode strings of the form ... @LANG , i.e. , strings that end with @LANG where LANG is a language identifier as defined in IETF RFC 3066 .", "label": "", "metadata": {}, "score": "62.07051"}
{"text": "Reasoning Agents in a Dynamic World : The Frame Problem , Greenwich : JAI Press .Harnad , S. ( 1987 )The induction and representation of categories .In : Harnad , S. ( ed . )Categorical Perception : The Groundwork of Cognition .", "label": "", "metadata": {}, "score": "62.172897"}
{"text": "RIF BLD has been designed to be extended by all future logic - based dialects .From a theoretical perspective , RIF - BLD corresponds to the language of definite Horn rules ( see Horn Logic ) with equality and with a standard first - order semantics .", "label": "", "metadata": {}, "score": "62.29976"}
{"text": "( color - instance - name ( face - foreground - instance face domain default no - fallback ) ) ) ( defun set - face - foreground ( face color & optional locale tag - set how - to - add ) \" Change the foreground color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.30258"}
{"text": "( color - instance - name ( face - foreground - instance face domain default no - fallback ) ) ) ( defun set - face - foreground ( face color & optional locale tag - set how - to - add ) \" Change the foreground color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.30258"}
{"text": "For instance , some versions of NAF use three truth values : t , f , and u ( undefined ) .Handling of contradictions and uncertainty requires at least four truth values : t , u , f , and i ( inconsistent ) .", "label": "", "metadata": {}, "score": "62.336044"}
{"text": "For instance , some versions of NAF use three truth values : t , f , and u ( undefined ) .Handling of contradictions and uncertainty requires at least four truth values : t , u , f , and i ( inconsistent ) .", "label": "", "metadata": {}, "score": "62.336067"}
{"text": "If offset is omitted , return the handlers of all breakpoints set anywhere in this script .If offset is present , but not a valid offset in this script , throw an error .Remove all breakpoints set in this Debugger instance that use handler as their handler .", "label": "", "metadata": {}, "score": "62.385017"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for the eval code is the referent . )Like evalInGlobal , but evaluate code using the referent as the variable object , but with a lexical environment extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "62.399734"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' background - pixmap locale tag - set exact - p ) ) ( defun face - background - pixmap - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background pixmap in DOMAIN .", "label": "", "metadata": {}, "score": "62.447968"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' background - pixmap locale tag - set exact - p ) ) ( defun face - background - pixmap - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background pixmap in DOMAIN .", "label": "", "metadata": {}, "score": "62.447968"}
{"text": "( cond ( frame ; ; Try to get from cache .( let ( ( cache ( frame - property frame ' custom - properties ) ) )( unless cache ; ; Oh well , get it then .( setq cache ( extract - custom - frame - properties frame ) ) ; ; and cache it ... ( set - frame - property frame ' custom - properties cache ) ) cache ) ) ; ; We avoid this cache , because various frame and device ; ; properties can change .", "label": "", "metadata": {}, "score": "62.49599"}
{"text": "( cond ( frame ; ; Try to get from cache .( let ( ( cache ( frame - property frame ' custom - properties ) ) )( unless cache ; ; Oh well , get it then .( setq cache ( extract - custom - frame - properties frame ) ) ; ; and cache it ... ( set - frame - property frame ' custom - properties cache ) ) cache ) ) ; ; We avoid this cache , because various frame and device ; ; properties can change .", "label": "", "metadata": {}, "score": "62.49599"}
{"text": "LOCALE works as in ' make - face - bold ' et al . , but the ' ' inheriting- from - the - bold - face ' ' operations described there are not done because they do n't make sense in this context .", "label": "", "metadata": {}, "score": "62.51322"}
{"text": "LOCALE works as in ' make - face - bold ' et al . , but the ' ' inheriting- from - the - bold - face ' ' operations described there are not done because they do n't make sense in this context .", "label": "", "metadata": {}, "score": "62.51322"}
{"text": "VARNAME .The above is a standard syntax for a variant of first - order logic .The application of a constant ( Const ) symbol to a sequence of terms is called a Uniterm ( Universal term ) ; it can play the role of a term or an atomic formula depending on the syntactic context in which the application occurs .", "label": "", "metadata": {}, "score": "62.565483"}
{"text": "VARNAME .The above is a standard syntax for a variant of first - order logic .The application of a constant ( Const ) symbol to a sequence of terms is called a Uniterm ( Universal term ) ; it can play the role of a term or an atomic formula depending on the syntactic context in which the application occurs .", "label": "", "metadata": {}, "score": "62.565483"}
{"text": "The following symbols have predefined meanings : foreground The foreground color of the face .For valid instantiators , see ' color - specifier - p ' .background The background color of the face .For valid instantiators , see ' color - specifier - p ' .", "label": "", "metadata": {}, "score": "62.613"}
{"text": "The following symbols have predefined meanings : foreground The foreground color of the face .For valid instantiators , see ' color - specifier - p ' .background The background color of the face .For valid instantiators , see ' color - specifier - p ' .", "label": "", "metadata": {}, "score": "62.613"}
{"text": "( color - instance - name ( face - background - instance face domain default no - fallback ) ) ) ( defun set - face - background ( face color & optional locale tag - set how - to - add ) \" Change the background color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.678776"}
{"text": "( color - instance - name ( face - background - instance face domain default no - fallback ) ) ) ( defun set - face - background ( face color & optional locale tag - set how - to - add ) \" Change the background color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.678776"}
{"text": "This section develops a RIF - BLD Rule Sublanguage by extending the RIF Condition Language , where conditions become rule bodies .RIF Phase I covers only Horn Rules and a number of extensions that do not increase the expressive power of the language .", "label": "", "metadata": {}, "score": "62.68212"}
{"text": "This section develops a RIF - BLD Rule Sublanguage by extending the RIF Condition Language , where conditions become rule bodies .RIF Phase I covers only Horn Rules and a number of extensions that do not increase the expressive power of the language .", "label": "", "metadata": {}, "score": "62.68212"}
{"text": "Constant symbols that belong to this symbol space are intended to be used in a way similar to RDF resources .The lexical space consists of all absolute IRIs as specified in RFC 3987 ; it is unrelated to the XML primitive type anyURI .", "label": "", "metadata": {}, "score": "62.83562"}
{"text": "Constant symbols that belong to this symbol space are intended to be used in a way similar to RDF resources .The lexical space consists of all absolute IRIs as specified in RFC 3987 ; it is unrelated to the XML primitive type anyURI .", "label": "", "metadata": {}, "score": "62.83562"}
{"text": "If global is a cross - compartment wrapper , this method returns a Debugger .Object instance referring to the wrapper 's referent .If global is a Debugger .Object instance belonging to this Debugger instance , this method returns global itself .", "label": "", "metadata": {}, "score": "62.835693"}
{"text": "Example 1 ( A RIF condition in and outside of a rule ) RIF condition : Exists ?Y ( condition ( ?X ?Y ) )RIF Horn rule : Forall ?X ( then_part ( ?X ) : - Exists ?", "label": "", "metadata": {}, "score": "62.839657"}
{"text": "Example 1 ( A RIF condition in and outside of a rule ) RIF condition : Exists ?Y ( condition ( ?X ?Y ) )RIF Horn rule : Forall ?X ( then_part ( ?X ) : - Exists ?", "label": "", "metadata": {}, "score": "62.839657"}
{"text": "In contrast , abc^^xsd : long is ill - formed , as it does not have a correct lexical part .A compliant RIF - BLD interpreter must reject ill - formed symbols .Symbols with undefined symbol spaces .RIF allows symbols of the form LITERAL^^SYMSPACE where SYMSPACE is not one of the pre - defined RIF symbol spaces .", "label": "", "metadata": {}, "score": "62.861122"}
{"text": "In contrast , abc^^xsd : long is ill - formed , as it does not have a correct lexical part .A compliant RIF - BLD interpreter must reject ill - formed symbols .Symbols with undefined symbol spaces .RIF allows symbols of the form LITERAL^^SYMSPACE where SYMSPACE is not one of the pre - defined RIF symbol spaces .", "label": "", "metadata": {}, "score": "62.861122"}
{"text": "To simplify the language , this document will often use symbol space identifiers to refer to the actual symbol spaces ( for instance , we may say \" symbol space xsd : string \" instead of \" symbol space identified by xsd : string \") .", "label": "", "metadata": {}, "score": "62.871803"}
{"text": "A scenario with a door , which can be open or closed , and a light , which can be on or off , is statically represented by two propositions and .If these conditions can change , they are better represented by two predicates and that depend on time ; such predicates are called fluents .", "label": "", "metadata": {}, "score": "62.937824"}
{"text": "( interactive ( face - interactive \" foreground \" ) ) ( set - face - property face ' foreground color locale tag - set how - to - add ) ) ( defun face - background ( face & optional locale tag - set exact - p ) \" Return the background color of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "63.007336"}
{"text": "( interactive ( face - interactive \" foreground \" ) ) ( set - face - property face ' foreground color locale tag - set how - to - add ) ) ( defun face - background ( face & optional locale tag - set exact - p ) \" Return the background color of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "63.007336"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" strikethru - p \" \" strikethru - d \" ) ) ( set - face - property face ' strikethru strikethru - p locale tag - set how - to - add ) ) ( defun face - highlight - p ( face & optional domain default no - fallback ) \" Return t if FACE is highlighted in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "63.03661"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" strikethru - p \" \" strikethru - d \" ) ) ( set - face - property face ' strikethru strikethru - p locale tag - set how - to - add ) ) ( defun face - highlight - p ( face & optional domain default no - fallback ) \" Return t if FACE is highlighted in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "63.03661"}
{"text": "At first sight , this question is only impressionistically related to the logical problem exercising the AI researchers .In contrast to the AI researcher 's problem , the philosopher 's question is n't expressed in the context of formal logic , and does n't specifically concern the non - effects of actions .", "label": "", "metadata": {}, "score": "63.114925"}
{"text": "Every handler method called while the debuggee is running in a given frame is given the same frame object .Similarly , walking the stack back to a previously accessed frame yields the same frame object as before .( If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .", "label": "", "metadata": {}, "score": "63.138878"}
{"text": "As the examples of ( 11b , e ) show , verbs ( and lexical items more generally ) may be associated with more than one subcategorization frame .devour ._ _ _ NP .d. . waited ._ _ _ .", "label": "", "metadata": {}, "score": "63.149826"}
{"text": "The Exists formula , where Var+ stands for the list of variables that are free in CONDITION , is an existential formula .It is the only kind of quantified formulas in RIF - BLD , but other dialects may add universal quantification .", "label": "", "metadata": {}, "score": "63.1734"}
{"text": "The Exists formula , where Var+ stands for the list of variables that are free in CONDITION , is an existential formula .It is the only kind of quantified formulas in RIF - BLD , but other dialects may add universal quantification .", "label": "", "metadata": {}, "score": "63.1734"}
{"text": "Name must be a string that is a valid ECMAScript identifier name .The result is a debuggee value .Store value as the value of the variable bound to name in this environment .Name must be a string that is a valid ECMAScript identifier name ; value must be a debuggee value .", "label": "", "metadata": {}, "score": "63.179363"}
{"text": "For Wheeler and others , classical AI and cognitive science rest on Cartesian assumptions that need to be overthrown in favour of a more Heideggerian stance before the frame problem can be overcome ( Dreyfus 2008 ; Wheeler 2005 ; 2008 ; Rietveld 2012 ) .", "label": "", "metadata": {}, "score": "63.261726"}
{"text": "If PIXMAP is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "63.26853"}
{"text": "If PIXMAP is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "63.26853"}
{"text": "This property must be either undefined or a function .If it is a function , SpiderMonkey calls it if the current frame is a generator frame whose execution has just been resumed .On newly created frames , this property 's value is undefined .", "label": "", "metadata": {}, "score": "63.294495"}
{"text": "A final issue concerns verbs such as eat , which can be used either with or without an explicit object .In the rule - based approach to generating syntactic structure , such verbs are associated with multiple subcategorization frames ; recall ( 11b , e ) .", "label": "", "metadata": {}, "score": "63.385803"}
{"text": "Only direct children are included ; nested children can be reached by walking the tree .Set a breakpoint at the bytecode instruction at offset in this script , reporting hits to the hit method of handler .If offset is not a valid offset in this script , throw an error .", "label": "", "metadata": {}, "score": "63.411194"}
{"text": "When a debugger in one compartment is debugging globals in another , many kinds of events in the debuggees may cause the debugger to call its handler methods .Conversely , a call to almost any method in this interface could cause the debugger to try to interact with a debuggee in some way .", "label": "", "metadata": {}, "score": "63.576702"}
{"text": "Garbage collection has no visible effect on Debugger .Environment instances .\" declarative \" , indicating that the environment is a declarative environment record .Function calls , calls to eval , let blocks , catch blocks , and the like create declarative environment records . \" object \" , indicating that the environment 's bindings are the properties of an object .", "label": "", "metadata": {}, "score": "63.663746"}
{"text": "If \u03c6 is a well - formed condition formula and ?V 1 , ... , ?V n are variables then Exists ?V 1 ... ?V n ( \u03c6 ) is a well - formed condition formula .Examples .", "label": "", "metadata": {}, "score": "63.668266"}
{"text": "If \u03c6 is a well - formed condition formula and ?V 1 , ... , ?V n are variables then Exists ?V 1 ... ?V n ( \u03c6 ) is a well - formed condition formula .Examples .", "label": "", "metadata": {}, "score": "63.668266"}
{"text": "Categorical Perception and the Evolution of Supervised Learning in Neural Nets .In : Working Papers of the AAAI Spring Symposium on Machine Learning of Natural Language and Ontology ( DW Powers & L Reeker , Eds . ) pp .65 - 74 .", "label": "", "metadata": {}, "score": "63.713596"}
{"text": "Return an array L describing the relationship between bytecode instruction offsets and source code positions in this script .L is sparse , and indexed by source line number .If a source line number line has no code , then L has no line property .", "label": "", "metadata": {}, "score": "63.73987"}
{"text": "Such a set can thus be infinite , finite , or even empty .In RIF - BLD , signatures can have at most one arrow expression .Other dialects ( such as HiLog , for example ) may require polymorphic symbols and thus allow signatures with more than one arrow expression in them .", "label": "", "metadata": {}, "score": "63.835415"}
{"text": "Such a set can thus be infinite , finite , or even empty .In RIF - BLD , signatures can have at most one arrow expression .Other dialects ( such as HiLog , for example ) may require polymorphic symbols and thus allow signatures with more than one arrow expression in them .", "label": "", "metadata": {}, "score": "63.835415"}
{"text": "RIF dialects that extend RIF - BLD will be specified in other documents by this working group .The condition sublanguage of RIF - BLD is intended to be a common basis for the dialects of RIF .First of all , it is used by RIF - BLD itself .", "label": "", "metadata": {}, "score": "63.856163"}
{"text": "RIF dialects that extend RIF - BLD will be specified in other documents by this working group .The condition sublanguage of RIF - BLD is intended to be a common basis for the dialects of RIF .First of all , it is used by RIF - BLD itself .", "label": "", "metadata": {}, "score": "63.856163"}
{"text": "If the optional FRAME argument is provided , change only in that frame ; otherwise change each frame . \"( while ( not ( find - face face ) )( setq face ( signal ' wrong - type - argument ( list ' facep face ) ) ) ) ( locate - file pixmap x - bitmap - file - path \" .", "label": "", "metadata": {}, "score": "63.925095"}
{"text": "If the optional FRAME argument is provided , change only in that frame ; otherwise change each frame . \"( while ( not ( find - face face ) )( setq face ( signal ' wrong - type - argument ( list ' facep face ) ) ) ) ( locate - file pixmap x - bitmap - file - path \" .", "label": "", "metadata": {}, "score": "63.925095"}
{"text": "b. Universal - existential form : Forall ? item ( reject^^rif : local ( ppl#John^^rif : iri ? item ) : - Exists ? deliverydate ? scheduledate ? diffduration ? diffdays ( And ( perishable^^rif : local ( ? item ) delivered^^rif : local ( ? item ? deliverydate ppl : John^^rif : iri ) scheduled^^rif : local ( ? item ? scheduledate ) fn : subtract - dateTimes - yielding - dayTimeDuration ( ? deliverydate ? scheduledate ? diffuration ) fn : get - days - from - dayTimeDuration ( ? diffduration ? diffdays ) op : numeric - greater - than ( ? diffdays 10 ) ) ) ) .", "label": "", "metadata": {}, "score": "64.03944"}
{"text": "For valid instantiators , see ' image - specifier - p ' .underline Underline all text covered by this face .For valid instantiators , see ' face - boolean - specifier - p ' .strikethru Draw a line through all text covered by this face .", "label": "", "metadata": {}, "score": "64.38878"}
{"text": "For valid instantiators , see ' image - specifier - p ' .underline Underline all text covered by this face .For valid instantiators , see ' face - boolean - specifier - p ' .strikethru Draw a line through all text covered by this face .", "label": "", "metadata": {}, "score": "64.38878"}
{"text": "Watchpoint handler calls are cross - compartment , intra - thread calls : the call takes place in the same thread that changed the property , and in handler 's method 's compartment ( typically the same as the debugger 's compartment ) .", "label": "", "metadata": {}, "score": "64.487976"}
{"text": "Object referring to it .The new object 's prototype is prototype , which must be an Debugger .Object instance .The new object 's properties are as given by properties , as if properties were passed to Debugger .Object.prototype.defineProperties , with the new Debugger .", "label": "", "metadata": {}, "score": "64.66374"}
{"text": "For valid instantiators , see ' font - specifier - p ' .display - table The display table of the face .This should be a vector of 256 elements . background - pixmap The pixmap displayed in the background of the face .", "label": "", "metadata": {}, "score": "64.75275"}
{"text": "For valid instantiators , see ' font - specifier - p ' .display - table The display table of the face .This should be a vector of 256 elements . background - pixmap The pixmap displayed in the background of the face .", "label": "", "metadata": {}, "score": "64.75275"}
{"text": "Moreover , insofar as the goal of classical AI is not computers with human - level intelligence , but is simply the design of better and more useful computer programs , it is immune to the philosophical objections of Fodor , Dreyfus , and the like .", "label": "", "metadata": {}, "score": "64.91347"}
{"text": "( face - property - instance face ' strikethru domain default no - fallback ) ) ( defun set - face - strikethru - p ( face strikethru - p & optional locale tag - set how - to - add ) \" Change whether FACE is strikethru - d ( i.e. struck through ) in LOCALE .", "label": "", "metadata": {}, "score": "64.9753"}
{"text": "( face - property - instance face ' strikethru domain default no - fallback ) ) ( defun set - face - strikethru - p ( face strikethru - p & optional locale tag - set how - to - add ) \" Change whether FACE is strikethru - d ( i.e. struck through ) in LOCALE .", "label": "", "metadata": {}, "score": "64.9753"}
{"text": "The returned instance will typically be a color - instance , font - instance , or pixmap - instance object , and you can query it using the appropriate object - specific functions .For example , you could use ' color - instance - rgb - components ' to find out the RGB ( red , green , and blue ) components of how the ' background property of the ' highlight face is displayed in a particular window .", "label": "", "metadata": {}, "score": "65.16316"}
{"text": "The returned instance will typically be a color - instance , font - instance , or pixmap - instance object , and you can query it using the appropriate object - specific functions .For example , you could use ' color - instance - rgb - components ' to find out the RGB ( red , green , and blue ) components of how the ' background property of the ' highlight face is displayed in a particular window .", "label": "", "metadata": {}, "score": "65.16316"}
{"text": "Dennett , D. ( 1978 ) , Brainstorms , MIT Press . -( 1987 ) , \" Cognitive Wheels : The Frame Problem in Artificial Intelligence \" , in Pylyshyn ( 1987 ) .Dreyfus , H.L. ( 1991 ) , Being - in - the - World : A Commentary on Heidegger 's Being and Time , Division I , MIT Press . -", "label": "", "metadata": {}, "score": "65.21146"}
{"text": "( error ' dark ) ) ) ) ( set - frame - property frame ' background - mode mode ) mode ) ) ( defun extract - custom - frame - properties ( frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "65.31733"}
{"text": "( error ' dark ) ) ) ) ( set - frame - property frame ' background - mode mode ) mode ) ) ( defun extract - custom - frame - properties ( frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "65.31733"}
{"text": "Frame instance , you can find the script the frame is executing , walk the stack to older frames , find the lexical environment in which the execution is taking place , and so on .For a given Debugger instance , SpiderMonkey creates only one Debugger .", "label": "", "metadata": {}, "score": "65.326126"}
{"text": "( add - spec - list - to - specifier sp ( list ( cons locale new - result ) ) ) ; ; tell map - specifier to keep going .If we 're ; ; inheriting from a standard face in this locale , frob the ; ; inheritance as appropriate .", "label": "", "metadata": {}, "score": "65.32907"}
{"text": "( add - spec - list - to - specifier sp ( list ( cons locale new - result ) ) ) ; ; tell map - specifier to keep going .If we 're ; ; inheriting from a standard face in this locale , frob the ; ; inheritance as appropriate .", "label": "", "metadata": {}, "score": "65.32907"}
{"text": "Sorted HiLog : Sorts in Higher - Order Logic Data Languages , W. Chen , M. Kifer .Sixth Intl .Conference on Database Theory , Prague , Czech Republic , January 1995 , Lecture Notes in Computer Science 893 , Springer Verlag , pp .", "label": "", "metadata": {}, "score": "65.36461"}
{"text": "Sorted HiLog : Sorts in Higher - Order Logic Data Languages , W. Chen , M. Kifer .Sixth Intl .Conference on Database Theory , Prague , Czech Republic , January 1995 , Lecture Notes in Computer Science 893 , Springer Verlag , pp .", "label": "", "metadata": {}, "score": "65.36461"}
{"text": "( font - proportional - p ( face - font face ) domain charset ) ) ; ; Functions that used to be in cus - face .el , but logically go here .Set this to the symbol dark if your background color is dark , light if your background is light , or nil ( default ) if you want Emacs to examine the brightness for you .", "label": "", "metadata": {}, "score": "65.67086"}
{"text": "( font - proportional - p ( face - font face ) domain charset ) ) ; ; Functions that used to be in cus - face .el , but logically go here .Set this to the symbol dark if your background color is dark , light if your background is light , or nil ( default ) if you want Emacs to examine the brightness for you .", "label": "", "metadata": {}, "score": "65.67086"}
{"text": "The order of the arguments in a slotted arrow expression is assumed to be immaterial , so any permutation of arguments is assumed to yield the same expression .By analogy with earlier definitions , if \u03ba is atomic then the expression is also a slotted Boolean expression .", "label": "", "metadata": {}, "score": "65.73548"}
{"text": "Any previous watchpoint handler on this property for this Debugger .Object instance is replaced .If handler is null , the property is no longer watched .Handler is as described for Debugger .Object.prototype.setObjectWatchpoint , except that it does not receive extensionsPrevented events .", "label": "", "metadata": {}, "score": "65.82353"}
{"text": "LITERAL must be an element in the lexical space of the symbol space .For instance , 1.2^^xsd : decimal and 1^^xsd : decimal are legal symbols because 1.2 and 1 are members of the lexical space of the XML data type xsd : decimal .", "label": "", "metadata": {}, "score": "65.87835"}
{"text": "LITERAL must be an element in the lexical space of the symbol space .For instance , 1.2^^xsd : decimal and 1^^xsd : decimal are legal symbols because 1.2 and 1 are members of the lexical space of the XML Schema data type xsd : decimal .", "label": "", "metadata": {}, "score": "65.915245"}
{"text": "Primitive values are passed freely between debugger and debuggee ; copying or wrapping is handled transparently .Objects received from the debuggee ( including host objects like DOM elements ) are fronted in the debugger by Debugger .Object instances , which provide reflection - oriented methods for inspecting their referents ; see Debugger .", "label": "", "metadata": {}, "score": "66.1774"}
{"text": "( defun init - global - faces ( ) ; ; Look for global face resources .( loop for face in ( face - list ) do ( init - face - from - resources face ' global ) ) ; ; Further X frobbing .", "label": "", "metadata": {}, "score": "66.3349"}
{"text": "( defun init - global - faces ( ) ; ; Look for global face resources .( loop for face in ( face - list ) do ( init - face - from - resources face ' global ) ) ; ; Further X frobbing .", "label": "", "metadata": {}, "score": "66.3349"}
{"text": "None of this has turned out to be at all straightforward .One of the most troublesome barriers to progress was highlighted in the so - called Yale shooting problem ( Hanks & McDermott 1987 ) , a simple scenario that gives rise to counter - intuitive conclusions if naively represented with a non - monotonic formalism .", "label": "", "metadata": {}, "score": "66.48593"}
{"text": "Regardless of things , do the TTY ; ; frobbing .; ; yuck --The LOCALE argument to make - face - bold is not actually a locale , ; ; but is a \" locale , locale - type , or nil for all \" .", "label": "", "metadata": {}, "score": "66.771706"}
{"text": "Regardless of things , do the TTY ; ; frobbing .; ; yuck --The LOCALE argument to make - face - bold is not actually a locale , ; ; but is a \" locale , locale - type , or nil for all \" .", "label": "", "metadata": {}, "score": "66.771706"}
{"text": "Return true if the referent is extensible \u2014 that is , if it can have new properties defined on it .( This function behaves like the standard Object.isExtensible function , except that the object inspected is implicit and in a different compartment from the caller . )", "label": "", "metadata": {}, "score": "66.93855"}
{"text": "The document RIF Use Cases and Requirements includes a use case \" Negotiating eBusiness Contracts Across Rule Platforms \" , which discusses a business rule slightly modified here : .The prefix op is used for a yet - to - be - determined IRI , which will be used for RIF builtin predicates .", "label": "", "metadata": {}, "score": "66.961555"}
{"text": "The document RIF Use Cases and Requirements includes a use case \" Negotiating eBusiness Contracts Across Rule Platforms \" , which discusses a business rule slightly modified here : .The prefix op is used for a yet - to - be - determined IRI , which will be used for RIF builtin predicates .", "label": "", "metadata": {}, "score": "66.961555"}
{"text": "As the debuggee runs , the Debugger interface calls various debugger - provided handler functions to report the debuggee 's behavior .Some of these calls can return a value indicating how the debuggee 's execution should continue ; these are called resumption values .", "label": "", "metadata": {}, "score": "67.20714"}
{"text": "( interactive ( face - interactive \" background \" ) ) ( set - face - property face ' background color locale tag - set how - to - add ) ) ( defun face - background - pixmap ( face & optional locale tag - set exact - p ) \" Return the background pixmap of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "67.29249"}
{"text": "( interactive ( face - interactive \" background \" ) ) ( set - face - property face ' background color locale tag - set how - to - add ) ) ( defun face - background - pixmap ( face & optional locale tag - set exact - p ) \" Return the background pixmap of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "67.29249"}
{"text": "( if is true in situation , and it can be assumed [ 3 ] that remains true after executing action , then we can conclude that remains true ) .Steve Hanks and Drew McDermott argued , on the basis of their Yale shooting example , that this solution to the frame problem is unsatisfactory .", "label": "", "metadata": {}, "score": "67.30557"}
{"text": "b. Universal - existential form : Forall ? item ( reject^^rif : local ( ppl#John^^rif : iri ? item ) : - Exists ? deliverydate ? scheduledate ? diffdate ( And ( perishable^^rif : local ( ? item ) delivered^^rif : local ( ? item ? deliverydate ppl : John^^rif : iri ) scheduled^^rif : local ( ? item ? scheduledate ) timediff ( ? diffdate ? deliverydate ? scheduledate ) op : numeric - greater - than ( ? diffdate 10 ) ) ) ) .", "label": "", "metadata": {}, "score": "67.364296"}
{"text": "Frame instance representing the currently executing stack frame .Breakpoint handler method calls are cross - compartment , intra - thread calls : the call takes place in the same thread that hit the breakpoint , and in the compartment containing the handler function ( typically the debugger 's compartment ) .", "label": "", "metadata": {}, "score": "67.55086"}
{"text": "Add the global object designated by global to the set of global objects this Debugger instance is debugging .Return this Debugger 's Debugger .Object instance referring to global 's referent .The global designated by global must be in a different compartment than this Debugger instance itself .", "label": "", "metadata": {}, "score": "67.62496"}
{"text": "Given a Debugger .Object instance d and an object o , the call d.makeDebuggeeValue(o ) returns a Debugger .Object instance that presents o as it would be seen by code in d 's compartment .If the referent is a function that is debuggee code , return the JavaScript source code for a function definition equivalent to the referent function in its effect and result , as a string .", "label": "", "metadata": {}, "score": "67.83299"}
{"text": "t ) ( [ italic ] .[ default ] ) ( [ bold - italic ] .[ bold ] ) ) ) ) ; ; Why do the following two functions lose so badly in so many ; ; circumstances ?", "label": "", "metadata": {}, "score": "67.97494"}
{"text": "t ) ( [ italic ] .[ default ] ) ( [ bold - italic ] .[ bold ] ) ) ) ) ; ; Why do the following two functions lose so badly in so many ; ; circumstances ?", "label": "", "metadata": {}, "score": "67.97494"}
{"text": "569 - 595 .Bruineberg , J. & Rietveld , E. ( 2014 ) , \" Self - organization , Free Energy Minimization , and Optimal Grip on a Field of Affordances \" , Frontiers in Human Neuroscience , 8 : 559 , doi : 10.3389/fnhum.2014.00599 .", "label": "", "metadata": {}, "score": "68.11249"}
{"text": "( Note that Debugger .Object instances referring to functions also have a decompile method , whose result includes the function header and parameter names , so it is probably better to write f.decompile ( ) than to write f.getFunctionScript ( ) .", "label": "", "metadata": {}, "score": "68.22867"}
{"text": "Environment instance representing the referent as a variable environment for evaluating code .If the referent is not a global object , throw a TypeError .Set a watchpoint on all the referent 's own properties , reporting events by calling handler 's methods .", "label": "", "metadata": {}, "score": "68.39044"}
{"text": "Rather , those parts that represent facets of the world that have changed are modified , and the rest is simply left as it is ( following the dictum \" let sleeping dogs lie \" ) .In our example of the robot and the tea - cup , we might apply the sleeping dog strategy by having the robot update its beliefs about the location of the cup and the contents of the cupboard .", "label": "", "metadata": {}, "score": "68.62482"}
{"text": "( let ( ( init - face - from - resources nil ) ) ( make - face name doc - string temporary ) ) ) ( defun init - face - from - resources ( face & optional locale ) \" Initialize FACE from the resource database .", "label": "", "metadata": {}, "score": "68.9261"}
{"text": "( let ( ( init - face - from - resources nil ) ) ( make - face name doc - string temporary ) ) ) ( defun init - face - from - resources ( face & optional locale ) \" Initialize FACE from the resource database .", "label": "", "metadata": {}, "score": "68.9261"}
{"text": "( 2008 ) , \" Why Heideggerian AI Failed and How Fixing It Would Require Making It More Heideggerian \" , in The Mechanical Mind in History , P. Husbands , O. Holland & M. Wheeler ( eds . ) , MIT Press , pp .", "label": "", "metadata": {}, "score": "69.23146"}
{"text": "Your event handling methods run in the compartment to which they belong , typically the debugger 's compartment .The compartment system mediates the debugger 's and debuggee 's access to each other 's objects .The Debugger interface does not itself support cross - thread or multi - threaded debugging .", "label": "", "metadata": {}, "score": "69.30282"}
{"text": "The same symbol space is allowed to have more than one identifier ( but different symbol spaces can not share an identifier ) .To simplify the language , this document will often use symbol space identifiers to refer to the actual symbol spaces ( for instance , we may say \" symbol space xsd : string \" instead of \" symbol space identified by xsd : string \") .", "label": "", "metadata": {}, "score": "69.50437"}
{"text": "( init - other - random - faces device ) ) ) ( defun init - frame - faces ( frame ) ( when init - face - from - resources ; ; First , add any frame - local face resources .", "label": "", "metadata": {}, "score": "69.508415"}
{"text": "( init - other - random - faces device ) ) ) ( defun init - frame - faces ( frame ) ( when init - face - from - resources ; ; First , add any frame - local face resources .", "label": "", "metadata": {}, "score": "69.508415"}
{"text": "Environment instances as needed as the debugger inspects stack frames and function objects ; calling Debugger .Environment as a function or constructor raises a TypeError exception .( If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .", "label": "", "metadata": {}, "score": "69.53622"}
{"text": "This happens very early , before creating ; ; the first non - stream device .( set - face - background ' text - cursor ' ( ( ( x default ) .\" Red3 \" ) ( ( mswindows default ) .", "label": "", "metadata": {}, "score": "69.58754"}
{"text": "This happens very early , before creating ; ; the first non - stream device .( set - face - background ' text - cursor ' ( ( ( x default ) .\" Red3 \" ) ( ( mswindows default ) .", "label": "", "metadata": {}, "score": "69.58754"}
{"text": "If \u03ba above is atomic then the signature is called a Boolean expression .A set S of signatures is coherent iff .S has at most one signature for any given signature name .Here \u03b7 S denotes a signature with the name \u03b7 and the associated set of arrow expression S ; similarly \u03ba R is a signature named \u03ba with the set of expressions R .", "label": "", "metadata": {}, "score": "69.606"}
{"text": "If \u03ba above is atomic then the signature is called a Boolean expression .A set S of signatures is coherent iff .S has at most one signature for any given signature name .Here \u03b7 S denotes a signature with the name \u03b7 and the associated set of arrow expression S ; similarly \u03ba R is a signature named \u03ba with the set of expressions R .", "label": "", "metadata": {}, "score": "69.606"}
{"text": "( An alternative design here would be : onException(status , frame , value ) where status is one of the strings \" throw \" , \" unwind \" , \" catch \" , \" finally \" , \" rethrow \" .JS_SaveExceptionState would trigger a \" finally \" event , JS_RestoreExceptionState would trigger a \" rethrow \" , JS_ClearPendingException would trigger a \" catch \" ; not sure what JS_DropExceptionState or a return / throw from a finally block should do . ) ' '", "label": "", "metadata": {}, "score": "69.692276"}
{"text": "For instance , 1.2^^xsd : decimal and 1.20^^xsd : decimal are two legal constants in RIF because 1.2 and 1.20 belong to the lexical space of xsd : decimal .However , these two constants are interpreted by the same element of the value space of the xsd : decimal type .", "label": "", "metadata": {}, "score": "69.74768"}
{"text": "For instance , 1.2^^xsd : decimal and 1.20^^xsd : decimal are two legal constants in RIF because 1.2 and 1.20 belong to the lexical space of xsd : decimal .However , these two constants are interpreted by the same element of the value space of the xsd : decimal type .", "label": "", "metadata": {}, "score": "69.74768"}
{"text": "Frame instance 's onPop handler method , if present , passing a yield resumption value ; however , the Debugger .Frame instance remains live .If multiple Debugger instances each have Debugger .Frame instances for a given stack frame with onPop handlers set , their handlers are run in an unspecified order .", "label": "", "metadata": {}, "score": "70.06816"}
{"text": "doi : 10.1016/0004 - 3702(95)90043 - 8 .This interface is partly implemented in Firefox Nightly builds .Some parts are not implemented , some APIs may yet change , and anything marked \" ( future plan ) \" is a long way off .", "label": "", "metadata": {}, "score": "70.07713"}
{"text": "May Be Superseded .This section describes the status of this document at the time of its publication .Other documents may supersede this document .Please Comment By ASAP .Working Group participants please send comments as soon as possible , for a 30 October publication decision .", "label": "", "metadata": {}, "score": "70.28021"}
{"text": "Frame instances . )Invoke the debuggee code as appropriate for the given invocation function , with the \" debugger \" frame as its continuation .For example , Debugger .Frame.prototype.eval pushes an \" eval \" frame for code it runs , whereas Debugger .", "label": "", "metadata": {}, "score": "70.56985"}
{"text": "A slotted arrow expression is a statement of the form .The order of the arguments in a slotted arrow expression is assumed to be immaterial , so any permutation of arguments is assumed to yield the same expression .By analogy with earlier definitions , if \u03ba is atomic then the expression is also a slotted Boolean expression .", "label": "", "metadata": {}, "score": "70.59764"}
{"text": "; ; You should have received a copy of the GNU General Public License ; ; along with XEmacs ; see the file COPYING .If not , write to the ; ; Free Software Foundation , Inc. , 59 Temple Place - Suite 330 , ; ; Boston , MA 02111 - 1307 , USA . ; ; ; Synched up with : Not synched with FSF .", "label": "", "metadata": {}, "score": "70.74054"}
{"text": "If the referent is a proxy whose handler object was allocated by debuggee code , this is its handler object \u2014 the object whose methods are invoked to implement accesses of the proxy 's properties .If the referent is not a proxy whose handler object was allocated by debuggee code , this is null .", "label": "", "metadata": {}, "score": "70.95391"}
{"text": "\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ) ' global ) ; ; Define some logical color names to be used when reading the pixmap files .; ; XEmacs is distributed in the hope that it will be useful , but ; ; WITHOUT ANY WARRANTY ; without even the implied warranty of ; ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE .", "label": "", "metadata": {}, "score": "71.01524"}
{"text": "So there seem to be both ecumenical and hegemonic sentiments in the air .For my part , I 'd like to cast my vote for another unitary candidate ( if only in the hope of keeping problem numbers tractable ) , one that might likewise subsume many of the rest as special cases .", "label": "", "metadata": {}, "score": "71.026596"}
{"text": "So there seem to be both ecumenical and hegemonic sentiments in the air .For my part , I 'd like to cast my vote for another unitary candidate ( if only in the hope of keeping problem numbers tractable ) , one that might likewise subsume many of the rest as special cases .", "label": "", "metadata": {}, "score": "71.026596"}
{"text": "( let ( ( sp ( face - property face property ) ) ) ( if ( valid - specifier - domain - p locale ) ; ; this is easy .Otherwise , something like ; ; ( make - face - larger ' modeline ) ; ; wo n't do anything at all if the modeline simply ; ; inherits its font from ' default .", "label": "", "metadata": {}, "score": "71.09581"}
{"text": "( let ( ( sp ( face - property face property ) ) ) ( if ( valid - specifier - domain - p locale ) ; ; this is easy .Otherwise , something like ; ; ( make - face - larger ' modeline ) ; ; wo n't do anything at all if the modeline simply ; ; inherits its font from ' default .", "label": "", "metadata": {}, "score": "71.09581"}
{"text": "When a debugger calls an invocation function to run debuggee code , that code 's continuation is the debugger , not the next debuggee code frame .Pushing a \" debugger \" frame makes this continuation explicit , and makes it easier to find the extent of the stack created for the invocation .", "label": "", "metadata": {}, "score": "71.11132"}
{"text": "; ; XEmacs is distributed in the hope that it will be useful , but ; ; WITHOUT ANY WARRANTY ; without even the implied warranty of ; ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE .See the GNU ; ; General Public License for more details .", "label": "", "metadata": {}, "score": "71.22966"}
{"text": "( not ( face - equal face ' default domain ) ) ) ; moved from x - faces . el ( defun try - font - name ( name & optional device ) ; ; yes , name really should be here twice .", "label": "", "metadata": {}, "score": "71.29814"}
{"text": "( not ( face - equal face ' default domain ) ) ) ; moved from x - faces . el ( defun try - font - name ( name & optional device ) ; ; yes , name really should be here twice .", "label": "", "metadata": {}, "score": "71.29814"}
{"text": "The Debugger interface constructs Debugger .Script objects as scripts of debuggee code are uncovered by the debugger : via the onNewScript handler method ; via Debugger .Frame 's script properties ; via the functionScript method of Debugger .Object instances ; and so on .", "label": "", "metadata": {}, "score": "71.343575"}
{"text": "For other methods , if their normal operation would cause debuggee code to run , they throw an instance of the Debugger .DebuggeeWouldRun exception .A Debugger .DebuggeeWouldRun exception may have a cause property , providing more detailed information on why the debuggee would have run .", "label": "", "metadata": {}, "score": "71.34807"}
{"text": "Each symbol space has an associated lexical space and a number of identifiers .The lexical space of a symbol space is a non - empty set of Unicode character strings .An identifier of a symbol space is an absolute IRI .", "label": "", "metadata": {}, "score": "71.69942"}
{"text": "An invocation function is any function in this interface that allows the debugger to invoke code in the debuggee : Debugger .Object.prototype.call , Debugger .Frame.prototype.eval , and so on .Let older be the youngest visible frame on the stack , or null if there is no such frame .", "label": "", "metadata": {}, "score": "71.8358"}
{"text": "So signal ; ; an error to indicate this . ; ; Otherwise map frob - face - property-1 over each device .( mapcar ( lambda ( arg ) ( when ( and arg ( not ( member arg new - result ) ) )", "label": "", "metadata": {}, "score": "71.88168"}
{"text": "So signal ; ; an error to indicate this . ; ; Otherwise map frob - face - property-1 over each device .( mapcar ( lambda ( arg ) ( when ( and arg ( not ( member arg new - result ) ) )", "label": "", "metadata": {}, "score": "71.88168"}
{"text": "These questions and the argument leading to them are very reminiscent of Goodman 's treatment of induction ( Goodman 1954 ) .Goodman 's \" new riddle of induction \" , commonly called the grue paradox , invites us to consider the predicate grue , which is true before time t only of objects that are green and after time t only of objects that are blue .", "label": "", "metadata": {}, "score": "71.95207"}
{"text": "Debugger .Object instances protect their referents from the garbage collector ; as long as the Debugger .Object instance is live , the referent remains live .This means that garbage collection has no visible effect on Debugger .Object instances .", "label": "", "metadata": {}, "score": "71.97085"}
{"text": "The lexical - to - value mapping of text , L,,text , , , maps each symbol string@lang in the lexical space of rif : text to ( string , lower - case(lang ) ) , where lower - case(lang ) is lang written in all - lowercase letters .", "label": "", "metadata": {}, "score": "72.17798"}
{"text": "We should use the custom mechanism for ; ; most of this stuff .Currently we do n't do it , because Custom ; ; does n't use specifiers ( yet . )FSF does it the Right Way . ; ; For instance , the definition of ' bold ' should be something like ; ; ( defface bold ( ( t ( : bold t ) ) ) \" Bold text . \" ) -- and ' : bold t ' should ; ; make sure that everything works properly .", "label": "", "metadata": {}, "score": "72.2956"}
{"text": "We should use the custom mechanism for ; ; most of this stuff .Currently we do n't do it , because Custom ; ; does n't use specifiers ( yet . )FSF does it the Right Way . ; ; For instance , the definition of ' bold ' should be something like ; ; ( defface bold ( ( t ( : bold t ) ) ) \" Bold text . \" ) -- and ' : bold t ' should ; ; make sure that everything works properly .", "label": "", "metadata": {}, "score": "72.2956"}
{"text": "If the referent is not callable , throw a TypeError .Code is a string .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If the referent is not a global object , throw a TypeError exception .", "label": "", "metadata": {}, "score": "72.306366"}
{"text": "Other documents may supersede this document .Please Comment By ASAP .Working Group participants please send comments as soon as possible , for a 30 October publication decision .Small changes may be made along the way .No Endorsement .", "label": "", "metadata": {}, "score": "72.6426"}
{"text": "Buyer ( purchase^^rif : local ( ?Buyer ?Seller book^^rif : local ( ?Author bks : LeRif^^rif : iri ) curr : USD^^rif : iri ( 49^^xsd : integer ) ) ?The first step in defining a model - theoretic semantics for a logic - based language is to define the notion of a semantic structure , also known as an interpretation .", "label": "", "metadata": {}, "score": "72.72267"}
{"text": "Buyer ( purchase^^rif : local ( ?Buyer ?Seller book^^rif : local ( ?Author bks : LeRif^^rif : iri ) curr : USD^^rif : iri ( 49^^xsd : integer ) ) ?The first step in defining a model - theoretic semantics for a logic - based language is to define the notion of a semantic structure , also known as an interpretation .", "label": "", "metadata": {}, "score": "72.72267"}
{"text": "If not , write to the ; ; Free Software Foundation , Inc. , 59 Temple Place - Suite 330 , ; ; Boston , MA 02111 - 1307 , USA . ; ; ; Synched up with : Not synched with FSF .", "label": "", "metadata": {}, "score": "72.84128"}
{"text": "What predicates should be included in our ontology for any of these claims about \" most properties \" to fall out ?To sharpen the point , Fodor introduces the concept of a \" fridgeon \" .Any particle is defined as a fridgeon at a given time if and only if Fodor 's fridge is switched on at that time .", "label": "", "metadata": {}, "score": "72.89199"}
{"text": "So , the inductive inference that all emeralds are grue seems to be no less legitimate than the inductive inference that all emeralds are green .The problem , of course , is the choice of predicates .Goodman showed that inductive inference only works in the context of the right set of predicates , and Fodor demonstrates much the same point for the common sense law of inertia .", "label": "", "metadata": {}, "score": "73.16423"}
{"text": "( face - property face ' doc - string ) ) ( defun set - face - doc - string ( face doc - string ) \" Change the documentation string of FACE to DOC - STRING . \"( interactive ( face - interactive \" doc - string \" ) ) ( set - face - property face ' doc - string doc - string ) ) ( defun face - font - name ( face & optional domain charset ) \" Return the font name of FACE in DOMAIN , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "73.1879"}
{"text": "( face - property face ' doc - string ) ) ( defun set - face - doc - string ( face doc - string ) \" Change the documentation string of FACE to DOC - STRING . \"( interactive ( face - interactive \" doc - string \" ) ) ( set - face - property face ' doc - string doc - string ) ) ( defun face - font - name ( face & optional domain charset ) \" Return the font name of FACE in DOMAIN , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "73.1879"}
{"text": "PIXMAP should be a string , the name of a file of pixmap data .The directories listed in the ' x - bitmap - file - path ' variable are searched .Alternatively , PIXMAP may be a list of the form ( WIDTH HEIGHT DATA ) where WIDTH and HEIGHT are the size in pixels , and DATA is a string , containing the raw bits of the bitmap .", "label": "", "metadata": {}, "score": "73.22002"}
{"text": "PIXMAP should be a string , the name of a file of pixmap data .The directories listed in the ' x - bitmap - file - path ' variable are searched .Alternatively , PIXMAP may be a list of the form ( WIDTH HEIGHT DATA ) where WIDTH and HEIGHT are the size in pixels , and DATA is a string , containing the raw bits of the bitmap .", "label": "", "metadata": {}, "score": "73.22002"}
{"text": "( + ( face - ascent face domain charset ) ( face - descent face domain charset ) ) ) ( defun face - proportional - p ( face & optional domain charset ) \" Return t if FACE is proportional in DOMAIN .", "label": "", "metadata": {}, "score": "73.4933"}
{"text": "( + ( face - ascent face domain charset ) ( face - descent face domain charset ) ) ) ( defun face - proportional - p ( face & optional domain charset ) \" Return t if FACE is proportional in DOMAIN .", "label": "", "metadata": {}, "score": "73.4933"}
{"text": "The lexical - to - value mapping of rif : text , L rif : text , maps each symbol string@lang in the lexical space of rif : text to ( string , lower - case(lang ) ) , where lower - case(lang ) is lang written in all - lowercase letters .", "label": "", "metadata": {}, "score": "73.74545"}
{"text": "Fetzer , J.H. ( 1991 ) , \" The Frame Problem : Artificial Intelligence Meets David Hume \" , in Ford & Hayes ( 1991 ) .Fodor , J.A. ( 1983 ) , The Modularity of Mind , MIT Press . -", "label": "", "metadata": {}, "score": "73.95051"}
{"text": "highlight Highlight all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .dim Dim all text covered by this face .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "74.08554"}
{"text": "highlight Highlight all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .dim Dim all text covered by this face .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "74.08554"}
{"text": "The frame problem , he claims , is \" Hamlet 's problem viewed from an engineer 's perspective \" .So construed , the obvious way to try to avoid the frame problem is by appealing to the notion of relevance .", "label": "", "metadata": {}, "score": "74.62965"}
{"text": "The common sense law of inertia is only justified in the context of the right ontology , the right choice of objects and predicates .But what is the right ontology to make the common sense law of inertia work ?Clearly , fridgeons and the like are to be excluded .", "label": "", "metadata": {}, "score": "74.65831"}
{"text": "( face - complain - about - font ' bold - italic device ) ) ) ) ) ) ; ; Set the text - cursor colors unless already specified .( defun set - face - stipple ( face pixmap & optional frame ) \" Change the stipple pixmap of FACE to PIXMAP .", "label": "", "metadata": {}, "score": "74.97499"}
{"text": "( face - complain - about - font ' bold - italic device ) ) ) ) ) ) ; ; Set the text - cursor colors unless already specified .( defun set - face - stipple ( face pixmap & optional frame ) \" Change the stipple pixmap of FACE to PIXMAP .", "label": "", "metadata": {}, "score": "74.97499"}
{"text": "t ) ) ) ) ( defun make - face - bold - italic ( face & optional locale ) \" Make FACE bold and italic in LOCALE , if possible .This will attempt to make the font bold - italic for X locales and will set the highlight and underline flags for TTY locales .", "label": "", "metadata": {}, "score": "75.05288"}
{"text": "t ) ) ) ) ( defun make - face - bold - italic ( face & optional locale ) \" Make FACE bold and italic in LOCALE , if possible .This will attempt to make the font bold - italic for X locales and will set the highlight and underline flags for TTY locales .", "label": "", "metadata": {}, "score": "75.05288"}
{"text": "( defun init - device - faces ( device ) ; ; First , add any device - local face resources .( when init - face - from - resources ( loop for face in ( face - list ) do ( init - face - from - resources face device ) ) ; ; Then do any device - specific initialization .", "label": "", "metadata": {}, "score": "75.14931"}
{"text": "( defun init - device - faces ( device ) ; ; First , add any device - local face resources .( when init - face - from - resources ( loop for face in ( face - list ) do ( init - face - from - resources face device ) ) ; ; Then do any device - specific initialization .", "label": "", "metadata": {}, "score": "75.14931"}
{"text": "blinking Blink all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .reverse Reverse the foreground and background colors .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "75.205215"}
{"text": "blinking Blink all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .reverse Reverse the foreground and background colors .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "75.205215"}
{"text": "Script instance .If the referent is a function proxy or not debuggee code , this is undefined .If the referent is a function that is debuggee code , a Debugger .Environment instance representing the lexical environment enclosing the function when it was created .", "label": "", "metadata": {}, "score": "75.49207"}
{"text": "There is no well - formed sentence in natural language ( including \" colorless green ideas sleep furiously \" ) that we can not \" gloss , \" as long as all its terms are grounded in thoughts that are about what the words are about .", "label": "", "metadata": {}, "score": "75.58357"}
{"text": "There is no well - formed sentence in natural language ( including \" colorless green ideas sleep furiously \" ) that we can not \" gloss , \" as long as all its terms are grounded in thoughts that are about what the words are about .", "label": "", "metadata": {}, "score": "75.58357"}
{"text": "( interactive ( face - interactive \" background - pixmap \" ) ) ( set - face - property face ' background - pixmap pixmap locale tag - set how - to - add ) ) ( defun face - display - table ( face & optional locale tag - set exact - p ) \" Return the display table of FACE in LOCALE .", "label": "", "metadata": {}, "score": "75.62459"}
{"text": "( interactive ( face - interactive \" background - pixmap \" ) ) ( set - face - property face ' background - pixmap pixmap locale tag - set how - to - add ) ) ( defun face - display - table ( face & optional locale tag - set exact - p ) \" Return the display table of FACE in LOCALE .", "label": "", "metadata": {}, "score": "75.62459"}
{"text": "If you want to add code to do stuff like this , use the create - device - hook .\" ; ; try to make ' bold look different from the default on this device .; ; If that does n't work at all , then issue a warning . ; ; It 's unreasonable to expect to be able to make a font italic all ; ; the time .", "label": "", "metadata": {}, "score": "76.185905"}
{"text": "If you want to add code to do stuff like this , use the create - device - hook .\" ; ; try to make ' bold look different from the default on this device .; ; If that does n't work at all , then issue a warning . ; ; It 's unreasonable to expect to be able to make a font italic all ; ; the time .", "label": "", "metadata": {}, "score": "76.185905"}
{"text": "If the referent is not a function proxy whose handler object was allocated by debuggee code , this is null .If the referent is a function proxy whose handler object was allocated by debuggee code , its construction trap function \u2014 the function called when the function proxy is called via a new expression .", "label": "", "metadata": {}, "score": "76.27757"}
{"text": "\" gray53 \" ) ) ' global ) ( set - face - background - pixmap ' highlight ' ( ( ( x default mono ) . \"gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' zmacs - region ' ( ( ( x default color ) . \"", "label": "", "metadata": {}, "score": "77.256256"}
{"text": "\" gray53 \" ) ) ' global ) ( set - face - background - pixmap ' highlight ' ( ( ( x default mono ) . \"gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' zmacs - region ' ( ( ( x default color ) . \"", "label": "", "metadata": {}, "score": "77.256256"}
{"text": "If it is a function , SpiderMonkey calls it when execution in this frame makes a small amount of progress , passing no arguments and providing this Debugger .Frame instance as the thisvalue .If multiple Debugger instances each have Debugger .", "label": "", "metadata": {}, "score": "77.35533"}
{"text": "Object.prototype.defineProperty , giving the newly added property 's attributes .The existing property named name on the referent is being changed from those given by oldDescriptor to those given by newDescriptor .This handler method is only called when attributes of the property other than its value are being changed ; if only the value is changing , SpiderMonkey calls the handler 's set method .", "label": "", "metadata": {}, "score": "77.63364"}
{"text": "The debuggee will only resume execution when you return from the handler method that brought control to the debugger originally .SpiderMonkey supports generator - iterator objects , which produce a series of values by repeatedly suspending the execution of a function or expression .", "label": "", "metadata": {}, "score": "78.09894"}
{"text": "If implementation restrictions prevent SpiderMonkey from extending this frame 's environment as requested , this call throws an Error exception .Like eval , but evaluate code in the environment of this frame , extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "78.58626"}
{"text": "[ italic ] ) ) ) ) ( defun make - face - unitalic ( face & optional locale ) \" Make FACE non - italic in LOCALE , if possible .This will attempt to make the font non - italic for X locales and will unset the underline flag for TTY locales .", "label": "", "metadata": {}, "score": "78.61638"}
{"text": "[ italic ] ) ) ) ) ( defun make - face - unitalic ( face & optional locale ) \" Make FACE non - italic in LOCALE , if possible .This will attempt to make the font non - italic for X locales and will unset the underline flag for TTY locales .", "label": "", "metadata": {}, "score": "78.61638"}
{"text": "emacs files .( define - obsolete - variable - alias ' custom - background - mode ' frame - background - mode ) ( defun get - frame - background - mode ( frame ) \" Detect background mode for FRAME .", "label": "", "metadata": {}, "score": "79.35632"}
{"text": "emacs files .( define - obsolete - variable - alias ' custom - background - mode ' frame - background - mode ) ( defun get - frame - background - mode ( frame ) \" Detect background mode for FRAME .", "label": "", "metadata": {}, "score": "79.35632"}
{"text": "If implementation restrictions prevent SpiderMonkey from extending this frame 's environment as requested , this call throws an Error exception .Note that this does not resume the debuggee 's execution ; it merely adjusts the debuggee 's state to what it would be if this frame 's execution had completed .", "label": "", "metadata": {}, "score": "79.84991"}
{"text": "Colour ( x , c ) holds after Move ( x , p ) if Colour ( x , c ) held beforehand .Position ( x , p ) holds after Paint ( x , c ) if Position ( x , p ) held beforehand .", "label": "", "metadata": {}, "score": "79.90028"}
{"text": "; ; ; ; The default , modeline , left - margin , right - margin , text - cursor , ; ; and pointer faces are created in C. ( make - face ' bold \" Bold text . \" ) ( make - face ' italic \" Italic text . \" ) ( make - face ' bold - italic \" Bold - italic text . \" ) ( make - face ' underline \" Underlined text . \" ) ( or ( face - differs - from - default - p ' underline ) ( set - face - underline - p ' underline t ' global ' ( default ) ) ) ( make - face ' zmacs - region \" Used on highlightes region between point and mark . \" ) ( make - face ' isearch \" Used on region matched by isearch . \" ) ( make - face ' list - mode - item - selected \" Face for the selected list item in list - mode . \" ) ( make - face ' highlight \" Highlight face . \" ) ( make - face ' primary - selection \" Primary selection face . \" ) ( make - face ' secondary - selection \" Secondary selection face . \" ) ; ; Several useful color faces .", "label": "", "metadata": {}, "score": "80.85846"}
{"text": "; ; ; ; The default , modeline , left - margin , right - margin , text - cursor , ; ; and pointer faces are created in C. ( make - face ' bold \" Bold text . \" ) ( make - face ' italic \" Italic text . \" ) ( make - face ' bold - italic \" Bold - italic text . \" ) ( make - face ' underline \" Underlined text . \" ) ( or ( face - differs - from - default - p ' underline ) ( set - face - underline - p ' underline t ' global ' ( default ) ) ) ( make - face ' zmacs - region \" Used on highlightes region between point and mark . \" ) ( make - face ' isearch \" Used on region matched by isearch . \" ) ( make - face ' list - mode - item - selected \" Face for the selected list item in list - mode . \" ) ( make - face ' highlight \" Highlight face . \" ) ( make - face ' primary - selection \" Primary selection face . \" ) ( make - face ' secondary - selection \" Secondary selection face . \" ) ; ; Several useful color faces .", "label": "", "metadata": {}, "score": "80.85846"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works . \" t ) ( [ bold ] .[ default ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "80.883255"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works . \" t ) ( [ bold ] .[ default ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "80.883255"}
{"text": "gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' isearch ' ( ( ( x default color ) .\" paleturquoise \" ) ( ( x default color ) .", "label": "", "metadata": {}, "score": "80.973076"}
{"text": "gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' isearch ' ( ( ( x default color ) .\" paleturquoise \" ) ( ( x default color ) .", "label": "", "metadata": {}, "score": "80.973076"}
{"text": "-hniksic ; ; In a Solaris Japanese environment , there just are n't any italic ; ; fonts - period .So we first try to make the font bold before ; ; complaining .( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - bold - italic ' bold - italic device ) ; ; if we could n't get a bold - italic version , try just bold .", "label": "", "metadata": {}, "score": "81.42433"}
{"text": "-hniksic ; ; In a Solaris Japanese environment , there just are n't any italic ; ; fonts - period .So we first try to make the font bold before ; ; complaining .( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - bold - italic ' bold - italic device ) ; ; if we could n't get a bold - italic version , try just bold .", "label": "", "metadata": {}, "score": "81.42433"}
{"text": "For example , in Firefox , code in privileged compartments sees content DOM element objects without redefinitions or extensions made to that object 's properties by content code .( In Firefox terminology , privileged code sees the element through an \" xray wrapper \" . )", "label": "", "metadata": {}, "score": "81.47958"}
{"text": "Position ( x , p ) holds after Move ( x , p ) .Now , suppose we have an initial situation in which Colour ( A , Red ) and Position ( A , House ) hold .According to the machinery of deductive logic , what then holds after the action Paint ( A , Blue ) followed by the action Move ( A , Garden ) ?", "label": "", "metadata": {}, "score": "81.65105"}
{"text": "[ default background ] ) ( ( mswindows default mono ) .[ default background ] ) ) ' global ) ( set - face - background ' primary - selection ' ( ( ( x default color ) . \"gray65 \" ) ( ( x default grayscale ) . \"", "label": "", "metadata": {}, "score": "81.84448"}
{"text": "[ default background ] ) ( ( mswindows default mono ) .[ default background ] ) ) ' global ) ( set - face - background ' primary - selection ' ( ( ( x default color ) . \"gray65 \" ) ( ( x default grayscale ) . \"", "label": "", "metadata": {}, "score": "81.84448"}
{"text": "In a universe that can include fridgeons , can it really be the case that most actions leave most things unchanged ?The point here is not a logical one .The effect on fridgeons of switching Fodor 's fridge on and off can concisely be represented without any difficulty ( Shanahan 1997 , 25 ) .", "label": "", "metadata": {}, "score": "84.19513"}
{"text": "; ; Basically , because italic is not a globally meaningful concept , ; ; the use of the italic face should really be oboleted .; ; I disagree with above .In many languages , the concept of capital ; ; letters is just as alien , and yet we use them .", "label": "", "metadata": {}, "score": "84.72116"}
{"text": "; ; Basically , because italic is not a globally meaningful concept , ; ; the use of the italic face should really be oboleted .; ; I disagree with above .In many languages , the concept of capital ; ; letters is just as alien , and yet we use them .", "label": "", "metadata": {}, "score": "84.72116"}
{"text": "\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - unbold ( face & optional locale ) \" Make FACE non - bold in LOCALE , if possible .", "label": "", "metadata": {}, "score": "85.22245"}
{"text": "\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - unbold ( face & optional locale ) \" Make FACE non - bold in LOCALE , if possible .", "label": "", "metadata": {}, "score": "85.22245"}
{"text": "Environment instance represents . )If implementation restrictions prevent SpiderMonkey from extending this environment as requested , this call throws an Error exception .Like eval , but evaluate code in this environment , extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "85.708244"}
{"text": "; ; ; Commentary : ; ; This file is dumped with XEmacs .; ; face implementation # 2 ( used one face object per frame per face ) ; ; authored by Jamie Zawinski for 19.9 .; ; ; Some stuff in FSF 's faces.el is in our x - faces .", "label": "", "metadata": {}, "score": "86.694855"}
{"text": "; ; ; Commentary : ; ; This file is dumped with XEmacs .; ; face implementation # 2 ( used one face object per frame per face ) ; ; authored by Jamie Zawinski for 19.9 .; ; ; Some stuff in FSF 's faces.el is in our x - faces .", "label": "", "metadata": {}, "score": "86.694855"}
{"text": "Script instance for a given script .This allows the code using each Debugger instance to place whatever properties it likes on its Debugger .Script instances , without worrying about interfering with other debuggers . )Note that SpiderMonkey may use the same Debugger .", "label": "", "metadata": {}, "score": "86.81955"}
{"text": "When SpiderMonkey calls an onPop handler for a frame that is throwing an exception or being terminated , and the handler returns undefined , then SpiderMonkey proceeds with the exception or termination .That is , an undefined resumption value leaves the frame 's throwing and termination process undisturbed .", "label": "", "metadata": {}, "score": "87.29672"}
{"text": "If uncaughtExceptionHook 's value is null , SpiderMonkey throws an exception to the debuggee whose message blames the debugger , and includes a textual description of debugger - exception .( This is not an ideal way to handle debugger bugs , but the hope here is that some sort of backstop , even if imperfect , will make life easier for debugger developers .", "label": "", "metadata": {}, "score": "90.22498"}
{"text": "\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ( ( mswindows default grayscale ) .", "label": "", "metadata": {}, "score": "90.54442"}
{"text": "\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ( ( mswindows default grayscale ) .", "label": "", "metadata": {}, "score": "90.54442"}
{"text": "gray65 \" ) ( ( mswindows default color ) . \"gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' zmacs - region ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' list - mode - item - selected ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.7713"}
{"text": "gray65 \" ) ( ( mswindows default color ) . \"gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' zmacs - region ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' list - mode - item - selected ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.7713"}
{"text": "gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' primary - selection ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' secondary - selection ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.98826"}
{"text": "gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' primary - selection ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' secondary - selection ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.98826"}
{"text": "\" [ bold ] ) ( [ bold ] .t ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - italic ( face & optional locale ) \" Make FACE italic in LOCALE , if possible .", "label": "", "metadata": {}, "score": "91.29538"}
{"text": "\" [ bold ] ) ( [ bold ] .t ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - italic ( face & optional locale ) \" Make FACE italic in LOCALE , if possible .", "label": "", "metadata": {}, "score": "91.29538"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works .\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "91.84761"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works .\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "91.84761"}
{"text": "Need to ; ; separate out the font elements as separate face properties ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! !", "label": "", "metadata": {}, "score": "92.94778"}
{"text": "Need to ; ; separate out the font elements as separate face properties ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! !", "label": "", "metadata": {}, "score": "92.94778"}
{"text": "But if the structure in ( 31 ) is not a legal elementary tree , then how is it possible to build the structure in ( 29 ) ?Let us work up to the answer to this question by first considering the adjunctless sentence They eat five apples .", "label": "", "metadata": {}, "score": "93.1452"}
{"text": "Then flight ( NewYork Boston ) , closure ( flight ) ( NewYork Boston ) , parent ( John Mary ) , and closure ( parent ) ( John Mary ) would be well - formed formulas .Such formulas are allowed in languages like HiLog , which support predicate constructors like closure in the above example .", "label": "", "metadata": {}, "score": "93.35598"}
{"text": "Then flight ( NewYork Boston ) , closure ( flight ) ( NewYork Boston ) , parent ( John Mary ) , and closure ( parent ) ( John Mary ) would be well - formed formulas .Such formulas are allowed in languages like HiLog , which support predicate constructors like closure in the above example .", "label": "", "metadata": {}, "score": "93.35598"}
{"text": "( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - unbold ' bold - italic device ) ( make - face - italic ' bold - italic device ) ( unless ( face - differs - from - default - p ' bold - italic device ) ; ; if that did n't work , try plain italic ; ; ( can this ever happen ? what the hell . )", "label": "", "metadata": {}, "score": "98.04983"}
{"text": "( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - unbold ' bold - italic device ) ( make - face - italic ' bold - italic device ) ( unless ( face - differs - from - default - p ' bold - italic device ) ; ; if that did n't work , try plain italic ; ; ( can this ever happen ? what the hell . )", "label": "", "metadata": {}, "score": "98.04983"}
{"text": "\" gray68 \" ) ( ( x default mono ) .[ default foreground ] ) ( ( mswindows default color ) .\" gray68 \" ) ( ( mswindows default grayscale ) .\" gray68 \" ) ( ( mswindows default mono ) .", "label": "", "metadata": {}, "score": "98.35419"}
{"text": "\" gray68 \" ) ( ( x default mono ) .[ default foreground ] ) ( ( mswindows default color ) .\" gray68 \" ) ( ( mswindows default grayscale ) .\" gray68 \" ) ( ( mswindows default mono ) .", "label": "", "metadata": {}, "score": "98.35419"}
{"text": "\" darkseagreen2 \" ) ( ( x default color ) .\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" darkseagreen2 \" ) ( ( mswindows default color ) .", "label": "", "metadata": {}, "score": "102.28813"}
{"text": "\" darkseagreen2 \" ) ( ( x default color ) .\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" darkseagreen2 \" ) ( ( mswindows default color ) .", "label": "", "metadata": {}, "score": "102.28813"}
{"text": "Either null or a function that SpiderMonkey calls when a call to a debug event handler , breakpoint handler , watchpoint handler , or similar function throws some exception , debugger - exception .Exceptions thrown in the debugger are not propagated to debuggee code ; instead , SpiderMonkey calls this function , passing debugger - exception as its sole argument and the Debugger instance as the this value .", "label": "", "metadata": {}, "score": "104.235794"}
